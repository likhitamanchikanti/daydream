{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst Connection = require('./connection');\n\nconst Query = require('./commands').Query;\n\nconst createClientInfo = require('../topologies/shared').createClientInfo;\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, callback) {\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  if (options.family !== void 0) {\n    makeConnection(options.family, options, (err, socket) => {\n      if (err) {\n        callback(err, socket); // in the error case, `socket` is the originating error event name\n\n        return;\n      }\n\n      performInitialHandshake(new Connection(socket, options), options, callback);\n    });\n    return;\n  }\n\n  return makeConnection(6, options, (err, ipv6Socket) => {\n    if (err) {\n      makeConnection(4, options, (err, ipv4Socket) => {\n        if (err) {\n          callback(err, ipv4Socket); // in the error case, `ipv4Socket` is the originating error event name\n\n          return;\n        }\n\n        performInitialHandshake(new Connection(ipv4Socket, options), options, callback);\n      });\n      return;\n    }\n\n    performInitialHandshake(new Connection(ipv6Socket, options), options, callback);\n  });\n}\n\nfunction getSaslSupportedMechs(options) {\n  if (!(options && options.credentials)) {\n    return {};\n  }\n\n  const credentials = options.credentials; // TODO: revisit whether or not items like `options.user` and `options.dbName` should be checked here\n\n  const authMechanism = credentials.mechanism;\n  const authSource = credentials.source || options.dbName || 'admin';\n  const user = credentials.username || options.user;\n\n  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {\n    return {};\n  }\n\n  if (!user) {\n    return {};\n  }\n\n  return {\n    saslSupportedMechs: `${authSource}.${user}`\n  };\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  let compressors = [];\n\n  if (options.compression && options.compression.compressors) {\n    compressors = options.compression.compressors;\n  }\n\n  const handshakeDoc = Object.assign({\n    ismaster: true,\n    client: createClientInfo(options),\n    compression: compressors\n  }, getSaslSupportedMechs(options));\n  const start = new Date().getTime();\n  runCommand(conn, 'admin.$cmd', handshakeDoc, options, (err, ismaster) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    if (ismaster.ok === 0) {\n      callback(new MongoError(ismaster), null);\n      return;\n    }\n\n    const supportedServerErr = checkSupportedServer(ismaster, options);\n\n    if (supportedServerErr) {\n      callback(supportedServerErr, null);\n      return;\n    } // resolve compression\n\n\n    if (ismaster.compression) {\n      const agreedCompressors = compressors.filter(compressor => ismaster.compression.indexOf(compressor) !== -1);\n\n      if (agreedCompressors.length) {\n        conn.agreedCompressor = agreedCompressors[0];\n      }\n\n      if (options.compression && options.compression.zlibCompressionLevel) {\n        conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n      }\n    } // NOTE: This is metadata attached to the connection while porting away from\n    //       handshake being done in the `Server` class. Likely, it should be\n    //       relocated, or at very least restructured.\n\n\n    conn.ismaster = ismaster;\n    conn.lastIsMasterMS = new Date().getTime() - start;\n    const credentials = options.credentials;\n\n    if (!ismaster.arbiterOnly && credentials) {\n      credentials.resolveAuthMechanism(ismaster);\n      authenticate(conn, credentials, callback);\n      return;\n    }\n\n    callback(null, conn);\n  });\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n\n  if (host.indexOf('/') !== -1) {\n    return {\n      path: host\n    };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options); // Merge in valid SSL options\n\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  } // Override checkServerIdentity behavior\n\n\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nfunction makeConnection(family, options, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  const rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const errorEvents = ['error', 'close', 'timeout', 'parseError'];\n\n  function errorHandler(eventName) {\n    return err => {\n      errorEvents.forEach(event => socket.removeAllListeners(event));\n      socket.removeListener('connect', connectHandler);\n      callback(connectionFailureError(eventName, err), eventName);\n    };\n  }\n\n  function connectHandler() {\n    errorEvents.forEach(event => socket.removeAllListeners(event));\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  socket.once('error', errorHandler('error'));\n  socket.once('close', errorHandler('close'));\n  socket.once('timeout', errorHandler('timeout'));\n  socket.once('parseError', errorHandler('parseError'));\n  socket.once('connect', connectHandler);\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction runCommand(conn, ns, command, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  const bson = conn.options.bson;\n  const query = new Query(bson, ns, command, {\n    numberToSkip: 0,\n    numberToReturn: 1\n  });\n\n  function errorHandler(err) {\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n    conn.removeListener('message', messageHandler);\n    callback(err, null);\n  }\n\n  function messageHandler(msg) {\n    if (msg.responseTo !== query.requestId) {\n      return;\n    }\n\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n    conn.removeListener('message', messageHandler);\n    msg.parse({\n      promoteValues: true\n    });\n    callback(null, msg.documents[0]);\n  }\n\n  conn.setSocketTimeout(socketTimeout);\n  CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n  conn.on('message', messageHandler);\n  conn.write(query.toBin());\n}\n\nfunction authenticate(conn, credentials, callback) {\n  const mechanism = credentials.mechanism;\n\n  if (!AUTH_PROVIDERS[mechanism]) {\n    callback(new MongoError(`authMechanism '${mechanism}' not supported`));\n    return;\n  }\n\n  const provider = AUTH_PROVIDERS[mechanism];\n  provider.auth(runCommand, [conn], credentials, err => {\n    if (err) return callback(err);\n    callback(null, conn);\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n\n    case 'timeout':\n      return new MongoNetworkError(`connection timed out`);\n\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/connection/connect.js"],"names":["net","require","tls","Connection","Query","createClientInfo","MongoError","MongoNetworkError","defaultAuthProviders","WIRE_CONSTANTS","MAX_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MIN_SUPPORTED_SERVER_VERSION","AUTH_PROVIDERS","connect","options","callback","bson","family","makeConnection","err","socket","performInitialHandshake","ipv6Socket","ipv4Socket","getSaslSupportedMechs","credentials","authMechanism","mechanism","authSource","source","dbName","user","username","toUpperCase","saslSupportedMechs","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","serverVersionLowEnough","minWireVersion","message","host","port","conn","_callback","ret","destroy","compressors","compression","handshakeDoc","Object","assign","client","start","Date","getTime","runCommand","ok","supportedServerErr","agreedCompressors","filter","compressor","indexOf","length","agreedCompressor","zlibCompressionLevel","lastIsMasterMS","arbiterOnly","resolveAuthMechanism","authenticate","LEGAL_SSL_SOCKET_OPTIONS","parseConnectOptions","path","result","rejectUnauthorized","parseSslOptions","name","checkServerIdentity","undefined","servername","useSsl","ssl","keepAlive","keepAliveInitialDelay","noDelay","connectionTimeout","socketTimeout","Math","round","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","errorEvents","errorHandler","eventName","forEach","event","removeAllListeners","removeListener","connectHandler","connectionFailureError","authorizationError","once","CONNECTION_ERROR_EVENTS","ns","command","query","numberToSkip","numberToReturn","resetSocketTimeout","messageHandler","msg","responseTo","requestId","parse","promoteValues","documents","setSocketTimeout","on","write","toBin","provider","auth","type","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\nconst net = require('net');\r\nconst tls = require('tls');\r\nconst Connection = require('./connection');\r\nconst Query = require('./commands').Query;\r\nconst createClientInfo = require('../topologies/shared').createClientInfo;\r\nconst MongoError = require('../error').MongoError;\r\nconst MongoNetworkError = require('../error').MongoNetworkError;\r\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\r\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\r\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\r\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\r\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\r\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\r\nlet AUTH_PROVIDERS;\r\n\r\nfunction connect(options, callback) {\r\n  if (AUTH_PROVIDERS == null) {\r\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\r\n  }\r\n\r\n  if (options.family !== void 0) {\r\n    makeConnection(options.family, options, (err, socket) => {\r\n      if (err) {\r\n        callback(err, socket); // in the error case, `socket` is the originating error event name\r\n        return;\r\n      }\r\n\r\n      performInitialHandshake(new Connection(socket, options), options, callback);\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  return makeConnection(6, options, (err, ipv6Socket) => {\r\n    if (err) {\r\n      makeConnection(4, options, (err, ipv4Socket) => {\r\n        if (err) {\r\n          callback(err, ipv4Socket); // in the error case, `ipv4Socket` is the originating error event name\r\n          return;\r\n        }\r\n\r\n        performInitialHandshake(new Connection(ipv4Socket, options), options, callback);\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    performInitialHandshake(new Connection(ipv6Socket, options), options, callback);\r\n  });\r\n}\r\n\r\nfunction getSaslSupportedMechs(options) {\r\n  if (!(options && options.credentials)) {\r\n    return {};\r\n  }\r\n\r\n  const credentials = options.credentials;\r\n\r\n  // TODO: revisit whether or not items like `options.user` and `options.dbName` should be checked here\r\n  const authMechanism = credentials.mechanism;\r\n  const authSource = credentials.source || options.dbName || 'admin';\r\n  const user = credentials.username || options.user;\r\n\r\n  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {\r\n    return {};\r\n  }\r\n\r\n  if (!user) {\r\n    return {};\r\n  }\r\n\r\n  return { saslSupportedMechs: `${authSource}.${user}` };\r\n}\r\n\r\nfunction checkSupportedServer(ismaster, options) {\r\n  const serverVersionHighEnough =\r\n    ismaster &&\r\n    typeof ismaster.maxWireVersion === 'number' &&\r\n    ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\r\n  const serverVersionLowEnough =\r\n    ismaster &&\r\n    typeof ismaster.minWireVersion === 'number' &&\r\n    ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\r\n\r\n  if (serverVersionHighEnough) {\r\n    if (serverVersionLowEnough) {\r\n      return null;\r\n    }\r\n\r\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${\r\n      ismaster.minWireVersion\r\n    }, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\r\n    return new MongoError(message);\r\n  }\r\n\r\n  const message = `Server at ${options.host}:${\r\n    options.port\r\n  } reports maximum wire version ${ismaster.maxWireVersion ||\r\n    0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\r\n  return new MongoError(message);\r\n}\r\n\r\nfunction performInitialHandshake(conn, options, _callback) {\r\n  const callback = function(err, ret) {\r\n    if (err && conn) {\r\n      conn.destroy();\r\n    }\r\n    _callback(err, ret);\r\n  };\r\n\r\n  let compressors = [];\r\n  if (options.compression && options.compression.compressors) {\r\n    compressors = options.compression.compressors;\r\n  }\r\n\r\n  const handshakeDoc = Object.assign(\r\n    {\r\n      ismaster: true,\r\n      client: createClientInfo(options),\r\n      compression: compressors\r\n    },\r\n    getSaslSupportedMechs(options)\r\n  );\r\n\r\n  const start = new Date().getTime();\r\n  runCommand(conn, 'admin.$cmd', handshakeDoc, options, (err, ismaster) => {\r\n    if (err) {\r\n      callback(err, null);\r\n      return;\r\n    }\r\n\r\n    if (ismaster.ok === 0) {\r\n      callback(new MongoError(ismaster), null);\r\n      return;\r\n    }\r\n\r\n    const supportedServerErr = checkSupportedServer(ismaster, options);\r\n    if (supportedServerErr) {\r\n      callback(supportedServerErr, null);\r\n      return;\r\n    }\r\n\r\n    // resolve compression\r\n    if (ismaster.compression) {\r\n      const agreedCompressors = compressors.filter(\r\n        compressor => ismaster.compression.indexOf(compressor) !== -1\r\n      );\r\n\r\n      if (agreedCompressors.length) {\r\n        conn.agreedCompressor = agreedCompressors[0];\r\n      }\r\n\r\n      if (options.compression && options.compression.zlibCompressionLevel) {\r\n        conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\r\n      }\r\n    }\r\n\r\n    // NOTE: This is metadata attached to the connection while porting away from\r\n    //       handshake being done in the `Server` class. Likely, it should be\r\n    //       relocated, or at very least restructured.\r\n    conn.ismaster = ismaster;\r\n    conn.lastIsMasterMS = new Date().getTime() - start;\r\n\r\n    const credentials = options.credentials;\r\n    if (!ismaster.arbiterOnly && credentials) {\r\n      credentials.resolveAuthMechanism(ismaster);\r\n      authenticate(conn, credentials, callback);\r\n      return;\r\n    }\r\n\r\n    callback(null, conn);\r\n  });\r\n}\r\n\r\nconst LEGAL_SSL_SOCKET_OPTIONS = [\r\n  'pfx',\r\n  'key',\r\n  'passphrase',\r\n  'cert',\r\n  'ca',\r\n  'ciphers',\r\n  'NPNProtocols',\r\n  'ALPNProtocols',\r\n  'servername',\r\n  'ecdhCurve',\r\n  'secureProtocol',\r\n  'secureContext',\r\n  'session',\r\n  'minDHSize',\r\n  'crl',\r\n  'rejectUnauthorized'\r\n];\r\n\r\nfunction parseConnectOptions(family, options) {\r\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\r\n  if (host.indexOf('/') !== -1) {\r\n    return { path: host };\r\n  }\r\n\r\n  const result = {\r\n    family,\r\n    host,\r\n    port: typeof options.port === 'number' ? options.port : 27017,\r\n    rejectUnauthorized: false\r\n  };\r\n\r\n  return result;\r\n}\r\n\r\nfunction parseSslOptions(family, options) {\r\n  const result = parseConnectOptions(family, options);\r\n\r\n  // Merge in valid SSL options\r\n  for (const name in options) {\r\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\r\n      result[name] = options[name];\r\n    }\r\n  }\r\n\r\n  // Override checkServerIdentity behavior\r\n  if (options.checkServerIdentity === false) {\r\n    // Skip the identiy check by retuning undefined as per node documents\r\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\r\n    result.checkServerIdentity = function() {\r\n      return undefined;\r\n    };\r\n  } else if (typeof options.checkServerIdentity === 'function') {\r\n    result.checkServerIdentity = options.checkServerIdentity;\r\n  }\r\n\r\n  // Set default sni servername to be the same as host\r\n  if (result.servername == null) {\r\n    result.servername = result.host;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction makeConnection(family, options, _callback) {\r\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\r\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\r\n  let keepAliveInitialDelay =\r\n    typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\r\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\r\n  const connectionTimeout =\r\n    typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\r\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\r\n  const rejectUnauthorized =\r\n    typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\r\n\r\n  if (keepAliveInitialDelay > socketTimeout) {\r\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\r\n  }\r\n\r\n  let socket;\r\n  const callback = function(err, ret) {\r\n    if (err && socket) {\r\n      socket.destroy();\r\n    }\r\n    _callback(err, ret);\r\n  };\r\n\r\n  try {\r\n    if (useSsl) {\r\n      socket = tls.connect(parseSslOptions(family, options));\r\n      if (typeof socket.disableRenegotiation === 'function') {\r\n        socket.disableRenegotiation();\r\n      }\r\n    } else {\r\n      socket = net.createConnection(parseConnectOptions(family, options));\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\r\n  socket.setTimeout(connectionTimeout);\r\n  socket.setNoDelay(noDelay);\r\n\r\n  const errorEvents = ['error', 'close', 'timeout', 'parseError'];\r\n  function errorHandler(eventName) {\r\n    return err => {\r\n      errorEvents.forEach(event => socket.removeAllListeners(event));\r\n      socket.removeListener('connect', connectHandler);\r\n      callback(connectionFailureError(eventName, err), eventName);\r\n    };\r\n  }\r\n\r\n  function connectHandler() {\r\n    errorEvents.forEach(event => socket.removeAllListeners(event));\r\n    if (socket.authorizationError && rejectUnauthorized) {\r\n      return callback(socket.authorizationError);\r\n    }\r\n\r\n    socket.setTimeout(socketTimeout);\r\n    callback(null, socket);\r\n  }\r\n\r\n  socket.once('error', errorHandler('error'));\r\n  socket.once('close', errorHandler('close'));\r\n  socket.once('timeout', errorHandler('timeout'));\r\n  socket.once('parseError', errorHandler('parseError'));\r\n  socket.once('connect', connectHandler);\r\n}\r\n\r\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\r\nfunction runCommand(conn, ns, command, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\r\n  const bson = conn.options.bson;\r\n  const query = new Query(bson, ns, command, {\r\n    numberToSkip: 0,\r\n    numberToReturn: 1\r\n  });\r\n\r\n  function errorHandler(err) {\r\n    conn.resetSocketTimeout();\r\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\r\n    conn.removeListener('message', messageHandler);\r\n    callback(err, null);\r\n  }\r\n\r\n  function messageHandler(msg) {\r\n    if (msg.responseTo !== query.requestId) {\r\n      return;\r\n    }\r\n\r\n    conn.resetSocketTimeout();\r\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\r\n    conn.removeListener('message', messageHandler);\r\n\r\n    msg.parse({ promoteValues: true });\r\n    callback(null, msg.documents[0]);\r\n  }\r\n\r\n  conn.setSocketTimeout(socketTimeout);\r\n  CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\r\n  conn.on('message', messageHandler);\r\n  conn.write(query.toBin());\r\n}\r\n\r\nfunction authenticate(conn, credentials, callback) {\r\n  const mechanism = credentials.mechanism;\r\n  if (!AUTH_PROVIDERS[mechanism]) {\r\n    callback(new MongoError(`authMechanism '${mechanism}' not supported`));\r\n    return;\r\n  }\r\n\r\n  const provider = AUTH_PROVIDERS[mechanism];\r\n  provider.auth(runCommand, [conn], credentials, err => {\r\n    if (err) return callback(err);\r\n    callback(null, conn);\r\n  });\r\n}\r\n\r\nfunction connectionFailureError(type, err) {\r\n  switch (type) {\r\n    case 'error':\r\n      return new MongoNetworkError(err);\r\n    case 'timeout':\r\n      return new MongoNetworkError(`connection timed out`);\r\n    case 'close':\r\n      return new MongoNetworkError(`connection closed`);\r\n    default:\r\n      return new MongoNetworkError(`unknown network error`);\r\n  }\r\n}\r\n\r\nmodule.exports = connect;\r\n"]},"metadata":{},"sourceType":"script"}