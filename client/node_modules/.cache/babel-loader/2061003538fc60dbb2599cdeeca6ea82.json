{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\n\nconst Logger = require('./logger');\n\nconst f = require('util').format;\n\nconst Msg = require('./msg').Msg;\n\nconst CommandResult = require('./command_result');\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nconst opcodes = require('../wireprotocol/shared').opcodes;\n\nconst compress = require('../wireprotocol/compression').compress;\n\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\n\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\n\nconst apm = require('./apm');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst connect = require('./connect');\n\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\n\nconst eachAsync = require('../utils').eachAsync;\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYING = 'destroying';\nvar DESTROYED = 'destroyed';\nconst CONNECTION_EVENTS = new Set(['error', 'close', 'timeout', 'parseError', 'connect', 'message']);\nvar _id = 0;\n/**\r\n * Creates a new Pool instance\r\n * @class\r\n * @param {string} options.host The server host\r\n * @param {number} options.port The server port\r\n * @param {number} [options.size=5] Max server connection pool size\r\n * @param {number} [options.minSize=0] Minimum server connection pool size\r\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\r\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\r\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\r\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passPhrase] SSL Certificate pass phrase\r\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @fires Pool#connect\r\n * @fires Pool#close\r\n * @fires Pool#error\r\n * @fires Pool#timeout\r\n * @fires Pool#parseError\r\n * @return {Pool} A cursor instance\r\n */\n\nvar Pool = function (topology, options) {\n  // Add event listener\n  EventEmitter.call(this); // Store topology for later use\n\n  this.topology = topology; // Add the options\n\n  this.options = Object.assign({\n    // Host and port settings\n    host: 'localhost',\n    port: 27017,\n    // Pool default max size\n    size: 5,\n    // Pool default min size\n    minSize: 0,\n    // socket settings\n    connectionTimeout: 30000,\n    socketTimeout: 360000,\n    keepAlive: true,\n    keepAliveInitialDelay: 300000,\n    noDelay: true,\n    // SSL Settings\n    ssl: false,\n    checkServerIdentity: true,\n    ca: null,\n    crl: null,\n    cert: null,\n    key: null,\n    passPhrase: null,\n    rejectUnauthorized: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    // Reconnection options\n    reconnect: true,\n    reconnectInterval: 1000,\n    reconnectTries: 30,\n    // Enable domains\n    domainsEnabled: false\n  }, options); // Identification information\n\n  this.id = _id++; // Current reconnect retries\n\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null; // No bson parser passed in\n\n  if (!options.bson || options.bson && (typeof options.bson.serialize !== 'function' || typeof options.bson.deserialize !== 'function')) {\n    throw new Error('must pass in valid bson parser');\n  } // Logger instance\n\n\n  this.logger = Logger('Pool', options); // Pool state\n\n  this.state = DISCONNECTED; // Connections\n\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = 0; // Currently executing\n\n  this.executing = false; // Operation work queue\n\n  this.queue = []; // Contains the reconnect connection\n\n  this.reconnectConnection = null; // Number of consecutive timeouts caught\n\n  this.numberOfConsecutiveTimeouts = 0; // Current pool Index\n\n  this.connectionIndex = 0; // event handlers\n\n  const pool = this;\n  this._messageHandler = messageHandler(this);\n\n  this._connectionCloseHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'close', err, connection);\n  };\n\n  this._connectionErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'error', err, connection);\n  };\n\n  this._connectionTimeoutHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'timeout', err, connection);\n  };\n\n  this._connectionParseErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'parseError', err, connection);\n  };\n};\n\ninherits(Pool, EventEmitter);\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function () {\n    return this.options.size;\n  }\n});\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function () {\n    return this.options.minSize;\n  }\n});\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.connectionTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.socketTimeout;\n  }\n}); // clears all pool state\n\nfunction resetPoolState(pool) {\n  pool.inUseConnections = [];\n  pool.availableConnections = [];\n  pool.connectingConnections = 0;\n  pool.executing = false;\n  pool.reconnectConnection = null;\n  pool.numberOfConsecutiveTimeouts = 0;\n  pool.connectionIndex = 0;\n  pool.retriesLeft = pool.options.reconnectTries;\n  pool.reconnectId = null;\n}\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYING, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYING],\n    destroying: [DESTROYING, DESTROYED],\n    destroyed: [DESTROYED]\n  }; // Get current state\n\n  var legalStates = legalTransitions[self.state];\n\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.emit('stateChanged', self.state, newState);\n    self.state = newState;\n  } else {\n    self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));\n  }\n}\n\nfunction connectionFailureHandler(pool, event, err, conn) {\n  if (conn) {\n    if (conn._connectionFailHandled) return;\n    conn._connectionFailHandled = true;\n    conn.destroy(); // Remove the connection\n\n    removeConnection(pool, conn); // Flush all work Items on this connection\n\n    while (conn.workItems.length > 0) {\n      const workItem = conn.workItems.shift();\n      if (workItem.cb) workItem.cb(err);\n    }\n  } // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n\n\n  if (event === 'timeout') {\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1; // Have we timed out more than reconnectTries in a row ?\n    // Force close the pool as we are trying to connect to tcp sink hole\n\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\n      pool.numberOfConsecutiveTimeouts = 0; // Destroy all connections and pool\n\n      pool.destroy(true); // Emit close event\n\n      return pool.emit('close', pool);\n    }\n  } // No more socket available propegate the event\n\n\n  if (pool.socketCount() === 0) {\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING) {\n      stateTransition(pool, DISCONNECTED);\n    } // Do not emit error events, they are always close events\n    // do not trigger the low level error handler in node\n\n\n    event = event === 'error' ? 'close' : event;\n    pool.emit(event, err);\n  } // Start reconnection attempts\n\n\n  if (!pool.reconnectId && pool.options.reconnect) {\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\n  } // Do we need to do anything to maintain the minimum pool size\n\n\n  const totalConnections = totalConnectionCount(pool);\n\n  if (totalConnections < pool.minSize) {\n    _createConnection(pool);\n  }\n}\n\nfunction attemptReconnect(self) {\n  return function () {\n    self.emit('attemptReconnect', self);\n    if (self.state === DESTROYED || self.state === DESTROYING) return; // We are connected do not try again\n\n    if (self.isConnected()) {\n      self.reconnectId = null;\n      return;\n    }\n\n    self.connectingConnections++;\n    connect(self.options, (err, connection) => {\n      self.connectingConnections--;\n\n      if (err) {\n        if (self.logger.isDebug()) {\n          self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n        }\n\n        self.retriesLeft = self.retriesLeft - 1;\n\n        if (self.retriesLeft <= 0) {\n          self.destroy();\n          self.emit('reconnectFailed', new MongoNetworkError(f('failed to reconnect after %s attempts with interval %s ms', self.options.reconnectTries, self.options.reconnectInterval)));\n        } else {\n          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n        }\n\n        return;\n      }\n\n      if (self.state === DESTROYED || self.state === DESTROYING) {\n        return connection.destroy();\n      }\n\n      self.reconnectId = null;\n      handlers.forEach(event => connection.removeAllListeners(event));\n      connection.on('error', self._connectionErrorHandler);\n      connection.on('close', self._connectionCloseHandler);\n      connection.on('timeout', self._connectionTimeoutHandler);\n      connection.on('parseError', self._connectionParseErrorHandler);\n      connection.on('message', self._messageHandler);\n      self.retriesLeft = self.options.reconnectTries;\n      self.availableConnections.push(connection);\n      self.reconnectConnection = null;\n      self.emit('reconnect', self);\n\n      _execute(self)();\n    });\n  };\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection); // Move the connection from connecting to available\n\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function (message, connection) {\n    // workItem to execute\n    var workItem = null; // Locate the workItem\n\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i]; // Remove from list of workItems\n\n        connection.workItems.splice(i, 1);\n      }\n    }\n\n    if (workItem && workItem.monitoring) {\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n    } // Reset timeout counter\n\n\n    self.numberOfConsecutiveTimeouts = 0; // Reset the connection timeout if we modified it for\n    // this operation\n\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    } // Log if debug enabled\n\n\n    if (self.logger.isDebug()) {\n      self.logger.debug(f('message [%s] received from %s:%s', message.raw.toString('hex'), self.options.host, self.options.port));\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function () {\n          return cb(err, result);\n        });\n      } // Domain enabled just call the callback\n\n\n      cb(err, result);\n    } // Keep executing, ensure current message handler does not stop execution\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    } // Time to dispatch the message if we have a callback\n\n\n    if (workItem && !workItem.immediateRelease) {\n      try {\n        // Parse the message according to the provided options\n        message.parse(workItem);\n      } catch (err) {\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\n      }\n\n      if (message.documents[0]) {\n        const document = message.documents[0];\n        const session = workItem.session;\n\n        if (session) {\n          updateSessionFromResponse(session, document);\n        }\n\n        if (document.$clusterTime) {\n          self.topology.clusterTime = document.$clusterTime;\n        }\n      } // Establish if we have an error\n\n\n      if (workItem.command && message.documents[0]) {\n        const responseDoc = message.documents[0];\n\n        if (responseDoc.writeConcernError) {\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\n          return handleOperationCallback(self, workItem.cb, err);\n        }\n\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n        }\n      } // Add the connection details\n\n\n      message.hashedName = connection.hashedName; // Return the documents\n\n      handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));\n    }\n  };\n}\n/**\r\n * Return the total socket count in the pool.\r\n * @method\r\n * @return {Number} The number of socket available.\r\n */\n\n\nPool.prototype.socketCount = function () {\n  return this.availableConnections.length + this.inUseConnections.length; // + this.connectingConnections.length;\n};\n\nfunction totalConnectionCount(pool) {\n  return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;\n}\n/**\r\n * Return all pool connections\r\n * @method\r\n * @return {Connection[]} The pool connections\r\n */\n\n\nPool.prototype.allConnections = function () {\n  return this.availableConnections.concat(this.inUseConnections);\n};\n/**\r\n * Get a pool connection (round-robin)\r\n * @method\r\n * @return {Connection}\r\n */\n\n\nPool.prototype.get = function () {\n  return this.allConnections()[0];\n};\n/**\r\n * Is the pool connected\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nPool.prototype.isConnected = function () {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  } // Get connections\n\n\n  var connections = this.availableConnections.concat(this.inUseConnections); // Check if we have any connected connections\n\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  } // Not connected\n\n\n  return false;\n};\n/**\r\n * Was the pool destroyed\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nPool.prototype.isDestroyed = function () {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n/**\r\n * Is the pool in a disconnected state\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nPool.prototype.isDisconnected = function () {\n  return this.state === DISCONNECTED;\n};\n/**\r\n * Connect pool\r\n */\n\n\nPool.prototype.connect = function () {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  const self = this;\n  stateTransition(this, CONNECTING);\n  self.connectingConnections++;\n  connect(self.options, (err, connection) => {\n    self.connectingConnections--;\n\n    if (err) {\n      if (self.logger.isDebug()) {\n        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      }\n\n      if (self.state === CONNECTING) {\n        self.emit('error', err);\n      }\n\n      return;\n    }\n\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      return self.destroy();\n    } // attach event handlers\n\n\n    connection.on('error', self._connectionErrorHandler);\n    connection.on('close', self._connectionCloseHandler);\n    connection.on('timeout', self._connectionTimeoutHandler);\n    connection.on('parseError', self._connectionParseErrorHandler);\n    connection.on('message', self._messageHandler); // If we are in a topology, delegate the auth to it\n    // This is to avoid issues where we would auth against an\n    // arbiter\n\n    if (self.options.inTopology) {\n      stateTransition(self, CONNECTED);\n      self.availableConnections.push(connection);\n      return self.emit('connect', self, connection);\n    }\n\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      return self.destroy();\n    }\n\n    if (err) {\n      self.destroy();\n      return self.emit('error', err);\n    }\n\n    stateTransition(self, CONNECTED);\n    self.availableConnections.push(connection);\n\n    if (self.minSize) {\n      for (let i = 0; i < self.minSize; i++) {\n        _createConnection(self);\n      }\n    }\n\n    self.emit('connect', self, connection);\n  });\n};\n/**\r\n * Authenticate using a specified mechanism\r\n * @param {authResultCallback} callback A callback function\r\n */\n\n\nPool.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\r\n * Logout all users against a database\r\n * @param {authResultCallback} callback A callback function\r\n */\n\n\nPool.prototype.logout = function (dbName, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\r\n * Unref the pool\r\n * @method\r\n */\n\n\nPool.prototype.unref = function () {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n  connections.forEach(function (c) {\n    c.unref();\n  });\n}; // Destroy the connections\n\n\nfunction destroy(self, connections, options, callback) {\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    }\n\n    conn.destroy(options, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') callback(err, null);\n      return;\n    }\n\n    resetPoolState(self);\n    self.queue = [];\n    stateTransition(self, DESTROYED);\n    if (typeof callback === 'function') callback(null, null);\n  });\n}\n/**\r\n * Destroy pool\r\n * @method\r\n */\n\n\nPool.prototype.destroy = function (force, callback) {\n  var self = this; // Do not try again if the pool is already dead\n\n  if (this.state === DESTROYED || self.state === DESTROYING) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  } // Set state to destroyed\n\n\n  stateTransition(this, DESTROYING); // Are we force closing\n\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections); // Flush any remaining work items with\n    // an error\n\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    } // Destroy the topology\n\n\n    return destroy(self, connections, {\n      force: true\n    }, callback);\n  } // Clear out the reconnect if set\n\n\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  } // If we have a reconnect connection running, close\n  // immediately\n\n\n  if (this.reconnectConnection) {\n    this.reconnectConnection.destroy();\n  } // Wait for the operations to drain before we close the pool\n\n\n  function checkStatus() {\n    flushMonitoringOperations(self.queue);\n\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections); // Check if we have any in flight operations\n\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections, {\n        force: false\n      }, callback); // } else if (self.queue.length > 0 && !this.reconnectId) {\n    } else {\n      // Ensure we empty the queue\n      _execute(self)(); // Set timeout\n\n\n      setTimeout(checkStatus, 1);\n    }\n  } // Initiate drain of operations\n\n\n  checkStatus();\n};\n/**\r\n * Reset all connections of this pool\r\n *\r\n * @param {function} [callback]\r\n */\n\n\nPool.prototype.reset = function (callback) {\n  const connections = this.availableConnections.concat(this.inUseConnections);\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    }\n\n    conn.destroy({\n      force: true\n    }, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') {\n        callback(err, null);\n        return;\n      }\n    }\n\n    resetPoolState(this); // create an initial connection, and kick off execution again\n\n    _createConnection(this);\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  });\n}; // Prepare the buffer that Pool.prototype.write() uses to send to the server\n\n\nfunction serializeCommand(self, command, callback) {\n  const originalCommandBuffer = command.toBin(); // Check whether we and the server have agreed to use a compressor\n\n  const shouldCompress = !!self.options.agreedCompressor;\n\n  if (!shouldCompress || !canCompress(command)) {\n    return callback(null, originalCommandBuffer);\n  } // Transform originalCommandBuffer into OP_COMPRESSED\n\n\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n  compress(self, messageToBeCompressed, function (err, compressedMessage) {\n    if (err) return callback(err, null); // Create the msgHeader of OP_COMPRESSED\n\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n    // Create the compression details of OP_COMPRESSED\n\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\n  });\n}\n/**\r\n * Write a message to MongoDB\r\n * @method\r\n * @return {Connection}\r\n */\n\n\nPool.prototype.write = function (command, options, cb) {\n  var self = this; // Ensure we have a callback\n\n  if (typeof options === 'function') {\n    cb = options;\n  } // Always have options\n\n\n  options = options || {}; // We need to have a callback function unless the message returns no response\n\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  } // Pool was destroyed error out\n\n\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    // Callback with an error\n    if (cb) {\n      try {\n        cb(new MongoError('pool destroyed'));\n      } catch (err) {\n        process.nextTick(function () {\n          throw err;\n        });\n      }\n    }\n\n    return;\n  }\n\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function () {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      } // bounce off event loop so domain switch takes place\n\n\n      process.nextTick(function () {\n        oldCb.apply(null, args);\n      });\n    });\n  } // Do we have an operation\n\n\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    fullResult: false\n  }; // Set the options for the parsing\n\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease = typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null; // Optional per operation socketTimeout\n\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring; // Custom socket Timeout\n\n  if (options.socketTimeout) {\n    operation.socketTimeout = options.socketTimeout;\n  } // Get the requestId\n\n\n  operation.requestId = command.requestId; // If command monitoring is enabled we need to modify the callback here\n\n  if (self.options.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operation.started = process.hrtime();\n\n    operation.cb = (err, reply) => {\n      if (err) {\n        self.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operation.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operation.started));\n        } else {\n          self.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operation.started));\n        }\n      }\n\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  } // Prepare the operation buffer\n\n\n  serializeCommand(self, command, (err, serializedBuffers) => {\n    if (err) throw err; // Set the operation's buffer to the serialization of the commands\n\n    operation.buffer = serializedBuffers; // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    } // Attempt to execute the operation\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    }\n  });\n}; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return uncompressibleCommands.indexOf(commandName) === -1;\n} // Remove connection method\n\n\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n}\n\nconst handlers = ['close', 'message', 'error', 'timeout', 'parseError', 'connect'];\n\nfunction _createConnection(self) {\n  if (self.state === DESTROYED || self.state === DESTROYING) {\n    return;\n  }\n\n  self.connectingConnections++;\n  connect(self.options, (err, connection) => {\n    self.connectingConnections--;\n\n    if (err) {\n      if (self.logger.isDebug()) {\n        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      }\n\n      if (!self.reconnectId && self.options.reconnect) {\n        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n      }\n\n      return;\n    }\n\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      removeConnection(self, connection);\n      return connection.destroy();\n    }\n\n    connection.on('error', self._connectionErrorHandler);\n    connection.on('close', self._connectionCloseHandler);\n    connection.on('timeout', self._connectionTimeoutHandler);\n    connection.on('parseError', self._connectionParseErrorHandler);\n    connection.on('message', self._messageHandler);\n\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      return connection.destroy();\n    } // Remove the connection from the connectingConnections list\n\n\n    removeConnection(self, connection); // Handle error\n\n    if (err) {\n      return connection.destroy();\n    } // Push to available\n\n\n    self.availableConnections.push(connection); // Execute any work waiting\n\n    _execute(self)();\n  });\n}\n\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(new MongoError({\n        message: 'no connection available for monitoring',\n        driver: true\n      }));\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function () {\n    if (self.state === DESTROYED) return; // Already executing, skip\n\n    if (self.executing) return; // Set pool as executing\n\n    self.executing = true; // New pool connections are in progress, wait them to finish\n    // before executing any more operation to ensure distribution of\n    // operations\n\n    if (self.connectingConnections > 0) {\n      self.executing = false;\n      return;\n    } // As long as we have available connections\n    // eslint-disable-next-line\n\n\n    while (true) {\n      // Total availble connections\n      const totalConnections = totalConnectionCount(self); // No available connections available, flush any monitoring ops\n\n      if (self.availableConnections.length === 0) {\n        // Flush any monitoring operations\n        flushMonitoringOperations(self.queue);\n        break;\n      } // No queue break\n\n\n      if (self.queue.length === 0) {\n        break;\n      }\n\n      var connection = null;\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0); // No connection found that has no work on it, just pick one for pipelining\n\n      if (connections.length === 0) {\n        connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n      } else {\n        connection = connections[self.connectionIndex++ % connections.length];\n      } // Is the connection connected\n\n\n      if (!connection.isConnected()) {\n        // Remove the disconnected connection\n        removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n        flushMonitoringOperations(self.queue);\n        break;\n      } // Get the next work item\n\n\n      var workItem = self.queue.shift(); // If we are monitoring we need to use a connection that is not\n      // running another operation to avoid socket timeout changes\n      // affecting an existing operation\n\n      if (workItem.monitoring) {\n        var foundValidConnection = false;\n\n        for (let i = 0; i < self.availableConnections.length; i++) {\n          // If the connection is connected\n          // And there are no pending workItems on it\n          // Then we can safely use it for monitoring.\n          if (self.availableConnections[i].isConnected() && self.availableConnections[i].workItems.length === 0) {\n            foundValidConnection = true;\n            connection = self.availableConnections[i];\n            break;\n          }\n        } // No safe connection found, attempt to grow the connections\n        // if possible and break from the loop\n\n\n        if (!foundValidConnection) {\n          // Put workItem back on the queue\n          self.queue.unshift(workItem); // Attempt to grow the pool if it's not yet maxsize\n\n          if (totalConnections < self.options.size && self.queue.length > 0) {\n            // Create a new connection\n            _createConnection(self);\n          } // Re-execute the operation\n\n\n          setTimeout(function () {\n            _execute(self)();\n          }, 10);\n          break;\n        }\n      } // Don't execute operation until we have a full pool\n\n\n      if (totalConnections < self.options.size) {\n        // Connection has work items, then put it back on the queue\n        // and create a new connection\n        if (connection.workItems.length > 0) {\n          // Lets put the workItem back on the list\n          self.queue.unshift(workItem); // Create a new connection\n\n          _createConnection(self); // Break from the loop\n\n\n          break;\n        }\n      } // Get actual binary commands\n\n\n      var buffer = workItem.buffer; // If we are monitoring take the connection of the availableConnections\n\n      if (workItem.monitoring) {\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n      } // Track the executing commands on the mongo server\n      // as long as there is an expected response\n\n\n      if (!workItem.noResponse) {\n        connection.workItems.push(workItem);\n      } // We have a custom socketTimeout\n\n\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n        connection.setSocketTimeout(workItem.socketTimeout);\n      } // Capture if write was successful\n\n\n      var writeSuccessful = true; // Put operation on the wire\n\n      if (Array.isArray(buffer)) {\n        for (let i = 0; i < buffer.length; i++) {\n          writeSuccessful = connection.write(buffer[i]);\n        }\n      } else {\n        writeSuccessful = connection.write(buffer);\n      } // if the command is designated noResponse, call the callback immeditely\n\n\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\n        workItem.cb(null, null);\n      }\n\n      if (writeSuccessful === false) {\n        // If write not successful put back on queue\n        self.queue.unshift(workItem); // Remove the disconnected connection\n\n        removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n    }\n\n    self.executing = false;\n  };\n} // Make execution loop available for testing\n\n\nPool._execute = _execute;\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Pool#connect\r\n * @type {Pool}\r\n */\n\n/**\r\n * A server reconnect event, used to verify that pool reconnected.\r\n *\r\n * @event Pool#reconnect\r\n * @type {Pool}\r\n */\n\n/**\r\n * The server connection closed, all pool connections closed\r\n *\r\n * @event Pool#close\r\n * @type {Pool}\r\n */\n\n/**\r\n * The server connection caused an error, all pool connections closed\r\n *\r\n * @event Pool#error\r\n * @type {Pool}\r\n */\n\n/**\r\n * The server connection timed out, all pool connections closed\r\n *\r\n * @event Pool#timeout\r\n * @type {Pool}\r\n */\n\n/**\r\n * The driver experienced an invalid message, all pool connections closed\r\n *\r\n * @event Pool#parseError\r\n * @type {Pool}\r\n */\n\n/**\r\n * The driver attempted to reconnect\r\n *\r\n * @event Pool#attemptReconnect\r\n * @type {Pool}\r\n */\n\n/**\r\n * The driver exhausted all reconnect attempts\r\n *\r\n * @event Pool#reconnectFailed\r\n * @type {Pool}\r\n */\n\nmodule.exports = Pool;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/connection/pool.js"],"names":["inherits","require","EventEmitter","MongoError","MongoNetworkError","MongoWriteConcernError","Logger","f","format","Msg","CommandResult","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","opcodes","compress","compressorIDs","uncompressibleCommands","apm","Buffer","connect","updateSessionFromResponse","eachAsync","DISCONNECTED","CONNECTING","CONNECTED","DESTROYING","DESTROYED","CONNECTION_EVENTS","Set","_id","Pool","topology","options","call","Object","assign","host","port","size","minSize","connectionTimeout","socketTimeout","keepAlive","keepAliveInitialDelay","noDelay","ssl","checkServerIdentity","ca","crl","cert","key","passPhrase","rejectUnauthorized","promoteLongs","promoteValues","promoteBuffers","reconnect","reconnectInterval","reconnectTries","domainsEnabled","id","retriesLeft","reconnectId","bson","serialize","deserialize","Error","logger","state","availableConnections","inUseConnections","connectingConnections","executing","queue","reconnectConnection","numberOfConsecutiveTimeouts","connectionIndex","pool","_messageHandler","messageHandler","_connectionCloseHandler","err","connection","connectionFailureHandler","_connectionErrorHandler","_connectionTimeoutHandler","_connectionParseErrorHandler","defineProperty","prototype","enumerable","get","resetPoolState","stateTransition","self","newState","legalTransitions","disconnected","connecting","connected","destroying","destroyed","legalStates","indexOf","emit","error","event","conn","_connectionFailHandled","destroy","removeConnection","workItems","length","workItem","shift","cb","socketCount","setTimeout","attemptReconnect","totalConnections","totalConnectionCount","_createConnection","isConnected","isDebug","debug","JSON","stringify","handlers","forEach","removeAllListeners","on","push","_execute","moveConnectionBetween","from","to","index","splice","message","i","requestId","responseTo","monitoring","resetSocketTimeout","raw","toString","handleOperationCallback","result","process","nextTick","immediateRelease","parse","documents","document","session","$clusterTime","clusterTime","command","responseDoc","writeConcernError","ok","$err","errmsg","code","hashedName","fullResult","allConnections","concat","connections","isDestroyed","isDisconnected","inTopology","auth","credentials","callback","logout","dbName","unref","c","eventName","force","clearTimeout","checkStatus","flushMonitoringOperations","reset","serializeCommand","originalCommandBuffer","toBin","shouldCompress","agreedCompressor","canCompress","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","compressedMessage","msgHeader","alloc","writeInt32LE","OP_COMPRESSED","compressionDetails","writeUInt8","write","noResponse","domain","oldCb","bind","args","Array","arguments","apply","operation","documentsReturnedIn","monitorCommands","CommandStartedEvent","started","hrtime","reply","CommandFailedEvent","CommandSucceededEvent","serializedBuffers","buffer","unshift","commandDoc","query","commandName","keys","remove","driver","filter","foundValidConnection","setSocketTimeout","writeSuccessful","isArray","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,MAAD,CAAP,CAAgBD,QAAjC;;AACA,MAAME,YAAY,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBC,YAAvC;;AACA,MAAMC,UAAU,GAAGF,OAAO,CAAC,UAAD,CAAP,CAAoBE,UAAvC;;AACA,MAAMC,iBAAiB,GAAGH,OAAO,CAAC,UAAD,CAAP,CAAoBG,iBAA9C;;AACA,MAAMC,sBAAsB,GAAGJ,OAAO,CAAC,UAAD,CAAP,CAAoBI,sBAAnD;;AACA,MAAMC,MAAM,GAAGL,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMM,CAAC,GAAGN,OAAO,CAAC,MAAD,CAAP,CAAgBO,MAA1B;;AACA,MAAMC,GAAG,GAAGR,OAAO,CAAC,OAAD,CAAP,CAAiBQ,GAA7B;;AACA,MAAMC,aAAa,GAAGT,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAMU,mBAAmB,GAAGV,OAAO,CAAC,wBAAD,CAAP,CAAkCU,mBAA9D;;AACA,MAAMC,wBAAwB,GAAGX,OAAO,CAAC,wBAAD,CAAP,CAAkCW,wBAAnE;;AACA,MAAMC,OAAO,GAAGZ,OAAO,CAAC,wBAAD,CAAP,CAAkCY,OAAlD;;AACA,MAAMC,QAAQ,GAAGb,OAAO,CAAC,6BAAD,CAAP,CAAuCa,QAAxD;;AACA,MAAMC,aAAa,GAAGd,OAAO,CAAC,6BAAD,CAAP,CAAuCc,aAA7D;;AACA,MAAMC,sBAAsB,GAAGf,OAAO,CAAC,6BAAD,CAAP,CAAuCe,sBAAtE;;AACA,MAAMC,GAAG,GAAGhB,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMiB,MAAM,GAAGjB,OAAO,CAAC,aAAD,CAAP,CAAuBiB,MAAtC;;AACA,MAAMC,OAAO,GAAGlB,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMmB,yBAAyB,GAAGnB,OAAO,CAAC,aAAD,CAAP,CAAuBmB,yBAAzD;;AACA,MAAMC,SAAS,GAAGpB,OAAO,CAAC,UAAD,CAAP,CAAoBoB,SAAtC;;AAEA,IAAIC,YAAY,GAAG,cAAnB;AACA,IAAIC,UAAU,GAAG,YAAjB;AACA,IAAIC,SAAS,GAAG,WAAhB;AACA,IAAIC,UAAU,GAAG,YAAjB;AACA,IAAIC,SAAS,GAAG,WAAhB;AAEA,MAAMC,iBAAiB,GAAG,IAAIC,GAAJ,CAAQ,CAChC,OADgC,EAEhC,OAFgC,EAGhC,SAHgC,EAIhC,YAJgC,EAKhC,SALgC,EAMhC,SANgC,CAAR,CAA1B;AASA,IAAIC,GAAG,GAAG,CAAV;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,IAAI,GAAG,UAASC,QAAT,EAAmBC,OAAnB,EAA4B;AACrC;AACA9B,EAAAA,YAAY,CAAC+B,IAAb,CAAkB,IAAlB,EAFqC,CAIrC;;AACA,OAAKF,QAAL,GAAgBA,QAAhB,CALqC,CAOrC;;AACA,OAAKC,OAAL,GAAeE,MAAM,CAACC,MAAP,CACb;AACE;AACAC,IAAAA,IAAI,EAAE,WAFR;AAGEC,IAAAA,IAAI,EAAE,KAHR;AAIE;AACAC,IAAAA,IAAI,EAAE,CALR;AAME;AACAC,IAAAA,OAAO,EAAE,CAPX;AAQE;AACAC,IAAAA,iBAAiB,EAAE,KATrB;AAUEC,IAAAA,aAAa,EAAE,MAVjB;AAWEC,IAAAA,SAAS,EAAE,IAXb;AAYEC,IAAAA,qBAAqB,EAAE,MAZzB;AAaEC,IAAAA,OAAO,EAAE,IAbX;AAcE;AACAC,IAAAA,GAAG,EAAE,KAfP;AAgBEC,IAAAA,mBAAmB,EAAE,IAhBvB;AAiBEC,IAAAA,EAAE,EAAE,IAjBN;AAkBEC,IAAAA,GAAG,EAAE,IAlBP;AAmBEC,IAAAA,IAAI,EAAE,IAnBR;AAoBEC,IAAAA,GAAG,EAAE,IApBP;AAqBEC,IAAAA,UAAU,EAAE,IArBd;AAsBEC,IAAAA,kBAAkB,EAAE,KAtBtB;AAuBEC,IAAAA,YAAY,EAAE,IAvBhB;AAwBEC,IAAAA,aAAa,EAAE,IAxBjB;AAyBEC,IAAAA,cAAc,EAAE,KAzBlB;AA0BE;AACAC,IAAAA,SAAS,EAAE,IA3Bb;AA4BEC,IAAAA,iBAAiB,EAAE,IA5BrB;AA6BEC,IAAAA,cAAc,EAAE,EA7BlB;AA8BE;AACAC,IAAAA,cAAc,EAAE;AA/BlB,GADa,EAkCb3B,OAlCa,CAAf,CARqC,CA6CrC;;AACA,OAAK4B,EAAL,GAAU/B,GAAG,EAAb,CA9CqC,CA+CrC;;AACA,OAAKgC,WAAL,GAAmB,KAAK7B,OAAL,CAAa0B,cAAhC;AACA,OAAKI,WAAL,GAAmB,IAAnB,CAjDqC,CAkDrC;;AACA,MACE,CAAC9B,OAAO,CAAC+B,IAAT,IACC/B,OAAO,CAAC+B,IAAR,KACE,OAAO/B,OAAO,CAAC+B,IAAR,CAAaC,SAApB,KAAkC,UAAlC,IACC,OAAOhC,OAAO,CAAC+B,IAAR,CAAaE,WAApB,KAAoC,UAFvC,CAFH,EAKE;AACA,UAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACD,GA1DoC,CA4DrC;;;AACA,OAAKC,MAAL,GAAc7D,MAAM,CAAC,MAAD,EAAS0B,OAAT,CAApB,CA7DqC,CA8DrC;;AACA,OAAKoC,KAAL,GAAa9C,YAAb,CA/DqC,CAgErC;;AACA,OAAK+C,oBAAL,GAA4B,EAA5B;AACA,OAAKC,gBAAL,GAAwB,EAAxB;AACA,OAAKC,qBAAL,GAA6B,CAA7B,CAnEqC,CAoErC;;AACA,OAAKC,SAAL,GAAiB,KAAjB,CArEqC,CAsErC;;AACA,OAAKC,KAAL,GAAa,EAAb,CAvEqC,CAyErC;;AACA,OAAKC,mBAAL,GAA2B,IAA3B,CA1EqC,CA4ErC;;AACA,OAAKC,2BAAL,GAAmC,CAAnC,CA7EqC,CA8ErC;;AACA,OAAKC,eAAL,GAAuB,CAAvB,CA/EqC,CAiFrC;;AACA,QAAMC,IAAI,GAAG,IAAb;AACA,OAAKC,eAAL,GAAuBC,cAAc,CAAC,IAAD,CAArC;;AACA,OAAKC,uBAAL,GAA+B,UAASC,GAAT,EAAc;AAC3C,UAAMC,UAAU,GAAG,IAAnB;AACAC,IAAAA,wBAAwB,CAACN,IAAD,EAAO,OAAP,EAAgBI,GAAhB,EAAqBC,UAArB,CAAxB;AACD,GAHD;;AAKA,OAAKE,uBAAL,GAA+B,UAASH,GAAT,EAAc;AAC3C,UAAMC,UAAU,GAAG,IAAnB;AACAC,IAAAA,wBAAwB,CAACN,IAAD,EAAO,OAAP,EAAgBI,GAAhB,EAAqBC,UAArB,CAAxB;AACD,GAHD;;AAKA,OAAKG,yBAAL,GAAiC,UAASJ,GAAT,EAAc;AAC7C,UAAMC,UAAU,GAAG,IAAnB;AACAC,IAAAA,wBAAwB,CAACN,IAAD,EAAO,SAAP,EAAkBI,GAAlB,EAAuBC,UAAvB,CAAxB;AACD,GAHD;;AAKA,OAAKI,4BAAL,GAAoC,UAASL,GAAT,EAAc;AAChD,UAAMC,UAAU,GAAG,IAAnB;AACAC,IAAAA,wBAAwB,CAACN,IAAD,EAAO,YAAP,EAAqBI,GAArB,EAA0BC,UAA1B,CAAxB;AACD,GAHD;AAID,CAvGD;;AAyGAlF,QAAQ,CAAC8B,IAAD,EAAO5B,YAAP,CAAR;AAEAgC,MAAM,CAACqD,cAAP,CAAsBzD,IAAI,CAAC0D,SAA3B,EAAsC,MAAtC,EAA8C;AAC5CC,EAAAA,UAAU,EAAE,IADgC;AAE5CC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAK1D,OAAL,CAAaM,IAApB;AACD;AAJ2C,CAA9C;AAOAJ,MAAM,CAACqD,cAAP,CAAsBzD,IAAI,CAAC0D,SAA3B,EAAsC,SAAtC,EAAiD;AAC/CC,EAAAA,UAAU,EAAE,IADmC;AAE/CC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAK1D,OAAL,CAAaO,OAApB;AACD;AAJ8C,CAAjD;AAOAL,MAAM,CAACqD,cAAP,CAAsBzD,IAAI,CAAC0D,SAA3B,EAAsC,mBAAtC,EAA2D;AACzDC,EAAAA,UAAU,EAAE,IAD6C;AAEzDC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAK1D,OAAL,CAAaQ,iBAApB;AACD;AAJwD,CAA3D;AAOAN,MAAM,CAACqD,cAAP,CAAsBzD,IAAI,CAAC0D,SAA3B,EAAsC,eAAtC,EAAuD;AACrDC,EAAAA,UAAU,EAAE,IADyC;AAErDC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAK1D,OAAL,CAAaS,aAApB;AACD;AAJoD,CAAvD,E,CAOA;;AACA,SAASkD,cAAT,CAAwBd,IAAxB,EAA8B;AAC5BA,EAAAA,IAAI,CAACP,gBAAL,GAAwB,EAAxB;AACAO,EAAAA,IAAI,CAACR,oBAAL,GAA4B,EAA5B;AACAQ,EAAAA,IAAI,CAACN,qBAAL,GAA6B,CAA7B;AACAM,EAAAA,IAAI,CAACL,SAAL,GAAiB,KAAjB;AACAK,EAAAA,IAAI,CAACH,mBAAL,GAA2B,IAA3B;AACAG,EAAAA,IAAI,CAACF,2BAAL,GAAmC,CAAnC;AACAE,EAAAA,IAAI,CAACD,eAAL,GAAuB,CAAvB;AACAC,EAAAA,IAAI,CAAChB,WAAL,GAAmBgB,IAAI,CAAC7C,OAAL,CAAa0B,cAAhC;AACAmB,EAAAA,IAAI,CAACf,WAAL,GAAmB,IAAnB;AACD;;AAED,SAAS8B,eAAT,CAAyBC,IAAzB,EAA+BC,QAA/B,EAAyC;AACvC,MAAIC,gBAAgB,GAAG;AACrBC,IAAAA,YAAY,EAAE,CAACzE,UAAD,EAAaE,UAAb,EAAyBH,YAAzB,CADO;AAErB2E,IAAAA,UAAU,EAAE,CAAC1E,UAAD,EAAaE,UAAb,EAAyBD,SAAzB,EAAoCF,YAApC,CAFS;AAGrB4E,IAAAA,SAAS,EAAE,CAAC1E,SAAD,EAAYF,YAAZ,EAA0BG,UAA1B,CAHU;AAIrB0E,IAAAA,UAAU,EAAE,CAAC1E,UAAD,EAAaC,SAAb,CAJS;AAKrB0E,IAAAA,SAAS,EAAE,CAAC1E,SAAD;AALU,GAAvB,CADuC,CASvC;;AACA,MAAI2E,WAAW,GAAGN,gBAAgB,CAACF,IAAI,CAACzB,KAAN,CAAlC;;AACA,MAAIiC,WAAW,IAAIA,WAAW,CAACC,OAAZ,CAAoBR,QAApB,MAAkC,CAAC,CAAtD,EAAyD;AACvDD,IAAAA,IAAI,CAACU,IAAL,CAAU,cAAV,EAA0BV,IAAI,CAACzB,KAA/B,EAAsC0B,QAAtC;AACAD,IAAAA,IAAI,CAACzB,KAAL,GAAa0B,QAAb;AACD,GAHD,MAGO;AACLD,IAAAA,IAAI,CAAC1B,MAAL,CAAYqC,KAAZ,CACEjG,CAAC,CACC,iHADD,EAECsF,IAAI,CAACjC,EAFN,EAGCiC,IAAI,CAACzB,KAHN,EAIC0B,QAJD,EAKCO,WALD,CADH;AASD;AACF;;AAED,SAASlB,wBAAT,CAAkCN,IAAlC,EAAwC4B,KAAxC,EAA+CxB,GAA/C,EAAoDyB,IAApD,EAA0D;AACxD,MAAIA,IAAJ,EAAU;AACR,QAAIA,IAAI,CAACC,sBAAT,EAAiC;AACjCD,IAAAA,IAAI,CAACC,sBAAL,GAA8B,IAA9B;AACAD,IAAAA,IAAI,CAACE,OAAL,GAHQ,CAKR;;AACAC,IAAAA,gBAAgB,CAAChC,IAAD,EAAO6B,IAAP,CAAhB,CANQ,CAQR;;AACA,WAAOA,IAAI,CAACI,SAAL,CAAeC,MAAf,GAAwB,CAA/B,EAAkC;AAChC,YAAMC,QAAQ,GAAGN,IAAI,CAACI,SAAL,CAAeG,KAAf,EAAjB;AACA,UAAID,QAAQ,CAACE,EAAb,EAAiBF,QAAQ,CAACE,EAAT,CAAYjC,GAAZ;AAClB;AACF,GAduD,CAgBxD;;;AACA,MAAIwB,KAAK,KAAK,SAAd,EAAyB;AACvB5B,IAAAA,IAAI,CAACF,2BAAL,GAAmCE,IAAI,CAACF,2BAAL,GAAmC,CAAtE,CADuB,CAGvB;AACA;;AACA,QAAIE,IAAI,CAACF,2BAAL,GAAmCE,IAAI,CAAC7C,OAAL,CAAa0B,cAApD,EAAoE;AAClEmB,MAAAA,IAAI,CAACF,2BAAL,GAAmC,CAAnC,CADkE,CAElE;;AACAE,MAAAA,IAAI,CAAC+B,OAAL,CAAa,IAAb,EAHkE,CAIlE;;AACA,aAAO/B,IAAI,CAAC0B,IAAL,CAAU,OAAV,EAAmB1B,IAAnB,CAAP;AACD;AACF,GA7BuD,CA+BxD;;;AACA,MAAIA,IAAI,CAACsC,WAAL,OAAuB,CAA3B,EAA8B;AAC5B,QAAItC,IAAI,CAACT,KAAL,KAAe1C,SAAf,IAA4BmD,IAAI,CAACT,KAAL,KAAe3C,UAA/C,EAA2D;AACzDmE,MAAAA,eAAe,CAACf,IAAD,EAAOvD,YAAP,CAAf;AACD,KAH2B,CAK5B;AACA;;;AACAmF,IAAAA,KAAK,GAAGA,KAAK,KAAK,OAAV,GAAoB,OAApB,GAA8BA,KAAtC;AACA5B,IAAAA,IAAI,CAAC0B,IAAL,CAAUE,KAAV,EAAiBxB,GAAjB;AACD,GAzCuD,CA2CxD;;;AACA,MAAI,CAACJ,IAAI,CAACf,WAAN,IAAqBe,IAAI,CAAC7C,OAAL,CAAawB,SAAtC,EAAiD;AAC/CqB,IAAAA,IAAI,CAACf,WAAL,GAAmBsD,UAAU,CAACC,gBAAgB,CAACxC,IAAD,CAAjB,EAAyBA,IAAI,CAAC7C,OAAL,CAAayB,iBAAtC,CAA7B;AACD,GA9CuD,CAgDxD;;;AACA,QAAM6D,gBAAgB,GAAGC,oBAAoB,CAAC1C,IAAD,CAA7C;;AACA,MAAIyC,gBAAgB,GAAGzC,IAAI,CAACtC,OAA5B,EAAqC;AACnCiF,IAAAA,iBAAiB,CAAC3C,IAAD,CAAjB;AACD;AACF;;AAED,SAASwC,gBAAT,CAA0BxB,IAA1B,EAAgC;AAC9B,SAAO,YAAW;AAChBA,IAAAA,IAAI,CAACU,IAAL,CAAU,kBAAV,EAA8BV,IAA9B;AACA,QAAIA,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D,OAF3C,CAIhB;;AACA,QAAIoE,IAAI,CAAC4B,WAAL,EAAJ,EAAwB;AACtB5B,MAAAA,IAAI,CAAC/B,WAAL,GAAmB,IAAnB;AACA;AACD;;AAED+B,IAAAA,IAAI,CAACtB,qBAAL;AACApD,IAAAA,OAAO,CAAC0E,IAAI,CAAC7D,OAAN,EAAe,CAACiD,GAAD,EAAMC,UAAN,KAAqB;AACzCW,MAAAA,IAAI,CAACtB,qBAAL;;AAEA,UAAIU,GAAJ,EAAS;AACP,YAAIY,IAAI,CAAC1B,MAAL,CAAYuD,OAAZ,EAAJ,EAA2B;AACzB7B,UAAAA,IAAI,CAAC1B,MAAL,CAAYwD,KAAZ,CAAmB,yCAAwCC,IAAI,CAACC,SAAL,CAAe5C,GAAf,CAAoB,GAA/E;AACD;;AAEDY,QAAAA,IAAI,CAAChC,WAAL,GAAmBgC,IAAI,CAAChC,WAAL,GAAmB,CAAtC;;AACA,YAAIgC,IAAI,CAAChC,WAAL,IAAoB,CAAxB,EAA2B;AACzBgC,UAAAA,IAAI,CAACe,OAAL;AACAf,UAAAA,IAAI,CAACU,IAAL,CACE,iBADF,EAEE,IAAInG,iBAAJ,CACEG,CAAC,CACC,2DADD,EAECsF,IAAI,CAAC7D,OAAL,CAAa0B,cAFd,EAGCmC,IAAI,CAAC7D,OAAL,CAAayB,iBAHd,CADH,CAFF;AAUD,SAZD,MAYO;AACLoC,UAAAA,IAAI,CAAC/B,WAAL,GAAmBsD,UAAU,CAACC,gBAAgB,CAACxB,IAAD,CAAjB,EAAyBA,IAAI,CAAC7D,OAAL,CAAayB,iBAAtC,CAA7B;AACD;;AAED;AACD;;AAED,UAAIoC,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzD,eAAOyD,UAAU,CAAC0B,OAAX,EAAP;AACD;;AAEDf,MAAAA,IAAI,CAAC/B,WAAL,GAAmB,IAAnB;AACAgE,MAAAA,QAAQ,CAACC,OAAT,CAAiBtB,KAAK,IAAIvB,UAAU,CAAC8C,kBAAX,CAA8BvB,KAA9B,CAA1B;AACAvB,MAAAA,UAAU,CAAC+C,EAAX,CAAc,OAAd,EAAuBpC,IAAI,CAACT,uBAA5B;AACAF,MAAAA,UAAU,CAAC+C,EAAX,CAAc,OAAd,EAAuBpC,IAAI,CAACb,uBAA5B;AACAE,MAAAA,UAAU,CAAC+C,EAAX,CAAc,SAAd,EAAyBpC,IAAI,CAACR,yBAA9B;AACAH,MAAAA,UAAU,CAAC+C,EAAX,CAAc,YAAd,EAA4BpC,IAAI,CAACP,4BAAjC;AACAJ,MAAAA,UAAU,CAAC+C,EAAX,CAAc,SAAd,EAAyBpC,IAAI,CAACf,eAA9B;AAEAe,MAAAA,IAAI,CAAChC,WAAL,GAAmBgC,IAAI,CAAC7D,OAAL,CAAa0B,cAAhC;AACAmC,MAAAA,IAAI,CAACxB,oBAAL,CAA0B6D,IAA1B,CAA+BhD,UAA/B;AACAW,MAAAA,IAAI,CAACnB,mBAAL,GAA2B,IAA3B;AACAmB,MAAAA,IAAI,CAACU,IAAL,CAAU,WAAV,EAAuBV,IAAvB;;AACAsC,MAAAA,QAAQ,CAACtC,IAAD,CAAR;AACD,KA7CM,CAAP;AA8CD,GAzDD;AA0DD;;AAED,SAASuC,qBAAT,CAA+BlD,UAA/B,EAA2CmD,IAA3C,EAAiDC,EAAjD,EAAqD;AACnD,MAAIC,KAAK,GAAGF,IAAI,CAAC/B,OAAL,CAAapB,UAAb,CAAZ,CADmD,CAEnD;;AACA,MAAIqD,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChBF,IAAAA,IAAI,CAACG,MAAL,CAAYD,KAAZ,EAAmB,CAAnB;AACAD,IAAAA,EAAE,CAACJ,IAAH,CAAQhD,UAAR;AACD;AACF;;AAED,SAASH,cAAT,CAAwBc,IAAxB,EAA8B;AAC5B,SAAO,UAAS4C,OAAT,EAAkBvD,UAAlB,EAA8B;AACnC;AACA,QAAI8B,QAAQ,GAAG,IAAf,CAFmC,CAInC;;AACA,SAAK,IAAI0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxD,UAAU,CAAC4B,SAAX,CAAqBC,MAAzC,EAAiD2B,CAAC,EAAlD,EAAsD;AACpD,UAAIxD,UAAU,CAAC4B,SAAX,CAAqB4B,CAArB,EAAwBC,SAAxB,KAAsCF,OAAO,CAACG,UAAlD,EAA8D;AAC5D;AACA5B,QAAAA,QAAQ,GAAG9B,UAAU,CAAC4B,SAAX,CAAqB4B,CAArB,CAAX,CAF4D,CAG5D;;AACAxD,QAAAA,UAAU,CAAC4B,SAAX,CAAqB0B,MAArB,CAA4BE,CAA5B,EAA+B,CAA/B;AACD;AACF;;AAED,QAAI1B,QAAQ,IAAIA,QAAQ,CAAC6B,UAAzB,EAAqC;AACnCT,MAAAA,qBAAqB,CAAClD,UAAD,EAAaW,IAAI,CAACvB,gBAAlB,EAAoCuB,IAAI,CAACxB,oBAAzC,CAArB;AACD,KAhBkC,CAkBnC;;;AACAwB,IAAAA,IAAI,CAAClB,2BAAL,GAAmC,CAAnC,CAnBmC,CAqBnC;AACA;;AACA,QAAIqC,QAAQ,IAAIA,QAAQ,CAACvE,aAAzB,EAAwC;AACtCyC,MAAAA,UAAU,CAAC4D,kBAAX;AACD,KAzBkC,CA2BnC;;;AACA,QAAIjD,IAAI,CAAC1B,MAAL,CAAYuD,OAAZ,EAAJ,EAA2B;AACzB7B,MAAAA,IAAI,CAAC1B,MAAL,CAAYwD,KAAZ,CACEpH,CAAC,CACC,kCADD,EAECkI,OAAO,CAACM,GAAR,CAAYC,QAAZ,CAAqB,KAArB,CAFD,EAGCnD,IAAI,CAAC7D,OAAL,CAAaI,IAHd,EAICyD,IAAI,CAAC7D,OAAL,CAAaK,IAJd,CADH;AAQD;;AAED,aAAS4G,uBAAT,CAAiCpD,IAAjC,EAAuCqB,EAAvC,EAA2CjC,GAA3C,EAAgDiE,MAAhD,EAAwD;AACtD;AACA,UAAI,CAACrD,IAAI,CAAC7D,OAAL,CAAa2B,cAAlB,EAAkC;AAChC,eAAOwF,OAAO,CAACC,QAAR,CAAiB,YAAW;AACjC,iBAAOlC,EAAE,CAACjC,GAAD,EAAMiE,MAAN,CAAT;AACD,SAFM,CAAP;AAGD,OANqD,CAQtD;;;AACAhC,MAAAA,EAAE,CAACjC,GAAD,EAAMiE,MAAN,CAAF;AACD,KAjDkC,CAmDnC;;;AACA,QAAI,CAACrD,IAAI,CAACrB,SAAV,EAAqB;AACnB2E,MAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1BjB,QAAAA,QAAQ,CAACtC,IAAD,CAAR;AACD,OAFD;AAGD,KAxDkC,CA0DnC;;;AACA,QAAImB,QAAQ,IAAI,CAACA,QAAQ,CAACqC,gBAA1B,EAA4C;AAC1C,UAAI;AACF;AACAZ,QAAAA,OAAO,CAACa,KAAR,CAActC,QAAd;AACD,OAHD,CAGE,OAAO/B,GAAP,EAAY;AACZ,eAAOgE,uBAAuB,CAACpD,IAAD,EAAOmB,QAAQ,CAACE,EAAhB,EAAoB,IAAI/G,UAAJ,CAAe8E,GAAf,CAApB,CAA9B;AACD;;AAED,UAAIwD,OAAO,CAACc,SAAR,CAAkB,CAAlB,CAAJ,EAA0B;AACxB,cAAMC,QAAQ,GAAGf,OAAO,CAACc,SAAR,CAAkB,CAAlB,CAAjB;AACA,cAAME,OAAO,GAAGzC,QAAQ,CAACyC,OAAzB;;AACA,YAAIA,OAAJ,EAAa;AACXrI,UAAAA,yBAAyB,CAACqI,OAAD,EAAUD,QAAV,CAAzB;AACD;;AAED,YAAIA,QAAQ,CAACE,YAAb,EAA2B;AACzB7D,UAAAA,IAAI,CAAC9D,QAAL,CAAc4H,WAAd,GAA4BH,QAAQ,CAACE,YAArC;AACD;AACF,OAlByC,CAoB1C;;;AACA,UAAI1C,QAAQ,CAAC4C,OAAT,IAAoBnB,OAAO,CAACc,SAAR,CAAkB,CAAlB,CAAxB,EAA8C;AAC5C,cAAMM,WAAW,GAAGpB,OAAO,CAACc,SAAR,CAAkB,CAAlB,CAApB;;AAEA,YAAIM,WAAW,CAACC,iBAAhB,EAAmC;AACjC,gBAAM7E,GAAG,GAAG,IAAI5E,sBAAJ,CAA2BwJ,WAAW,CAACC,iBAAvC,EAA0DD,WAA1D,CAAZ;AACA,iBAAOZ,uBAAuB,CAACpD,IAAD,EAAOmB,QAAQ,CAACE,EAAhB,EAAoBjC,GAApB,CAA9B;AACD;;AAED,YAAI4E,WAAW,CAACE,EAAZ,KAAmB,CAAnB,IAAwBF,WAAW,CAACG,IAApC,IAA4CH,WAAW,CAACI,MAAxD,IAAkEJ,WAAW,CAACK,IAAlF,EAAwF;AACtF,iBAAOjB,uBAAuB,CAACpD,IAAD,EAAOmB,QAAQ,CAACE,EAAhB,EAAoB,IAAI/G,UAAJ,CAAe0J,WAAf,CAApB,CAA9B;AACD;AACF,OAhCyC,CAkC1C;;;AACApB,MAAAA,OAAO,CAAC0B,UAAR,GAAqBjF,UAAU,CAACiF,UAAhC,CAnC0C,CAqC1C;;AACAlB,MAAAA,uBAAuB,CACrBpD,IADqB,EAErBmB,QAAQ,CAACE,EAFY,EAGrB,IAHqB,EAIrB,IAAIxG,aAAJ,CAAkBsG,QAAQ,CAACoD,UAAT,GAAsB3B,OAAtB,GAAgCA,OAAO,CAACc,SAAR,CAAkB,CAAlB,CAAlD,EAAwErE,UAAxE,EAAoFuD,OAApF,CAJqB,CAAvB;AAMD;AACF,GAxGD;AAyGD;AAED;AACA;AACA;AACA;AACA;;;AACA3G,IAAI,CAAC0D,SAAL,CAAe2B,WAAf,GAA6B,YAAW;AACtC,SAAO,KAAK9C,oBAAL,CAA0B0C,MAA1B,GAAmC,KAAKzC,gBAAL,CAAsByC,MAAhE,CADsC,CAEtC;AACD,CAHD;;AAKA,SAASQ,oBAAT,CAA8B1C,IAA9B,EAAoC;AAClC,SACEA,IAAI,CAACR,oBAAL,CAA0B0C,MAA1B,GAAmClC,IAAI,CAACP,gBAAL,CAAsByC,MAAzD,GAAkElC,IAAI,CAACN,qBADzE;AAGD;AAED;AACA;AACA;AACA;AACA;;;AACAzC,IAAI,CAAC0D,SAAL,CAAe6E,cAAf,GAAgC,YAAW;AACzC,SAAO,KAAKhG,oBAAL,CAA0BiG,MAA1B,CAAiC,KAAKhG,gBAAtC,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAxC,IAAI,CAAC0D,SAAL,CAAeE,GAAf,GAAqB,YAAW;AAC9B,SAAO,KAAK2E,cAAL,GAAsB,CAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAvI,IAAI,CAAC0D,SAAL,CAAeiC,WAAf,GAA6B,YAAW;AACtC;AACA,MAAI,KAAKrD,KAAL,KAAe1C,SAAf,IAA4B,KAAK0C,KAAL,KAAe3C,UAA/C,EAA2D;AACzD,WAAO,KAAP;AACD,GAJqC,CAMtC;;;AACA,MAAI8I,WAAW,GAAG,KAAKlG,oBAAL,CAA0BiG,MAA1B,CAAiC,KAAKhG,gBAAtC,CAAlB,CAPsC,CAStC;;AACA,OAAK,IAAIoE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,WAAW,CAACxD,MAAhC,EAAwC2B,CAAC,EAAzC,EAA6C;AAC3C,QAAI6B,WAAW,CAAC7B,CAAD,CAAX,CAAejB,WAAf,EAAJ,EAAkC,OAAO,IAAP;AACnC,GAZqC,CActC;;;AACA,SAAO,KAAP;AACD,CAhBD;AAkBA;AACA;AACA;AACA;AACA;;;AACA3F,IAAI,CAAC0D,SAAL,CAAegF,WAAf,GAA6B,YAAW;AACtC,SAAO,KAAKpG,KAAL,KAAe1C,SAAf,IAA4B,KAAK0C,KAAL,KAAe3C,UAAlD;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAK,IAAI,CAAC0D,SAAL,CAAeiF,cAAf,GAAgC,YAAW;AACzC,SAAO,KAAKrG,KAAL,KAAe9C,YAAtB;AACD,CAFD;AAIA;AACA;AACA;;;AACAQ,IAAI,CAAC0D,SAAL,CAAerE,OAAf,GAAyB,YAAW;AAClC,MAAI,KAAKiD,KAAL,KAAe9C,YAAnB,EAAiC;AAC/B,UAAM,IAAInB,UAAJ,CAAe,kCAAkC,KAAKiE,KAAtD,CAAN;AACD;;AAED,QAAMyB,IAAI,GAAG,IAAb;AACAD,EAAAA,eAAe,CAAC,IAAD,EAAOrE,UAAP,CAAf;AAEAsE,EAAAA,IAAI,CAACtB,qBAAL;AACApD,EAAAA,OAAO,CAAC0E,IAAI,CAAC7D,OAAN,EAAe,CAACiD,GAAD,EAAMC,UAAN,KAAqB;AACzCW,IAAAA,IAAI,CAACtB,qBAAL;;AAEA,QAAIU,GAAJ,EAAS;AACP,UAAIY,IAAI,CAAC1B,MAAL,CAAYuD,OAAZ,EAAJ,EAA2B;AACzB7B,QAAAA,IAAI,CAAC1B,MAAL,CAAYwD,KAAZ,CAAmB,yCAAwCC,IAAI,CAACC,SAAL,CAAe5C,GAAf,CAAoB,GAA/E;AACD;;AAED,UAAIY,IAAI,CAACzB,KAAL,KAAe7C,UAAnB,EAA+B;AAC7BsE,QAAAA,IAAI,CAACU,IAAL,CAAU,OAAV,EAAmBtB,GAAnB;AACD;;AAED;AACD;;AAED,QAAIY,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzD,aAAOoE,IAAI,CAACe,OAAL,EAAP;AACD,KAjBwC,CAmBzC;;;AACA1B,IAAAA,UAAU,CAAC+C,EAAX,CAAc,OAAd,EAAuBpC,IAAI,CAACT,uBAA5B;AACAF,IAAAA,UAAU,CAAC+C,EAAX,CAAc,OAAd,EAAuBpC,IAAI,CAACb,uBAA5B;AACAE,IAAAA,UAAU,CAAC+C,EAAX,CAAc,SAAd,EAAyBpC,IAAI,CAACR,yBAA9B;AACAH,IAAAA,UAAU,CAAC+C,EAAX,CAAc,YAAd,EAA4BpC,IAAI,CAACP,4BAAjC;AACAJ,IAAAA,UAAU,CAAC+C,EAAX,CAAc,SAAd,EAAyBpC,IAAI,CAACf,eAA9B,EAxByC,CA0BzC;AACA;AACA;;AACA,QAAIe,IAAI,CAAC7D,OAAL,CAAa0I,UAAjB,EAA6B;AAC3B9E,MAAAA,eAAe,CAACC,IAAD,EAAOrE,SAAP,CAAf;AACAqE,MAAAA,IAAI,CAACxB,oBAAL,CAA0B6D,IAA1B,CAA+BhD,UAA/B;AACA,aAAOW,IAAI,CAACU,IAAL,CAAU,SAAV,EAAqBV,IAArB,EAA2BX,UAA3B,CAAP;AACD;;AAED,QAAIW,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzD,aAAOoE,IAAI,CAACe,OAAL,EAAP;AACD;;AAED,QAAI3B,GAAJ,EAAS;AACPY,MAAAA,IAAI,CAACe,OAAL;AACA,aAAOf,IAAI,CAACU,IAAL,CAAU,OAAV,EAAmBtB,GAAnB,CAAP;AACD;;AAEDW,IAAAA,eAAe,CAACC,IAAD,EAAOrE,SAAP,CAAf;AACAqE,IAAAA,IAAI,CAACxB,oBAAL,CAA0B6D,IAA1B,CAA+BhD,UAA/B;;AAEA,QAAIW,IAAI,CAACtD,OAAT,EAAkB;AAChB,WAAK,IAAImG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7C,IAAI,CAACtD,OAAzB,EAAkCmG,CAAC,EAAnC,EAAuC;AACrClB,QAAAA,iBAAiB,CAAC3B,IAAD,CAAjB;AACD;AACF;;AAEDA,IAAAA,IAAI,CAACU,IAAL,CAAU,SAAV,EAAqBV,IAArB,EAA2BX,UAA3B;AACD,GAtDM,CAAP;AAuDD,CAhED;AAkEA;AACA;AACA;AACA;;;AACApD,IAAI,CAAC0D,SAAL,CAAemF,IAAf,GAAsB,UAASC,WAAT,EAAsBC,QAAtB,EAAgC;AACpD,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACrC,CAFD;AAIA;AACA;AACA;AACA;;;AACA/I,IAAI,CAAC0D,SAAL,CAAesF,MAAf,GAAwB,UAASC,MAAT,EAAiBF,QAAjB,EAA2B;AACjD,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACrC,CAFD;AAIA;AACA;AACA;AACA;;;AACA/I,IAAI,CAAC0D,SAAL,CAAewF,KAAf,GAAuB,YAAW;AAChC;AACA,MAAIT,WAAW,GAAG,KAAKlG,oBAAL,CAA0BiG,MAA1B,CAAiC,KAAKhG,gBAAtC,CAAlB;AAEAiG,EAAAA,WAAW,CAACxC,OAAZ,CAAoB,UAASkD,CAAT,EAAY;AAC9BA,IAAAA,CAAC,CAACD,KAAF;AACD,GAFD;AAGD,CAPD,C,CASA;;;AACA,SAASpE,OAAT,CAAiBf,IAAjB,EAAuB0E,WAAvB,EAAoCvI,OAApC,EAA6C6I,QAA7C,EAAuD;AACrDxJ,EAAAA,SAAS,CACPkJ,WADO,EAEP,CAAC7D,IAAD,EAAOQ,EAAP,KAAc;AACZ,SAAK,MAAMgE,SAAX,IAAwBvJ,iBAAxB,EAA2C;AACzC+E,MAAAA,IAAI,CAACsB,kBAAL,CAAwBkD,SAAxB;AACD;;AAEDxE,IAAAA,IAAI,CAACE,OAAL,CAAa5E,OAAb,EAAsBkF,EAAtB;AACD,GARM,EASPjC,GAAG,IAAI;AACL,QAAIA,GAAJ,EAAS;AACP,UAAI,OAAO4F,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC5F,GAAD,EAAM,IAAN,CAAR;AACpC;AACD;;AAEDU,IAAAA,cAAc,CAACE,IAAD,CAAd;AACAA,IAAAA,IAAI,CAACpB,KAAL,GAAa,EAAb;AAEAmB,IAAAA,eAAe,CAACC,IAAD,EAAOnE,SAAP,CAAf;AACA,QAAI,OAAOmJ,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACrC,GApBM,CAAT;AAsBD;AAED;AACA;AACA;AACA;;;AACA/I,IAAI,CAAC0D,SAAL,CAAeoB,OAAf,GAAyB,UAASuE,KAAT,EAAgBN,QAAhB,EAA0B;AACjD,MAAIhF,IAAI,GAAG,IAAX,CADiD,CAEjD;;AACA,MAAI,KAAKzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzD,QAAI,OAAOoJ,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACpC;AACD,GANgD,CAQjD;;;AACAjF,EAAAA,eAAe,CAAC,IAAD,EAAOnE,UAAP,CAAf,CATiD,CAWjD;;AACA,MAAI0J,KAAJ,EAAW;AACT;AACA,QAAIZ,WAAW,GAAG1E,IAAI,CAACxB,oBAAL,CAA0BiG,MAA1B,CAAiCzE,IAAI,CAACvB,gBAAtC,CAAlB,CAFS,CAIT;AACA;;AACA,WAAOuB,IAAI,CAACpB,KAAL,CAAWsC,MAAX,GAAoB,CAA3B,EAA8B;AAC5B,UAAIC,QAAQ,GAAGnB,IAAI,CAACpB,KAAL,CAAWwC,KAAX,EAAf;;AACA,UAAI,OAAOD,QAAQ,CAACE,EAAhB,KAAuB,UAA3B,EAAuC;AACrCF,QAAAA,QAAQ,CAACE,EAAT,CAAY,IAAI/G,UAAJ,CAAe,0BAAf,CAAZ;AACD;AACF,KAXQ,CAaT;;;AACA,WAAOyG,OAAO,CAACf,IAAD,EAAO0E,WAAP,EAAoB;AAAEY,MAAAA,KAAK,EAAE;AAAT,KAApB,EAAqCN,QAArC,CAAd;AACD,GA3BgD,CA6BjD;;;AACA,MAAI,KAAK/G,WAAT,EAAsB;AACpBsH,IAAAA,YAAY,CAAC,KAAKtH,WAAN,CAAZ;AACD,GAhCgD,CAkCjD;AACA;;;AACA,MAAI,KAAKY,mBAAT,EAA8B;AAC5B,SAAKA,mBAAL,CAAyBkC,OAAzB;AACD,GAtCgD,CAwCjD;;;AACA,WAASyE,WAAT,GAAuB;AACrBC,IAAAA,yBAAyB,CAACzF,IAAI,CAACpB,KAAN,CAAzB;;AAEA,QAAIoB,IAAI,CAACpB,KAAL,CAAWsC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B;AACA,UAAIwD,WAAW,GAAG1E,IAAI,CAACxB,oBAAL,CAA0BiG,MAA1B,CAAiCzE,IAAI,CAACvB,gBAAtC,CAAlB,CAF2B,CAI3B;;AACA,WAAK,IAAIoE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,WAAW,CAACxD,MAAhC,EAAwC2B,CAAC,EAAzC,EAA6C;AAC3C;AACA;AACA,YAAI6B,WAAW,CAAC7B,CAAD,CAAX,CAAe5B,SAAf,CAAyBC,MAAzB,GAAkC,CAAtC,EAAyC;AACvC,iBAAOK,UAAU,CAACiE,WAAD,EAAc,CAAd,CAAjB;AACD;AACF;;AAEDzE,MAAAA,OAAO,CAACf,IAAD,EAAO0E,WAAP,EAAoB;AAAEY,QAAAA,KAAK,EAAE;AAAT,OAApB,EAAsCN,QAAtC,CAAP,CAb2B,CAc3B;AACD,KAfD,MAeO;AACL;AACA1C,MAAAA,QAAQ,CAACtC,IAAD,CAAR,GAFK,CAGL;;;AACAuB,MAAAA,UAAU,CAACiE,WAAD,EAAc,CAAd,CAAV;AACD;AACF,GAjEgD,CAmEjD;;;AACAA,EAAAA,WAAW;AACZ,CArED;AAuEA;AACA;AACA;AACA;AACA;;;AACAvJ,IAAI,CAAC0D,SAAL,CAAe+F,KAAf,GAAuB,UAASV,QAAT,EAAmB;AACxC,QAAMN,WAAW,GAAG,KAAKlG,oBAAL,CAA0BiG,MAA1B,CAAiC,KAAKhG,gBAAtC,CAApB;AACAjD,EAAAA,SAAS,CACPkJ,WADO,EAEP,CAAC7D,IAAD,EAAOQ,EAAP,KAAc;AACZ,SAAK,MAAMgE,SAAX,IAAwBvJ,iBAAxB,EAA2C;AACzC+E,MAAAA,IAAI,CAACsB,kBAAL,CAAwBkD,SAAxB;AACD;;AAEDxE,IAAAA,IAAI,CAACE,OAAL,CAAa;AAAEuE,MAAAA,KAAK,EAAE;AAAT,KAAb,EAA8BjE,EAA9B;AACD,GARM,EASPjC,GAAG,IAAI;AACL,QAAIA,GAAJ,EAAS;AACP,UAAI,OAAO4F,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,QAAAA,QAAQ,CAAC5F,GAAD,EAAM,IAAN,CAAR;AACA;AACD;AACF;;AAEDU,IAAAA,cAAc,CAAC,IAAD,CAAd,CARK,CAUL;;AACA6B,IAAAA,iBAAiB,CAAC,IAAD,CAAjB;;AAEA,QAAI,OAAOqD,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,MAAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACD;AACF,GAzBM,CAAT;AA2BD,CA7BD,C,CA+BA;;;AACA,SAASW,gBAAT,CAA0B3F,IAA1B,EAAgC+D,OAAhC,EAAyCiB,QAAzC,EAAmD;AACjD,QAAMY,qBAAqB,GAAG7B,OAAO,CAAC8B,KAAR,EAA9B,CADiD,CAGjD;;AACA,QAAMC,cAAc,GAAG,CAAC,CAAC9F,IAAI,CAAC7D,OAAL,CAAa4J,gBAAtC;;AACA,MAAI,CAACD,cAAD,IAAmB,CAACE,WAAW,CAACjC,OAAD,CAAnC,EAA8C;AAC5C,WAAOiB,QAAQ,CAAC,IAAD,EAAOY,qBAAP,CAAf;AACD,GAPgD,CASjD;;;AACA,QAAMK,iCAAiC,GAAG5K,MAAM,CAACoJ,MAAP,CAAcmB,qBAAd,CAA1C;AACA,QAAMM,qBAAqB,GAAGD,iCAAiC,CAACE,KAAlC,CAAwCrL,mBAAxC,CAA9B,CAXiD,CAajD;;AACA,QAAMsL,qBAAqB,GAAGH,iCAAiC,CAACI,WAAlC,CAA8C,EAA9C,CAA9B,CAdiD,CAgBjD;;AACApL,EAAAA,QAAQ,CAAC+E,IAAD,EAAOkG,qBAAP,EAA8B,UAAS9G,GAAT,EAAckH,iBAAd,EAAiC;AACrE,QAAIlH,GAAJ,EAAS,OAAO4F,QAAQ,CAAC5F,GAAD,EAAM,IAAN,CAAf,CAD4D,CAGrE;;AACA,UAAMmH,SAAS,GAAGlL,MAAM,CAACmL,KAAP,CAAa1L,mBAAb,CAAlB;AACAyL,IAAAA,SAAS,CAACE,YAAV,CACE3L,mBAAmB,GAAGC,wBAAtB,GAAiDuL,iBAAiB,CAACpF,MADrE,EAEE,CAFF,EALqE,CAQlE;;AACHqF,IAAAA,SAAS,CAACE,YAAV,CAAuB1C,OAAO,CAACjB,SAA/B,EAA0C,CAA1C,EATqE,CASvB;;AAC9CyD,IAAAA,SAAS,CAACE,YAAV,CAAuB,CAAvB,EAA0B,CAA1B,EAVqE,CAUvC;;AAC9BF,IAAAA,SAAS,CAACE,YAAV,CAAuBzL,OAAO,CAAC0L,aAA/B,EAA8C,EAA9C,EAXqE,CAWlB;AAEnD;;AACA,UAAMC,kBAAkB,GAAGtL,MAAM,CAACmL,KAAP,CAAazL,wBAAb,CAA3B;AACA4L,IAAAA,kBAAkB,CAACF,YAAnB,CAAgCL,qBAAhC,EAAuD,CAAvD,EAfqE,CAeV;;AAC3DO,IAAAA,kBAAkB,CAACF,YAAnB,CAAgCP,qBAAqB,CAAChF,MAAtD,EAA8D,CAA9D,EAhBqE,CAgBH;;AAClEyF,IAAAA,kBAAkB,CAACC,UAAnB,CAA8B1L,aAAa,CAAC8E,IAAI,CAAC7D,OAAL,CAAa4J,gBAAd,CAA3C,EAA4E,CAA5E,EAjBqE,CAiBW;;AAEhF,WAAOf,QAAQ,CAAC,IAAD,EAAO,CAACuB,SAAD,EAAYI,kBAAZ,EAAgCL,iBAAhC,CAAP,CAAf;AACD,GApBO,CAAR;AAqBD;AAED;AACA;AACA;AACA;AACA;;;AACArK,IAAI,CAAC0D,SAAL,CAAekH,KAAf,GAAuB,UAAS9C,OAAT,EAAkB5H,OAAlB,EAA2BkF,EAA3B,EAA+B;AACpD,MAAIrB,IAAI,GAAG,IAAX,CADoD,CAEpD;;AACA,MAAI,OAAO7D,OAAP,KAAmB,UAAvB,EAAmC;AACjCkF,IAAAA,EAAE,GAAGlF,OAAL;AACD,GALmD,CAOpD;;;AACAA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CARoD,CAUpD;;AACA,MAAI,EAAE,OAAOkF,EAAP,KAAc,UAAhB,KAA+B,CAAClF,OAAO,CAAC2K,UAA5C,EAAwD;AACtD,UAAM,IAAIxM,UAAJ,CAAe,sCAAf,CAAN;AACD,GAbmD,CAepD;;;AACA,MAAI,KAAKiE,KAAL,KAAe1C,SAAf,IAA4B,KAAK0C,KAAL,KAAe3C,UAA/C,EAA2D;AACzD;AACA,QAAIyF,EAAJ,EAAQ;AACN,UAAI;AACFA,QAAAA,EAAE,CAAC,IAAI/G,UAAJ,CAAe,gBAAf,CAAD,CAAF;AACD,OAFD,CAEE,OAAO8E,GAAP,EAAY;AACZkE,QAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1B,gBAAMnE,GAAN;AACD,SAFD;AAGD;AACF;;AAED;AACD;;AAED,MAAI,KAAKjD,OAAL,CAAa2B,cAAb,IAA+BwF,OAAO,CAACyD,MAAvC,IAAiD,OAAO1F,EAAP,KAAc,UAAnE,EAA+E;AAC7E;AACA,QAAI2F,KAAK,GAAG3F,EAAZ;AACAA,IAAAA,EAAE,GAAGiC,OAAO,CAACyD,MAAR,CAAeE,IAAf,CAAoB,YAAW;AAClC;AACA,UAAIC,IAAI,GAAG,IAAIC,KAAJ,CAAUC,SAAS,CAAClG,MAApB,CAAX;;AACA,WAAK,IAAI2B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuE,SAAS,CAAClG,MAA9B,EAAsC2B,CAAC,EAAvC,EAA2C;AACzCqE,QAAAA,IAAI,CAACrE,CAAD,CAAJ,GAAUuE,SAAS,CAACvE,CAAD,CAAnB;AACD,OALiC,CAMlC;;;AACAS,MAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1ByD,QAAAA,KAAK,CAACK,KAAN,CAAY,IAAZ,EAAkBH,IAAlB;AACD,OAFD;AAGD,KAVI,CAAL;AAWD,GA7CmD,CA+CpD;;;AACA,MAAII,SAAS,GAAG;AACdjG,IAAAA,EAAE,EAAEA,EADU;AAEd6B,IAAAA,GAAG,EAAE,KAFS;AAGd1F,IAAAA,YAAY,EAAE,IAHA;AAIdC,IAAAA,aAAa,EAAE,IAJD;AAKdC,IAAAA,cAAc,EAAE,KALF;AAMd6G,IAAAA,UAAU,EAAE;AANE,GAAhB,CAhDoD,CAyDpD;;AACA+C,EAAAA,SAAS,CAAC9J,YAAV,GAAyB,OAAOrB,OAAO,CAACqB,YAAf,KAAgC,SAAhC,GAA4CrB,OAAO,CAACqB,YAApD,GAAmE,IAA5F;AACA8J,EAAAA,SAAS,CAAC7J,aAAV,GACE,OAAOtB,OAAO,CAACsB,aAAf,KAAiC,SAAjC,GAA6CtB,OAAO,CAACsB,aAArD,GAAqE,IADvE;AAEA6J,EAAAA,SAAS,CAAC5J,cAAV,GACE,OAAOvB,OAAO,CAACuB,cAAf,KAAkC,SAAlC,GAA8CvB,OAAO,CAACuB,cAAtD,GAAuE,KADzE;AAEA4J,EAAAA,SAAS,CAACpE,GAAV,GAAgB,OAAO/G,OAAO,CAAC+G,GAAf,KAAuB,SAAvB,GAAmC/G,OAAO,CAAC+G,GAA3C,GAAiD,KAAjE;AACAoE,EAAAA,SAAS,CAAC9D,gBAAV,GACE,OAAOrH,OAAO,CAACqH,gBAAf,KAAoC,SAApC,GAAgDrH,OAAO,CAACqH,gBAAxD,GAA2E,KAD7E;AAEA8D,EAAAA,SAAS,CAACC,mBAAV,GAAgCpL,OAAO,CAACoL,mBAAxC;AACAD,EAAAA,SAAS,CAACvD,OAAV,GAAoB,OAAO5H,OAAO,CAAC4H,OAAf,KAA2B,SAA3B,GAAuC5H,OAAO,CAAC4H,OAA/C,GAAyD,KAA7E;AACAuD,EAAAA,SAAS,CAAC/C,UAAV,GAAuB,OAAOpI,OAAO,CAACoI,UAAf,KAA8B,SAA9B,GAA0CpI,OAAO,CAACoI,UAAlD,GAA+D,KAAtF;AACA+C,EAAAA,SAAS,CAACR,UAAV,GAAuB,OAAO3K,OAAO,CAAC2K,UAAf,KAA8B,SAA9B,GAA0C3K,OAAO,CAAC2K,UAAlD,GAA+D,KAAtF;AACAQ,EAAAA,SAAS,CAAC1D,OAAV,GAAoBzH,OAAO,CAACyH,OAAR,IAAmB,IAAvC,CAtEoD,CAwEpD;;AACA0D,EAAAA,SAAS,CAAC1K,aAAV,GAA0BT,OAAO,CAACS,aAAlC;AACA0K,EAAAA,SAAS,CAACtE,UAAV,GAAuB7G,OAAO,CAAC6G,UAA/B,CA1EoD,CA2EpD;;AACA,MAAI7G,OAAO,CAACS,aAAZ,EAA2B;AACzB0K,IAAAA,SAAS,CAAC1K,aAAV,GAA0BT,OAAO,CAACS,aAAlC;AACD,GA9EmD,CAgFpD;;;AACA0K,EAAAA,SAAS,CAACxE,SAAV,GAAsBiB,OAAO,CAACjB,SAA9B,CAjFoD,CAmFpD;;AACA,MAAI9C,IAAI,CAAC7D,OAAL,CAAaqL,eAAjB,EAAkC;AAChC,SAAK9G,IAAL,CAAU,gBAAV,EAA4B,IAAItF,GAAG,CAACqM,mBAAR,CAA4B,IAA5B,EAAkC1D,OAAlC,CAA5B;AAEAuD,IAAAA,SAAS,CAACI,OAAV,GAAoBpE,OAAO,CAACqE,MAAR,EAApB;;AACAL,IAAAA,SAAS,CAACjG,EAAV,GAAe,CAACjC,GAAD,EAAMwI,KAAN,KAAgB;AAC7B,UAAIxI,GAAJ,EAAS;AACPY,QAAAA,IAAI,CAACU,IAAL,CACE,eADF,EAEE,IAAItF,GAAG,CAACyM,kBAAR,CAA2B,IAA3B,EAAiC9D,OAAjC,EAA0C3E,GAA1C,EAA+CkI,SAAS,CAACI,OAAzD,CAFF;AAID,OALD,MAKO;AACL,YAAIE,KAAK,IAAIA,KAAK,CAACvE,MAAf,KAA0BuE,KAAK,CAACvE,MAAN,CAAaa,EAAb,KAAoB,CAApB,IAAyB0D,KAAK,CAACvE,MAAN,CAAac,IAAhE,CAAJ,EAA2E;AACzEnE,UAAAA,IAAI,CAACU,IAAL,CACE,eADF,EAEE,IAAItF,GAAG,CAACyM,kBAAR,CAA2B,IAA3B,EAAiC9D,OAAjC,EAA0C6D,KAAK,CAACvE,MAAhD,EAAwDiE,SAAS,CAACI,OAAlE,CAFF;AAID,SALD,MAKO;AACL1H,UAAAA,IAAI,CAACU,IAAL,CACE,kBADF,EAEE,IAAItF,GAAG,CAAC0M,qBAAR,CAA8B,IAA9B,EAAoC/D,OAApC,EAA6C6D,KAA7C,EAAoDN,SAAS,CAACI,OAA9D,CAFF;AAID;AACF;;AAED,UAAI,OAAOrG,EAAP,KAAc,UAAlB,EAA8BA,EAAE,CAACjC,GAAD,EAAMwI,KAAN,CAAF;AAC/B,KArBD;AAsBD,GA9GmD,CAgHpD;;;AACAjC,EAAAA,gBAAgB,CAAC3F,IAAD,EAAO+D,OAAP,EAAgB,CAAC3E,GAAD,EAAM2I,iBAAN,KAA4B;AAC1D,QAAI3I,GAAJ,EAAS,MAAMA,GAAN,CADiD,CAG1D;;AACAkI,IAAAA,SAAS,CAACU,MAAV,GAAmBD,iBAAnB,CAJ0D,CAM1D;AACA;;AACA,QAAI5L,OAAO,CAAC6G,UAAZ,EAAwB;AACtBhD,MAAAA,IAAI,CAACpB,KAAL,CAAWqJ,OAAX,CAAmBX,SAAnB;AACD,KAFD,MAEO;AACLtH,MAAAA,IAAI,CAACpB,KAAL,CAAWyD,IAAX,CAAgBiF,SAAhB;AACD,KAZyD,CAc1D;;;AACA,QAAI,CAACtH,IAAI,CAACrB,SAAV,EAAqB;AACnB2E,MAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1BjB,QAAAA,QAAQ,CAACtC,IAAD,CAAR;AACD,OAFD;AAGD;AACF,GApBe,CAAhB;AAqBD,CAtID,C,CAwIA;AACA;;;AACA,SAASgG,WAAT,CAAqBjC,OAArB,EAA8B;AAC5B,QAAMmE,UAAU,GAAGnE,OAAO,YAAYnJ,GAAnB,GAAyBmJ,OAAO,CAACA,OAAjC,GAA2CA,OAAO,CAACoE,KAAtE;AACA,QAAMC,WAAW,GAAG/L,MAAM,CAACgM,IAAP,CAAYH,UAAZ,EAAwB,CAAxB,CAApB;AACA,SAAO/M,sBAAsB,CAACsF,OAAvB,CAA+B2H,WAA/B,MAAgD,CAAC,CAAxD;AACD,C,CAED;;;AACA,SAASE,MAAT,CAAgBjJ,UAAhB,EAA4BqF,WAA5B,EAAyC;AACvC,OAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,WAAW,CAACxD,MAAhC,EAAwC2B,CAAC,EAAzC,EAA6C;AAC3C,QAAI6B,WAAW,CAAC7B,CAAD,CAAX,KAAmBxD,UAAvB,EAAmC;AACjCqF,MAAAA,WAAW,CAAC/B,MAAZ,CAAmBE,CAAnB,EAAsB,CAAtB;AACA,aAAO,IAAP;AACD;AACF;AACF;;AAED,SAAS7B,gBAAT,CAA0BhB,IAA1B,EAAgCX,UAAhC,EAA4C;AAC1C,MAAIiJ,MAAM,CAACjJ,UAAD,EAAaW,IAAI,CAACxB,oBAAlB,CAAV,EAAmD;AACnD,MAAI8J,MAAM,CAACjJ,UAAD,EAAaW,IAAI,CAACvB,gBAAlB,CAAV,EAA+C;AAChD;;AAED,MAAMwD,QAAQ,GAAG,CAAC,OAAD,EAAU,SAAV,EAAqB,OAArB,EAA8B,SAA9B,EAAyC,YAAzC,EAAuD,SAAvD,CAAjB;;AACA,SAASN,iBAAT,CAA2B3B,IAA3B,EAAiC;AAC/B,MAAIA,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzD;AACD;;AAEDoE,EAAAA,IAAI,CAACtB,qBAAL;AACApD,EAAAA,OAAO,CAAC0E,IAAI,CAAC7D,OAAN,EAAe,CAACiD,GAAD,EAAMC,UAAN,KAAqB;AACzCW,IAAAA,IAAI,CAACtB,qBAAL;;AAEA,QAAIU,GAAJ,EAAS;AACP,UAAIY,IAAI,CAAC1B,MAAL,CAAYuD,OAAZ,EAAJ,EAA2B;AACzB7B,QAAAA,IAAI,CAAC1B,MAAL,CAAYwD,KAAZ,CAAmB,yCAAwCC,IAAI,CAACC,SAAL,CAAe5C,GAAf,CAAoB,GAA/E;AACD;;AAED,UAAI,CAACY,IAAI,CAAC/B,WAAN,IAAqB+B,IAAI,CAAC7D,OAAL,CAAawB,SAAtC,EAAiD;AAC/CqC,QAAAA,IAAI,CAAC/B,WAAL,GAAmBsD,UAAU,CAACC,gBAAgB,CAACxB,IAAD,CAAjB,EAAyBA,IAAI,CAAC7D,OAAL,CAAayB,iBAAtC,CAA7B;AACD;;AAED;AACD;;AAED,QAAIoC,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzDoF,MAAAA,gBAAgB,CAAChB,IAAD,EAAOX,UAAP,CAAhB;AACA,aAAOA,UAAU,CAAC0B,OAAX,EAAP;AACD;;AAED1B,IAAAA,UAAU,CAAC+C,EAAX,CAAc,OAAd,EAAuBpC,IAAI,CAACT,uBAA5B;AACAF,IAAAA,UAAU,CAAC+C,EAAX,CAAc,OAAd,EAAuBpC,IAAI,CAACb,uBAA5B;AACAE,IAAAA,UAAU,CAAC+C,EAAX,CAAc,SAAd,EAAyBpC,IAAI,CAACR,yBAA9B;AACAH,IAAAA,UAAU,CAAC+C,EAAX,CAAc,YAAd,EAA4BpC,IAAI,CAACP,4BAAjC;AACAJ,IAAAA,UAAU,CAAC+C,EAAX,CAAc,SAAd,EAAyBpC,IAAI,CAACf,eAA9B;;AAEA,QAAIe,IAAI,CAACzB,KAAL,KAAe1C,SAAf,IAA4BmE,IAAI,CAACzB,KAAL,KAAe3C,UAA/C,EAA2D;AACzD,aAAOyD,UAAU,CAAC0B,OAAX,EAAP;AACD,KA5BwC,CA8BzC;;;AACAC,IAAAA,gBAAgB,CAAChB,IAAD,EAAOX,UAAP,CAAhB,CA/ByC,CAiCzC;;AACA,QAAID,GAAJ,EAAS;AACP,aAAOC,UAAU,CAAC0B,OAAX,EAAP;AACD,KApCwC,CAsCzC;;;AACAf,IAAAA,IAAI,CAACxB,oBAAL,CAA0B6D,IAA1B,CAA+BhD,UAA/B,EAvCyC,CAwCzC;;AACAiD,IAAAA,QAAQ,CAACtC,IAAD,CAAR;AACD,GA1CM,CAAP;AA2CD;;AAED,SAASyF,yBAAT,CAAmC7G,KAAnC,EAA0C;AACxC,OAAK,IAAIiE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjE,KAAK,CAACsC,MAA1B,EAAkC2B,CAAC,EAAnC,EAAuC;AACrC,QAAIjE,KAAK,CAACiE,CAAD,CAAL,CAASG,UAAb,EAAyB;AACvB,UAAI7B,QAAQ,GAAGvC,KAAK,CAACiE,CAAD,CAApB;AACAjE,MAAAA,KAAK,CAAC+D,MAAN,CAAaE,CAAb,EAAgB,CAAhB;AACA1B,MAAAA,QAAQ,CAACE,EAAT,CACE,IAAI/G,UAAJ,CAAe;AAAEsI,QAAAA,OAAO,EAAE,wCAAX;AAAqD2F,QAAAA,MAAM,EAAE;AAA7D,OAAf,CADF;AAGD;AACF;AACF;;AAED,SAASjG,QAAT,CAAkBtC,IAAlB,EAAwB;AACtB,SAAO,YAAW;AAChB,QAAIA,IAAI,CAACzB,KAAL,KAAe1C,SAAnB,EAA8B,OADd,CAEhB;;AACA,QAAImE,IAAI,CAACrB,SAAT,EAAoB,OAHJ,CAIhB;;AACAqB,IAAAA,IAAI,CAACrB,SAAL,GAAiB,IAAjB,CALgB,CAOhB;AACA;AACA;;AACA,QAAIqB,IAAI,CAACtB,qBAAL,GAA6B,CAAjC,EAAoC;AAClCsB,MAAAA,IAAI,CAACrB,SAAL,GAAiB,KAAjB;AACA;AACD,KAbe,CAehB;AACA;;;AACA,WAAO,IAAP,EAAa;AACX;AACA,YAAM8C,gBAAgB,GAAGC,oBAAoB,CAAC1B,IAAD,CAA7C,CAFW,CAIX;;AACA,UAAIA,IAAI,CAACxB,oBAAL,CAA0B0C,MAA1B,KAAqC,CAAzC,EAA4C;AAC1C;AACAuE,QAAAA,yBAAyB,CAACzF,IAAI,CAACpB,KAAN,CAAzB;AACA;AACD,OATU,CAWX;;;AACA,UAAIoB,IAAI,CAACpB,KAAL,CAAWsC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B;AACD;;AAED,UAAI7B,UAAU,GAAG,IAAjB;AACA,YAAMqF,WAAW,GAAG1E,IAAI,CAACxB,oBAAL,CAA0BgK,MAA1B,CAAiC3H,IAAI,IAAIA,IAAI,CAACI,SAAL,CAAeC,MAAf,KAA0B,CAAnE,CAApB,CAjBW,CAmBX;;AACA,UAAIwD,WAAW,CAACxD,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B7B,QAAAA,UAAU,GACRW,IAAI,CAACxB,oBAAL,CAA0BwB,IAAI,CAACjB,eAAL,KAAyBiB,IAAI,CAACxB,oBAAL,CAA0B0C,MAA7E,CADF;AAED,OAHD,MAGO;AACL7B,QAAAA,UAAU,GAAGqF,WAAW,CAAC1E,IAAI,CAACjB,eAAL,KAAyB2F,WAAW,CAACxD,MAAtC,CAAxB;AACD,OAzBU,CA2BX;;;AACA,UAAI,CAAC7B,UAAU,CAACuC,WAAX,EAAL,EAA+B;AAC7B;AACAZ,QAAAA,gBAAgB,CAAChB,IAAD,EAAOX,UAAP,CAAhB,CAF6B,CAG7B;;AACAoG,QAAAA,yBAAyB,CAACzF,IAAI,CAACpB,KAAN,CAAzB;AACA;AACD,OAlCU,CAoCX;;;AACA,UAAIuC,QAAQ,GAAGnB,IAAI,CAACpB,KAAL,CAAWwC,KAAX,EAAf,CArCW,CAuCX;AACA;AACA;;AACA,UAAID,QAAQ,CAAC6B,UAAb,EAAyB;AACvB,YAAIyF,oBAAoB,GAAG,KAA3B;;AAEA,aAAK,IAAI5F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7C,IAAI,CAACxB,oBAAL,CAA0B0C,MAA9C,EAAsD2B,CAAC,EAAvD,EAA2D;AACzD;AACA;AACA;AACA,cACE7C,IAAI,CAACxB,oBAAL,CAA0BqE,CAA1B,EAA6BjB,WAA7B,MACA5B,IAAI,CAACxB,oBAAL,CAA0BqE,CAA1B,EAA6B5B,SAA7B,CAAuCC,MAAvC,KAAkD,CAFpD,EAGE;AACAuH,YAAAA,oBAAoB,GAAG,IAAvB;AACApJ,YAAAA,UAAU,GAAGW,IAAI,CAACxB,oBAAL,CAA0BqE,CAA1B,CAAb;AACA;AACD;AACF,SAfsB,CAiBvB;AACA;;;AACA,YAAI,CAAC4F,oBAAL,EAA2B;AACzB;AACAzI,UAAAA,IAAI,CAACpB,KAAL,CAAWqJ,OAAX,CAAmB9G,QAAnB,EAFyB,CAIzB;;AACA,cAAIM,gBAAgB,GAAGzB,IAAI,CAAC7D,OAAL,CAAaM,IAAhC,IAAwCuD,IAAI,CAACpB,KAAL,CAAWsC,MAAX,GAAoB,CAAhE,EAAmE;AACjE;AACAS,YAAAA,iBAAiB,CAAC3B,IAAD,CAAjB;AACD,WARwB,CAUzB;;;AACAuB,UAAAA,UAAU,CAAC,YAAW;AACpBe,YAAAA,QAAQ,CAACtC,IAAD,CAAR;AACD,WAFS,EAEP,EAFO,CAAV;AAIA;AACD;AACF,OA9EU,CAgFX;;;AACA,UAAIyB,gBAAgB,GAAGzB,IAAI,CAAC7D,OAAL,CAAaM,IAApC,EAA0C;AACxC;AACA;AACA,YAAI4C,UAAU,CAAC4B,SAAX,CAAqBC,MAArB,GAA8B,CAAlC,EAAqC;AACnC;AACAlB,UAAAA,IAAI,CAACpB,KAAL,CAAWqJ,OAAX,CAAmB9G,QAAnB,EAFmC,CAGnC;;AACAQ,UAAAA,iBAAiB,CAAC3B,IAAD,CAAjB,CAJmC,CAKnC;;;AACA;AACD;AACF,OA5FU,CA8FX;;;AACA,UAAIgI,MAAM,GAAG7G,QAAQ,CAAC6G,MAAtB,CA/FW,CAiGX;;AACA,UAAI7G,QAAQ,CAAC6B,UAAb,EAAyB;AACvBT,QAAAA,qBAAqB,CAAClD,UAAD,EAAaW,IAAI,CAACxB,oBAAlB,EAAwCwB,IAAI,CAACvB,gBAA7C,CAArB;AACD,OApGU,CAsGX;AACA;;;AACA,UAAI,CAAC0C,QAAQ,CAAC2F,UAAd,EAA0B;AACxBzH,QAAAA,UAAU,CAAC4B,SAAX,CAAqBoB,IAArB,CAA0BlB,QAA1B;AACD,OA1GU,CA4GX;;;AACA,UAAI,CAACA,QAAQ,CAACqC,gBAAV,IAA8B,OAAOrC,QAAQ,CAACvE,aAAhB,KAAkC,QAApE,EAA8E;AAC5EyC,QAAAA,UAAU,CAACqJ,gBAAX,CAA4BvH,QAAQ,CAACvE,aAArC;AACD,OA/GU,CAiHX;;;AACA,UAAI+L,eAAe,GAAG,IAAtB,CAlHW,CAoHX;;AACA,UAAIxB,KAAK,CAACyB,OAAN,CAAcZ,MAAd,CAAJ,EAA2B;AACzB,aAAK,IAAInF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmF,MAAM,CAAC9G,MAA3B,EAAmC2B,CAAC,EAApC,EAAwC;AACtC8F,UAAAA,eAAe,GAAGtJ,UAAU,CAACwH,KAAX,CAAiBmB,MAAM,CAACnF,CAAD,CAAvB,CAAlB;AACD;AACF,OAJD,MAIO;AACL8F,QAAAA,eAAe,GAAGtJ,UAAU,CAACwH,KAAX,CAAiBmB,MAAjB,CAAlB;AACD,OA3HU,CA6HX;;;AACA,UAAI7G,QAAQ,CAAC2F,UAAT,IAAuB,OAAO3F,QAAQ,CAACE,EAAhB,KAAuB,UAAlD,EAA8D;AAC5DF,QAAAA,QAAQ,CAACE,EAAT,CAAY,IAAZ,EAAkB,IAAlB;AACD;;AAED,UAAIsH,eAAe,KAAK,KAAxB,EAA+B;AAC7B;AACA3I,QAAAA,IAAI,CAACpB,KAAL,CAAWqJ,OAAX,CAAmB9G,QAAnB,EAF6B,CAG7B;;AACAH,QAAAA,gBAAgB,CAAChB,IAAD,EAAOX,UAAP,CAAhB,CAJ6B,CAK7B;;AACAoG,QAAAA,yBAAyB,CAACzF,IAAI,CAACpB,KAAN,CAAzB;AACA;AACD;AACF;;AAEDoB,IAAAA,IAAI,CAACrB,SAAL,GAAiB,KAAjB;AACD,GA/JD;AAgKD,C,CAED;;;AACA1C,IAAI,CAACqG,QAAL,GAAgBA,QAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEAuG,MAAM,CAACC,OAAP,GAAiB7M,IAAjB","sourcesContent":["'use strict';\r\n\r\nconst inherits = require('util').inherits;\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst MongoError = require('../error').MongoError;\r\nconst MongoNetworkError = require('../error').MongoNetworkError;\r\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\r\nconst Logger = require('./logger');\r\nconst f = require('util').format;\r\nconst Msg = require('./msg').Msg;\r\nconst CommandResult = require('./command_result');\r\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\r\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\r\nconst opcodes = require('../wireprotocol/shared').opcodes;\r\nconst compress = require('../wireprotocol/compression').compress;\r\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\r\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\r\nconst apm = require('./apm');\r\nconst Buffer = require('safe-buffer').Buffer;\r\nconst connect = require('./connect');\r\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\r\nconst eachAsync = require('../utils').eachAsync;\r\n\r\nvar DISCONNECTED = 'disconnected';\r\nvar CONNECTING = 'connecting';\r\nvar CONNECTED = 'connected';\r\nvar DESTROYING = 'destroying';\r\nvar DESTROYED = 'destroyed';\r\n\r\nconst CONNECTION_EVENTS = new Set([\r\n  'error',\r\n  'close',\r\n  'timeout',\r\n  'parseError',\r\n  'connect',\r\n  'message'\r\n]);\r\n\r\nvar _id = 0;\r\n\r\n/**\r\n * Creates a new Pool instance\r\n * @class\r\n * @param {string} options.host The server host\r\n * @param {number} options.port The server port\r\n * @param {number} [options.size=5] Max server connection pool size\r\n * @param {number} [options.minSize=0] Minimum server connection pool size\r\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\r\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\r\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\r\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passPhrase] SSL Certificate pass phrase\r\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @fires Pool#connect\r\n * @fires Pool#close\r\n * @fires Pool#error\r\n * @fires Pool#timeout\r\n * @fires Pool#parseError\r\n * @return {Pool} A cursor instance\r\n */\r\nvar Pool = function(topology, options) {\r\n  // Add event listener\r\n  EventEmitter.call(this);\r\n\r\n  // Store topology for later use\r\n  this.topology = topology;\r\n\r\n  // Add the options\r\n  this.options = Object.assign(\r\n    {\r\n      // Host and port settings\r\n      host: 'localhost',\r\n      port: 27017,\r\n      // Pool default max size\r\n      size: 5,\r\n      // Pool default min size\r\n      minSize: 0,\r\n      // socket settings\r\n      connectionTimeout: 30000,\r\n      socketTimeout: 360000,\r\n      keepAlive: true,\r\n      keepAliveInitialDelay: 300000,\r\n      noDelay: true,\r\n      // SSL Settings\r\n      ssl: false,\r\n      checkServerIdentity: true,\r\n      ca: null,\r\n      crl: null,\r\n      cert: null,\r\n      key: null,\r\n      passPhrase: null,\r\n      rejectUnauthorized: false,\r\n      promoteLongs: true,\r\n      promoteValues: true,\r\n      promoteBuffers: false,\r\n      // Reconnection options\r\n      reconnect: true,\r\n      reconnectInterval: 1000,\r\n      reconnectTries: 30,\r\n      // Enable domains\r\n      domainsEnabled: false\r\n    },\r\n    options\r\n  );\r\n\r\n  // Identification information\r\n  this.id = _id++;\r\n  // Current reconnect retries\r\n  this.retriesLeft = this.options.reconnectTries;\r\n  this.reconnectId = null;\r\n  // No bson parser passed in\r\n  if (\r\n    !options.bson ||\r\n    (options.bson &&\r\n      (typeof options.bson.serialize !== 'function' ||\r\n        typeof options.bson.deserialize !== 'function'))\r\n  ) {\r\n    throw new Error('must pass in valid bson parser');\r\n  }\r\n\r\n  // Logger instance\r\n  this.logger = Logger('Pool', options);\r\n  // Pool state\r\n  this.state = DISCONNECTED;\r\n  // Connections\r\n  this.availableConnections = [];\r\n  this.inUseConnections = [];\r\n  this.connectingConnections = 0;\r\n  // Currently executing\r\n  this.executing = false;\r\n  // Operation work queue\r\n  this.queue = [];\r\n\r\n  // Contains the reconnect connection\r\n  this.reconnectConnection = null;\r\n\r\n  // Number of consecutive timeouts caught\r\n  this.numberOfConsecutiveTimeouts = 0;\r\n  // Current pool Index\r\n  this.connectionIndex = 0;\r\n\r\n  // event handlers\r\n  const pool = this;\r\n  this._messageHandler = messageHandler(this);\r\n  this._connectionCloseHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'close', err, connection);\r\n  };\r\n\r\n  this._connectionErrorHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'error', err, connection);\r\n  };\r\n\r\n  this._connectionTimeoutHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'timeout', err, connection);\r\n  };\r\n\r\n  this._connectionParseErrorHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'parseError', err, connection);\r\n  };\r\n};\r\n\r\ninherits(Pool, EventEmitter);\r\n\r\nObject.defineProperty(Pool.prototype, 'size', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.size;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'minSize', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.minSize;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.connectionTimeout;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.socketTimeout;\r\n  }\r\n});\r\n\r\n// clears all pool state\r\nfunction resetPoolState(pool) {\r\n  pool.inUseConnections = [];\r\n  pool.availableConnections = [];\r\n  pool.connectingConnections = 0;\r\n  pool.executing = false;\r\n  pool.reconnectConnection = null;\r\n  pool.numberOfConsecutiveTimeouts = 0;\r\n  pool.connectionIndex = 0;\r\n  pool.retriesLeft = pool.options.reconnectTries;\r\n  pool.reconnectId = null;\r\n}\r\n\r\nfunction stateTransition(self, newState) {\r\n  var legalTransitions = {\r\n    disconnected: [CONNECTING, DESTROYING, DISCONNECTED],\r\n    connecting: [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],\r\n    connected: [CONNECTED, DISCONNECTED, DESTROYING],\r\n    destroying: [DESTROYING, DESTROYED],\r\n    destroyed: [DESTROYED]\r\n  };\r\n\r\n  // Get current state\r\n  var legalStates = legalTransitions[self.state];\r\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\r\n    self.emit('stateChanged', self.state, newState);\r\n    self.state = newState;\r\n  } else {\r\n    self.logger.error(\r\n      f(\r\n        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',\r\n        self.id,\r\n        self.state,\r\n        newState,\r\n        legalStates\r\n      )\r\n    );\r\n  }\r\n}\r\n\r\nfunction connectionFailureHandler(pool, event, err, conn) {\r\n  if (conn) {\r\n    if (conn._connectionFailHandled) return;\r\n    conn._connectionFailHandled = true;\r\n    conn.destroy();\r\n\r\n    // Remove the connection\r\n    removeConnection(pool, conn);\r\n\r\n    // Flush all work Items on this connection\r\n    while (conn.workItems.length > 0) {\r\n      const workItem = conn.workItems.shift();\r\n      if (workItem.cb) workItem.cb(err);\r\n    }\r\n  }\r\n\r\n  // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\r\n  if (event === 'timeout') {\r\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;\r\n\r\n    // Have we timed out more than reconnectTries in a row ?\r\n    // Force close the pool as we are trying to connect to tcp sink hole\r\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\r\n      pool.numberOfConsecutiveTimeouts = 0;\r\n      // Destroy all connections and pool\r\n      pool.destroy(true);\r\n      // Emit close event\r\n      return pool.emit('close', pool);\r\n    }\r\n  }\r\n\r\n  // No more socket available propegate the event\r\n  if (pool.socketCount() === 0) {\r\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING) {\r\n      stateTransition(pool, DISCONNECTED);\r\n    }\r\n\r\n    // Do not emit error events, they are always close events\r\n    // do not trigger the low level error handler in node\r\n    event = event === 'error' ? 'close' : event;\r\n    pool.emit(event, err);\r\n  }\r\n\r\n  // Start reconnection attempts\r\n  if (!pool.reconnectId && pool.options.reconnect) {\r\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\r\n  }\r\n\r\n  // Do we need to do anything to maintain the minimum pool size\r\n  const totalConnections = totalConnectionCount(pool);\r\n  if (totalConnections < pool.minSize) {\r\n    _createConnection(pool);\r\n  }\r\n}\r\n\r\nfunction attemptReconnect(self) {\r\n  return function() {\r\n    self.emit('attemptReconnect', self);\r\n    if (self.state === DESTROYED || self.state === DESTROYING) return;\r\n\r\n    // We are connected do not try again\r\n    if (self.isConnected()) {\r\n      self.reconnectId = null;\r\n      return;\r\n    }\r\n\r\n    self.connectingConnections++;\r\n    connect(self.options, (err, connection) => {\r\n      self.connectingConnections--;\r\n\r\n      if (err) {\r\n        if (self.logger.isDebug()) {\r\n          self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\r\n        }\r\n\r\n        self.retriesLeft = self.retriesLeft - 1;\r\n        if (self.retriesLeft <= 0) {\r\n          self.destroy();\r\n          self.emit(\r\n            'reconnectFailed',\r\n            new MongoNetworkError(\r\n              f(\r\n                'failed to reconnect after %s attempts with interval %s ms',\r\n                self.options.reconnectTries,\r\n                self.options.reconnectInterval\r\n              )\r\n            )\r\n          );\r\n        } else {\r\n          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if (self.state === DESTROYED || self.state === DESTROYING) {\r\n        return connection.destroy();\r\n      }\r\n\r\n      self.reconnectId = null;\r\n      handlers.forEach(event => connection.removeAllListeners(event));\r\n      connection.on('error', self._connectionErrorHandler);\r\n      connection.on('close', self._connectionCloseHandler);\r\n      connection.on('timeout', self._connectionTimeoutHandler);\r\n      connection.on('parseError', self._connectionParseErrorHandler);\r\n      connection.on('message', self._messageHandler);\r\n\r\n      self.retriesLeft = self.options.reconnectTries;\r\n      self.availableConnections.push(connection);\r\n      self.reconnectConnection = null;\r\n      self.emit('reconnect', self);\r\n      _execute(self)();\r\n    });\r\n  };\r\n}\r\n\r\nfunction moveConnectionBetween(connection, from, to) {\r\n  var index = from.indexOf(connection);\r\n  // Move the connection from connecting to available\r\n  if (index !== -1) {\r\n    from.splice(index, 1);\r\n    to.push(connection);\r\n  }\r\n}\r\n\r\nfunction messageHandler(self) {\r\n  return function(message, connection) {\r\n    // workItem to execute\r\n    var workItem = null;\r\n\r\n    // Locate the workItem\r\n    for (var i = 0; i < connection.workItems.length; i++) {\r\n      if (connection.workItems[i].requestId === message.responseTo) {\r\n        // Get the callback\r\n        workItem = connection.workItems[i];\r\n        // Remove from list of workItems\r\n        connection.workItems.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    if (workItem && workItem.monitoring) {\r\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\r\n    }\r\n\r\n    // Reset timeout counter\r\n    self.numberOfConsecutiveTimeouts = 0;\r\n\r\n    // Reset the connection timeout if we modified it for\r\n    // this operation\r\n    if (workItem && workItem.socketTimeout) {\r\n      connection.resetSocketTimeout();\r\n    }\r\n\r\n    // Log if debug enabled\r\n    if (self.logger.isDebug()) {\r\n      self.logger.debug(\r\n        f(\r\n          'message [%s] received from %s:%s',\r\n          message.raw.toString('hex'),\r\n          self.options.host,\r\n          self.options.port\r\n        )\r\n      );\r\n    }\r\n\r\n    function handleOperationCallback(self, cb, err, result) {\r\n      // No domain enabled\r\n      if (!self.options.domainsEnabled) {\r\n        return process.nextTick(function() {\r\n          return cb(err, result);\r\n        });\r\n      }\r\n\r\n      // Domain enabled just call the callback\r\n      cb(err, result);\r\n    }\r\n\r\n    // Keep executing, ensure current message handler does not stop execution\r\n    if (!self.executing) {\r\n      process.nextTick(function() {\r\n        _execute(self)();\r\n      });\r\n    }\r\n\r\n    // Time to dispatch the message if we have a callback\r\n    if (workItem && !workItem.immediateRelease) {\r\n      try {\r\n        // Parse the message according to the provided options\r\n        message.parse(workItem);\r\n      } catch (err) {\r\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\r\n      }\r\n\r\n      if (message.documents[0]) {\r\n        const document = message.documents[0];\r\n        const session = workItem.session;\r\n        if (session) {\r\n          updateSessionFromResponse(session, document);\r\n        }\r\n\r\n        if (document.$clusterTime) {\r\n          self.topology.clusterTime = document.$clusterTime;\r\n        }\r\n      }\r\n\r\n      // Establish if we have an error\r\n      if (workItem.command && message.documents[0]) {\r\n        const responseDoc = message.documents[0];\r\n\r\n        if (responseDoc.writeConcernError) {\r\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\r\n          return handleOperationCallback(self, workItem.cb, err);\r\n        }\r\n\r\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\r\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\r\n        }\r\n      }\r\n\r\n      // Add the connection details\r\n      message.hashedName = connection.hashedName;\r\n\r\n      // Return the documents\r\n      handleOperationCallback(\r\n        self,\r\n        workItem.cb,\r\n        null,\r\n        new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message)\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Return the total socket count in the pool.\r\n * @method\r\n * @return {Number} The number of socket available.\r\n */\r\nPool.prototype.socketCount = function() {\r\n  return this.availableConnections.length + this.inUseConnections.length;\r\n  // + this.connectingConnections.length;\r\n};\r\n\r\nfunction totalConnectionCount(pool) {\r\n  return (\r\n    pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections\r\n  );\r\n}\r\n\r\n/**\r\n * Return all pool connections\r\n * @method\r\n * @return {Connection[]} The pool connections\r\n */\r\nPool.prototype.allConnections = function() {\r\n  return this.availableConnections.concat(this.inUseConnections);\r\n};\r\n\r\n/**\r\n * Get a pool connection (round-robin)\r\n * @method\r\n * @return {Connection}\r\n */\r\nPool.prototype.get = function() {\r\n  return this.allConnections()[0];\r\n};\r\n\r\n/**\r\n * Is the pool connected\r\n * @method\r\n * @return {boolean}\r\n */\r\nPool.prototype.isConnected = function() {\r\n  // We are in a destroyed state\r\n  if (this.state === DESTROYED || this.state === DESTROYING) {\r\n    return false;\r\n  }\r\n\r\n  // Get connections\r\n  var connections = this.availableConnections.concat(this.inUseConnections);\r\n\r\n  // Check if we have any connected connections\r\n  for (var i = 0; i < connections.length; i++) {\r\n    if (connections[i].isConnected()) return true;\r\n  }\r\n\r\n  // Not connected\r\n  return false;\r\n};\r\n\r\n/**\r\n * Was the pool destroyed\r\n * @method\r\n * @return {boolean}\r\n */\r\nPool.prototype.isDestroyed = function() {\r\n  return this.state === DESTROYED || this.state === DESTROYING;\r\n};\r\n\r\n/**\r\n * Is the pool in a disconnected state\r\n * @method\r\n * @return {boolean}\r\n */\r\nPool.prototype.isDisconnected = function() {\r\n  return this.state === DISCONNECTED;\r\n};\r\n\r\n/**\r\n * Connect pool\r\n */\r\nPool.prototype.connect = function() {\r\n  if (this.state !== DISCONNECTED) {\r\n    throw new MongoError('connection in unlawful state ' + this.state);\r\n  }\r\n\r\n  const self = this;\r\n  stateTransition(this, CONNECTING);\r\n\r\n  self.connectingConnections++;\r\n  connect(self.options, (err, connection) => {\r\n    self.connectingConnections--;\r\n\r\n    if (err) {\r\n      if (self.logger.isDebug()) {\r\n        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\r\n      }\r\n\r\n      if (self.state === CONNECTING) {\r\n        self.emit('error', err);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (self.state === DESTROYED || self.state === DESTROYING) {\r\n      return self.destroy();\r\n    }\r\n\r\n    // attach event handlers\r\n    connection.on('error', self._connectionErrorHandler);\r\n    connection.on('close', self._connectionCloseHandler);\r\n    connection.on('timeout', self._connectionTimeoutHandler);\r\n    connection.on('parseError', self._connectionParseErrorHandler);\r\n    connection.on('message', self._messageHandler);\r\n\r\n    // If we are in a topology, delegate the auth to it\r\n    // This is to avoid issues where we would auth against an\r\n    // arbiter\r\n    if (self.options.inTopology) {\r\n      stateTransition(self, CONNECTED);\r\n      self.availableConnections.push(connection);\r\n      return self.emit('connect', self, connection);\r\n    }\r\n\r\n    if (self.state === DESTROYED || self.state === DESTROYING) {\r\n      return self.destroy();\r\n    }\r\n\r\n    if (err) {\r\n      self.destroy();\r\n      return self.emit('error', err);\r\n    }\r\n\r\n    stateTransition(self, CONNECTED);\r\n    self.availableConnections.push(connection);\r\n\r\n    if (self.minSize) {\r\n      for (let i = 0; i < self.minSize; i++) {\r\n        _createConnection(self);\r\n      }\r\n    }\r\n\r\n    self.emit('connect', self, connection);\r\n  });\r\n};\r\n\r\n/**\r\n * Authenticate using a specified mechanism\r\n * @param {authResultCallback} callback A callback function\r\n */\r\nPool.prototype.auth = function(credentials, callback) {\r\n  if (typeof callback === 'function') callback(null, null);\r\n};\r\n\r\n/**\r\n * Logout all users against a database\r\n * @param {authResultCallback} callback A callback function\r\n */\r\nPool.prototype.logout = function(dbName, callback) {\r\n  if (typeof callback === 'function') callback(null, null);\r\n};\r\n\r\n/**\r\n * Unref the pool\r\n * @method\r\n */\r\nPool.prototype.unref = function() {\r\n  // Get all the known connections\r\n  var connections = this.availableConnections.concat(this.inUseConnections);\r\n\r\n  connections.forEach(function(c) {\r\n    c.unref();\r\n  });\r\n};\r\n\r\n// Destroy the connections\r\nfunction destroy(self, connections, options, callback) {\r\n  eachAsync(\r\n    connections,\r\n    (conn, cb) => {\r\n      for (const eventName of CONNECTION_EVENTS) {\r\n        conn.removeAllListeners(eventName);\r\n      }\r\n\r\n      conn.destroy(options, cb);\r\n    },\r\n    err => {\r\n      if (err) {\r\n        if (typeof callback === 'function') callback(err, null);\r\n        return;\r\n      }\r\n\r\n      resetPoolState(self);\r\n      self.queue = [];\r\n\r\n      stateTransition(self, DESTROYED);\r\n      if (typeof callback === 'function') callback(null, null);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Destroy pool\r\n * @method\r\n */\r\nPool.prototype.destroy = function(force, callback) {\r\n  var self = this;\r\n  // Do not try again if the pool is already dead\r\n  if (this.state === DESTROYED || self.state === DESTROYING) {\r\n    if (typeof callback === 'function') callback(null, null);\r\n    return;\r\n  }\r\n\r\n  // Set state to destroyed\r\n  stateTransition(this, DESTROYING);\r\n\r\n  // Are we force closing\r\n  if (force) {\r\n    // Get all the known connections\r\n    var connections = self.availableConnections.concat(self.inUseConnections);\r\n\r\n    // Flush any remaining work items with\r\n    // an error\r\n    while (self.queue.length > 0) {\r\n      var workItem = self.queue.shift();\r\n      if (typeof workItem.cb === 'function') {\r\n        workItem.cb(new MongoError('Pool was force destroyed'));\r\n      }\r\n    }\r\n\r\n    // Destroy the topology\r\n    return destroy(self, connections, { force: true }, callback);\r\n  }\r\n\r\n  // Clear out the reconnect if set\r\n  if (this.reconnectId) {\r\n    clearTimeout(this.reconnectId);\r\n  }\r\n\r\n  // If we have a reconnect connection running, close\r\n  // immediately\r\n  if (this.reconnectConnection) {\r\n    this.reconnectConnection.destroy();\r\n  }\r\n\r\n  // Wait for the operations to drain before we close the pool\r\n  function checkStatus() {\r\n    flushMonitoringOperations(self.queue);\r\n\r\n    if (self.queue.length === 0) {\r\n      // Get all the known connections\r\n      var connections = self.availableConnections.concat(self.inUseConnections);\r\n\r\n      // Check if we have any in flight operations\r\n      for (var i = 0; i < connections.length; i++) {\r\n        // There is an operation still in flight, reschedule a\r\n        // check waiting for it to drain\r\n        if (connections[i].workItems.length > 0) {\r\n          return setTimeout(checkStatus, 1);\r\n        }\r\n      }\r\n\r\n      destroy(self, connections, { force: false }, callback);\r\n      // } else if (self.queue.length > 0 && !this.reconnectId) {\r\n    } else {\r\n      // Ensure we empty the queue\r\n      _execute(self)();\r\n      // Set timeout\r\n      setTimeout(checkStatus, 1);\r\n    }\r\n  }\r\n\r\n  // Initiate drain of operations\r\n  checkStatus();\r\n};\r\n\r\n/**\r\n * Reset all connections of this pool\r\n *\r\n * @param {function} [callback]\r\n */\r\nPool.prototype.reset = function(callback) {\r\n  const connections = this.availableConnections.concat(this.inUseConnections);\r\n  eachAsync(\r\n    connections,\r\n    (conn, cb) => {\r\n      for (const eventName of CONNECTION_EVENTS) {\r\n        conn.removeAllListeners(eventName);\r\n      }\r\n\r\n      conn.destroy({ force: true }, cb);\r\n    },\r\n    err => {\r\n      if (err) {\r\n        if (typeof callback === 'function') {\r\n          callback(err, null);\r\n          return;\r\n        }\r\n      }\r\n\r\n      resetPoolState(this);\r\n\r\n      // create an initial connection, and kick off execution again\r\n      _createConnection(this);\r\n\r\n      if (typeof callback === 'function') {\r\n        callback(null, null);\r\n      }\r\n    }\r\n  );\r\n};\r\n\r\n// Prepare the buffer that Pool.prototype.write() uses to send to the server\r\nfunction serializeCommand(self, command, callback) {\r\n  const originalCommandBuffer = command.toBin();\r\n\r\n  // Check whether we and the server have agreed to use a compressor\r\n  const shouldCompress = !!self.options.agreedCompressor;\r\n  if (!shouldCompress || !canCompress(command)) {\r\n    return callback(null, originalCommandBuffer);\r\n  }\r\n\r\n  // Transform originalCommandBuffer into OP_COMPRESSED\r\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\r\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\r\n\r\n  // Extract information needed for OP_COMPRESSED from the uncompressed message\r\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\r\n\r\n  // Compress the message body\r\n  compress(self, messageToBeCompressed, function(err, compressedMessage) {\r\n    if (err) return callback(err, null);\r\n\r\n    // Create the msgHeader of OP_COMPRESSED\r\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\r\n    msgHeader.writeInt32LE(\r\n      MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\r\n      0\r\n    ); // messageLength\r\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\r\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\r\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\r\n\r\n    // Create the compression details of OP_COMPRESSED\r\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\r\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\r\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\r\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\r\n\r\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\r\n  });\r\n}\r\n\r\n/**\r\n * Write a message to MongoDB\r\n * @method\r\n * @return {Connection}\r\n */\r\nPool.prototype.write = function(command, options, cb) {\r\n  var self = this;\r\n  // Ensure we have a callback\r\n  if (typeof options === 'function') {\r\n    cb = options;\r\n  }\r\n\r\n  // Always have options\r\n  options = options || {};\r\n\r\n  // We need to have a callback function unless the message returns no response\r\n  if (!(typeof cb === 'function') && !options.noResponse) {\r\n    throw new MongoError('write method must provide a callback');\r\n  }\r\n\r\n  // Pool was destroyed error out\r\n  if (this.state === DESTROYED || this.state === DESTROYING) {\r\n    // Callback with an error\r\n    if (cb) {\r\n      try {\r\n        cb(new MongoError('pool destroyed'));\r\n      } catch (err) {\r\n        process.nextTick(function() {\r\n          throw err;\r\n        });\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\r\n    // if we have a domain bind to it\r\n    var oldCb = cb;\r\n    cb = process.domain.bind(function() {\r\n      // v8 - argumentsToArray one-liner\r\n      var args = new Array(arguments.length);\r\n      for (var i = 0; i < arguments.length; i++) {\r\n        args[i] = arguments[i];\r\n      }\r\n      // bounce off event loop so domain switch takes place\r\n      process.nextTick(function() {\r\n        oldCb.apply(null, args);\r\n      });\r\n    });\r\n  }\r\n\r\n  // Do we have an operation\r\n  var operation = {\r\n    cb: cb,\r\n    raw: false,\r\n    promoteLongs: true,\r\n    promoteValues: true,\r\n    promoteBuffers: false,\r\n    fullResult: false\r\n  };\r\n\r\n  // Set the options for the parsing\r\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\r\n  operation.promoteValues =\r\n    typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\r\n  operation.promoteBuffers =\r\n    typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\r\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\r\n  operation.immediateRelease =\r\n    typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\r\n  operation.documentsReturnedIn = options.documentsReturnedIn;\r\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\r\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\r\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\r\n  operation.session = options.session || null;\r\n\r\n  // Optional per operation socketTimeout\r\n  operation.socketTimeout = options.socketTimeout;\r\n  operation.monitoring = options.monitoring;\r\n  // Custom socket Timeout\r\n  if (options.socketTimeout) {\r\n    operation.socketTimeout = options.socketTimeout;\r\n  }\r\n\r\n  // Get the requestId\r\n  operation.requestId = command.requestId;\r\n\r\n  // If command monitoring is enabled we need to modify the callback here\r\n  if (self.options.monitorCommands) {\r\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\r\n\r\n    operation.started = process.hrtime();\r\n    operation.cb = (err, reply) => {\r\n      if (err) {\r\n        self.emit(\r\n          'commandFailed',\r\n          new apm.CommandFailedEvent(this, command, err, operation.started)\r\n        );\r\n      } else {\r\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\r\n          self.emit(\r\n            'commandFailed',\r\n            new apm.CommandFailedEvent(this, command, reply.result, operation.started)\r\n          );\r\n        } else {\r\n          self.emit(\r\n            'commandSucceeded',\r\n            new apm.CommandSucceededEvent(this, command, reply, operation.started)\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof cb === 'function') cb(err, reply);\r\n    };\r\n  }\r\n\r\n  // Prepare the operation buffer\r\n  serializeCommand(self, command, (err, serializedBuffers) => {\r\n    if (err) throw err;\r\n\r\n    // Set the operation's buffer to the serialization of the commands\r\n    operation.buffer = serializedBuffers;\r\n\r\n    // If we have a monitoring operation schedule as the very first operation\r\n    // Otherwise add to back of queue\r\n    if (options.monitoring) {\r\n      self.queue.unshift(operation);\r\n    } else {\r\n      self.queue.push(operation);\r\n    }\r\n\r\n    // Attempt to execute the operation\r\n    if (!self.executing) {\r\n      process.nextTick(function() {\r\n        _execute(self)();\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n// Return whether a command contains an uncompressible command term\r\n// Will return true if command contains no uncompressible command terms\r\nfunction canCompress(command) {\r\n  const commandDoc = command instanceof Msg ? command.command : command.query;\r\n  const commandName = Object.keys(commandDoc)[0];\r\n  return uncompressibleCommands.indexOf(commandName) === -1;\r\n}\r\n\r\n// Remove connection method\r\nfunction remove(connection, connections) {\r\n  for (var i = 0; i < connections.length; i++) {\r\n    if (connections[i] === connection) {\r\n      connections.splice(i, 1);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction removeConnection(self, connection) {\r\n  if (remove(connection, self.availableConnections)) return;\r\n  if (remove(connection, self.inUseConnections)) return;\r\n}\r\n\r\nconst handlers = ['close', 'message', 'error', 'timeout', 'parseError', 'connect'];\r\nfunction _createConnection(self) {\r\n  if (self.state === DESTROYED || self.state === DESTROYING) {\r\n    return;\r\n  }\r\n\r\n  self.connectingConnections++;\r\n  connect(self.options, (err, connection) => {\r\n    self.connectingConnections--;\r\n\r\n    if (err) {\r\n      if (self.logger.isDebug()) {\r\n        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\r\n      }\r\n\r\n      if (!self.reconnectId && self.options.reconnect) {\r\n        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (self.state === DESTROYED || self.state === DESTROYING) {\r\n      removeConnection(self, connection);\r\n      return connection.destroy();\r\n    }\r\n\r\n    connection.on('error', self._connectionErrorHandler);\r\n    connection.on('close', self._connectionCloseHandler);\r\n    connection.on('timeout', self._connectionTimeoutHandler);\r\n    connection.on('parseError', self._connectionParseErrorHandler);\r\n    connection.on('message', self._messageHandler);\r\n\r\n    if (self.state === DESTROYED || self.state === DESTROYING) {\r\n      return connection.destroy();\r\n    }\r\n\r\n    // Remove the connection from the connectingConnections list\r\n    removeConnection(self, connection);\r\n\r\n    // Handle error\r\n    if (err) {\r\n      return connection.destroy();\r\n    }\r\n\r\n    // Push to available\r\n    self.availableConnections.push(connection);\r\n    // Execute any work waiting\r\n    _execute(self)();\r\n  });\r\n}\r\n\r\nfunction flushMonitoringOperations(queue) {\r\n  for (var i = 0; i < queue.length; i++) {\r\n    if (queue[i].monitoring) {\r\n      var workItem = queue[i];\r\n      queue.splice(i, 1);\r\n      workItem.cb(\r\n        new MongoError({ message: 'no connection available for monitoring', driver: true })\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction _execute(self) {\r\n  return function() {\r\n    if (self.state === DESTROYED) return;\r\n    // Already executing, skip\r\n    if (self.executing) return;\r\n    // Set pool as executing\r\n    self.executing = true;\r\n\r\n    // New pool connections are in progress, wait them to finish\r\n    // before executing any more operation to ensure distribution of\r\n    // operations\r\n    if (self.connectingConnections > 0) {\r\n      self.executing = false;\r\n      return;\r\n    }\r\n\r\n    // As long as we have available connections\r\n    // eslint-disable-next-line\r\n    while (true) {\r\n      // Total availble connections\r\n      const totalConnections = totalConnectionCount(self);\r\n\r\n      // No available connections available, flush any monitoring ops\r\n      if (self.availableConnections.length === 0) {\r\n        // Flush any monitoring operations\r\n        flushMonitoringOperations(self.queue);\r\n        break;\r\n      }\r\n\r\n      // No queue break\r\n      if (self.queue.length === 0) {\r\n        break;\r\n      }\r\n\r\n      var connection = null;\r\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0);\r\n\r\n      // No connection found that has no work on it, just pick one for pipelining\r\n      if (connections.length === 0) {\r\n        connection =\r\n          self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\r\n      } else {\r\n        connection = connections[self.connectionIndex++ % connections.length];\r\n      }\r\n\r\n      // Is the connection connected\r\n      if (!connection.isConnected()) {\r\n        // Remove the disconnected connection\r\n        removeConnection(self, connection);\r\n        // Flush any monitoring operations in the queue, failing fast\r\n        flushMonitoringOperations(self.queue);\r\n        break;\r\n      }\r\n\r\n      // Get the next work item\r\n      var workItem = self.queue.shift();\r\n\r\n      // If we are monitoring we need to use a connection that is not\r\n      // running another operation to avoid socket timeout changes\r\n      // affecting an existing operation\r\n      if (workItem.monitoring) {\r\n        var foundValidConnection = false;\r\n\r\n        for (let i = 0; i < self.availableConnections.length; i++) {\r\n          // If the connection is connected\r\n          // And there are no pending workItems on it\r\n          // Then we can safely use it for monitoring.\r\n          if (\r\n            self.availableConnections[i].isConnected() &&\r\n            self.availableConnections[i].workItems.length === 0\r\n          ) {\r\n            foundValidConnection = true;\r\n            connection = self.availableConnections[i];\r\n            break;\r\n          }\r\n        }\r\n\r\n        // No safe connection found, attempt to grow the connections\r\n        // if possible and break from the loop\r\n        if (!foundValidConnection) {\r\n          // Put workItem back on the queue\r\n          self.queue.unshift(workItem);\r\n\r\n          // Attempt to grow the pool if it's not yet maxsize\r\n          if (totalConnections < self.options.size && self.queue.length > 0) {\r\n            // Create a new connection\r\n            _createConnection(self);\r\n          }\r\n\r\n          // Re-execute the operation\r\n          setTimeout(function() {\r\n            _execute(self)();\r\n          }, 10);\r\n\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Don't execute operation until we have a full pool\r\n      if (totalConnections < self.options.size) {\r\n        // Connection has work items, then put it back on the queue\r\n        // and create a new connection\r\n        if (connection.workItems.length > 0) {\r\n          // Lets put the workItem back on the list\r\n          self.queue.unshift(workItem);\r\n          // Create a new connection\r\n          _createConnection(self);\r\n          // Break from the loop\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Get actual binary commands\r\n      var buffer = workItem.buffer;\r\n\r\n      // If we are monitoring take the connection of the availableConnections\r\n      if (workItem.monitoring) {\r\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\r\n      }\r\n\r\n      // Track the executing commands on the mongo server\r\n      // as long as there is an expected response\r\n      if (!workItem.noResponse) {\r\n        connection.workItems.push(workItem);\r\n      }\r\n\r\n      // We have a custom socketTimeout\r\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\r\n        connection.setSocketTimeout(workItem.socketTimeout);\r\n      }\r\n\r\n      // Capture if write was successful\r\n      var writeSuccessful = true;\r\n\r\n      // Put operation on the wire\r\n      if (Array.isArray(buffer)) {\r\n        for (let i = 0; i < buffer.length; i++) {\r\n          writeSuccessful = connection.write(buffer[i]);\r\n        }\r\n      } else {\r\n        writeSuccessful = connection.write(buffer);\r\n      }\r\n\r\n      // if the command is designated noResponse, call the callback immeditely\r\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\r\n        workItem.cb(null, null);\r\n      }\r\n\r\n      if (writeSuccessful === false) {\r\n        // If write not successful put back on queue\r\n        self.queue.unshift(workItem);\r\n        // Remove the disconnected connection\r\n        removeConnection(self, connection);\r\n        // Flush any monitoring operations in the queue, failing fast\r\n        flushMonitoringOperations(self.queue);\r\n        break;\r\n      }\r\n    }\r\n\r\n    self.executing = false;\r\n  };\r\n}\r\n\r\n// Make execution loop available for testing\r\nPool._execute = _execute;\r\n\r\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Pool#connect\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * A server reconnect event, used to verify that pool reconnected.\r\n *\r\n * @event Pool#reconnect\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The server connection closed, all pool connections closed\r\n *\r\n * @event Pool#close\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The server connection caused an error, all pool connections closed\r\n *\r\n * @event Pool#error\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The server connection timed out, all pool connections closed\r\n *\r\n * @event Pool#timeout\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The driver experienced an invalid message, all pool connections closed\r\n *\r\n * @event Pool#parseError\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The driver attempted to reconnect\r\n *\r\n * @event Pool#attemptReconnect\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The driver exhausted all reconnect attempts\r\n *\r\n * @event Pool#reconnectFailed\r\n * @type {Pool}\r\n */\r\n\r\nmodule.exports = Pool;\r\n"]},"metadata":{},"sourceType":"script"}