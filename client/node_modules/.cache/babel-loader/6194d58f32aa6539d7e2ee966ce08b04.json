{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst requireOptional = require('require_optional');\n/**\r\n * Generate a UUIDv4\r\n */\n\n\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n};\n/**\r\n * Returns the duration calculated from two high resolution timers in milliseconds\r\n *\r\n * @param {Object} started A high resolution timestamp created from `process.hrtime()`\r\n * @returns {Number} The duration in milliseconds\r\n */\n\n\nconst calculateDurationInMs = started => {\n  const hrtime = process.hrtime(started);\n  return (hrtime[0] * 1e9 + hrtime[1]) / 1e6;\n};\n/**\r\n * Relays events for a given listener and emitter\r\n *\r\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\r\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\r\n */\n\n\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\n\nfunction retrieveKerberos() {\n  let kerberos;\n\n  try {\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n} // Throw an error if an attempt to use EJSON is made when it is not installed\n\n\nconst noEJSONError = function () {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n}; // Facilitate loading EJSON optionally\n\n\nfunction retrieveEJSON() {\n  let EJSON = null;\n\n  try {\n    EJSON = requireOptional('mongodb-extjson');\n  } catch (error) {} // eslint-disable-line\n\n\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology\r\n * instances\r\n *\r\n * @private\r\n * @param {(Topology|Server)} topologyOrServer\r\n */\n\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer.ismaster) {\n    return topologyOrServer.ismaster.maxWireVersion;\n  }\n\n  if (typeof topologyOrServer.lastIsMaster === 'function') {\n    const lastIsMaster = topologyOrServer.lastIsMaster();\n\n    if (lastIsMaster) {\n      return lastIsMaster.maxWireVersion;\n    }\n  }\n\n  if (topologyOrServer.description) {\n    return topologyOrServer.description.maxWireVersion;\n  }\n\n  return null;\n}\n/*\r\n * Checks that collation is supported by server.\r\n *\r\n * @param {Server} [server] to check against\r\n * @param {object} [cmd] object where collation may be specified\r\n * @param {function} [callback] callback function\r\n * @return true if server does not support collation\r\n */\n\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @param {*} maybePromise\r\n * @return true if the provided value is a Promise\r\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n *\r\n * @param {array} arr an array of items to asynchronusly iterate over\r\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param {function} callback The callback called after every item has been iterated\r\n */\n\n\nfunction eachAsync(arr, eachFn, callback) {\n  if (arr.length === 0) {\n    callback(null);\n    return;\n  }\n\n  const length = arr.length;\n  let completed = 0;\n\n  function eachCallback(err) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    if (++completed === length) {\n      callback(null);\n    }\n  }\n\n  for (let idx = 0; idx < length; ++idx) {\n    eachFn(arr[idx], eachCallback);\n  }\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nmodule.exports = {\n  uuidV4,\n  calculateDurationInMs,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  isUnifiedTopology\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/utils.js"],"names":["crypto","require","requireOptional","uuidV4","result","randomBytes","calculateDurationInMs","started","hrtime","process","relayEvents","listener","emitter","events","forEach","eventName","on","event","emit","retrieveKerberos","kerberos","err","code","Error","noEJSONError","retrieveEJSON","EJSON","error","parse","deserialize","serialize","stringify","setBSONModule","BSON","maxWireVersion","topologyOrServer","ismaster","lastIsMaster","description","collationNotSupported","server","cmd","collation","isPromiseLike","maybePromise","then","eachAsync","arr","eachFn","callback","length","completed","eachCallback","idx","isUnifiedTopology","topology","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst crypto = require('crypto');\r\nconst requireOptional = require('require_optional');\r\n\r\n/**\r\n * Generate a UUIDv4\r\n */\r\nconst uuidV4 = () => {\r\n  const result = crypto.randomBytes(16);\r\n  result[6] = (result[6] & 0x0f) | 0x40;\r\n  result[8] = (result[8] & 0x3f) | 0x80;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns the duration calculated from two high resolution timers in milliseconds\r\n *\r\n * @param {Object} started A high resolution timestamp created from `process.hrtime()`\r\n * @returns {Number} The duration in milliseconds\r\n */\r\nconst calculateDurationInMs = started => {\r\n  const hrtime = process.hrtime(started);\r\n  return (hrtime[0] * 1e9 + hrtime[1]) / 1e6;\r\n};\r\n\r\n/**\r\n * Relays events for a given listener and emitter\r\n *\r\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\r\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\r\n */\r\nfunction relayEvents(listener, emitter, events) {\r\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\r\n}\r\n\r\nfunction retrieveKerberos() {\r\n  let kerberos;\r\n\r\n  try {\r\n    kerberos = requireOptional('kerberos');\r\n  } catch (err) {\r\n    if (err.code === 'MODULE_NOT_FOUND') {\r\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\r\n    }\r\n\r\n    throw err;\r\n  }\r\n\r\n  return kerberos;\r\n}\r\n\r\n// Throw an error if an attempt to use EJSON is made when it is not installed\r\nconst noEJSONError = function() {\r\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\r\n};\r\n\r\n// Facilitate loading EJSON optionally\r\nfunction retrieveEJSON() {\r\n  let EJSON = null;\r\n  try {\r\n    EJSON = requireOptional('mongodb-extjson');\r\n  } catch (error) {} // eslint-disable-line\r\n  if (!EJSON) {\r\n    EJSON = {\r\n      parse: noEJSONError,\r\n      deserialize: noEJSONError,\r\n      serialize: noEJSONError,\r\n      stringify: noEJSONError,\r\n      setBSONModule: noEJSONError,\r\n      BSON: noEJSONError\r\n    };\r\n  }\r\n\r\n  return EJSON;\r\n}\r\n\r\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology\r\n * instances\r\n *\r\n * @private\r\n * @param {(Topology|Server)} topologyOrServer\r\n */\r\nfunction maxWireVersion(topologyOrServer) {\r\n  if (topologyOrServer.ismaster) {\r\n    return topologyOrServer.ismaster.maxWireVersion;\r\n  }\r\n\r\n  if (typeof topologyOrServer.lastIsMaster === 'function') {\r\n    const lastIsMaster = topologyOrServer.lastIsMaster();\r\n    if (lastIsMaster) {\r\n      return lastIsMaster.maxWireVersion;\r\n    }\r\n  }\r\n\r\n  if (topologyOrServer.description) {\r\n    return topologyOrServer.description.maxWireVersion;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/*\r\n * Checks that collation is supported by server.\r\n *\r\n * @param {Server} [server] to check against\r\n * @param {object} [cmd] object where collation may be specified\r\n * @param {function} [callback] callback function\r\n * @return true if server does not support collation\r\n */\r\nfunction collationNotSupported(server, cmd) {\r\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\r\n}\r\n\r\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @param {*} maybePromise\r\n * @return true if the provided value is a Promise\r\n */\r\nfunction isPromiseLike(maybePromise) {\r\n  return maybePromise && typeof maybePromise.then === 'function';\r\n}\r\n\r\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n *\r\n * @param {array} arr an array of items to asynchronusly iterate over\r\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param {function} callback The callback called after every item has been iterated\r\n */\r\nfunction eachAsync(arr, eachFn, callback) {\r\n  if (arr.length === 0) {\r\n    callback(null);\r\n    return;\r\n  }\r\n\r\n  const length = arr.length;\r\n  let completed = 0;\r\n  function eachCallback(err) {\r\n    if (err) {\r\n      callback(err, null);\r\n      return;\r\n    }\r\n\r\n    if (++completed === length) {\r\n      callback(null);\r\n    }\r\n  }\r\n\r\n  for (let idx = 0; idx < length; ++idx) {\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n}\r\n\r\nfunction isUnifiedTopology(topology) {\r\n  return topology.description != null;\r\n}\r\n\r\nmodule.exports = {\r\n  uuidV4,\r\n  calculateDurationInMs,\r\n  relayEvents,\r\n  collationNotSupported,\r\n  retrieveEJSON,\r\n  retrieveKerberos,\r\n  maxWireVersion,\r\n  isPromiseLike,\r\n  eachAsync,\r\n  isUnifiedTopology\r\n};\r\n"]},"metadata":{},"sourceType":"script"}