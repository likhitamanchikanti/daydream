{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../core/error').MongoError;\n\nconst Aspect = require('./operation').Aspect;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst ReadPreference = require('../core/topologies/read_preference');\n\nconst isRetryableError = require('../core/error').isRetryableError;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n/**\r\n * Executes the given operation with provided arguments.\r\n *\r\n * This method reduces large amounts of duplication in the entire codebase by providing\r\n * a single point for determining whether callbacks or promises should be used. Additionally\r\n * it allows for a single point of entry to provide features such as implicit sessions, which\r\n * are required by the Driver Sessions specification in the event that a ClientSession is\r\n * not provided\r\n *\r\n * @param {object} topology The topology to execute this operation on\r\n * @param {Operation} operation The operation to execute\r\n * @param {function} callback The command result callback\r\n */\n\n\nfunction executeOperation(topology, operation, callback) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  if (isUnifiedTopology(topology) && !operation.hasAspect(Aspect.SKIP_SESSION) && topology.shouldCheckForSessionSupport()) {\n    return selectServerForSessionSupport(topology, operation, callback);\n  }\n\n  const Promise = topology.s.promiseLibrary; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, owner;\n\n  if (!operation.hasAspect(Aspect.SKIP_SESSION) && topology.hasSessionSupport()) {\n    if (operation.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      operation.session = session;\n    } else if (operation.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner) {\n      session.endSession(() => {\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n\n    try {\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n        return executeWithServerSelection(topology, operation, handler);\n      } else {\n        return operation.execute(handler);\n      }\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n\n    try {\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n        return executeWithServerSelection(topology, operation, handler);\n      } else {\n        return operation.execute(handler);\n      }\n    } catch (e) {\n      handler(e);\n    }\n  });\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n} // TODO: This is only supported for unified topology, it should go away once\n//       we remove support for legacy topology types.\n\n\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  const Promise = topology.s.promiseLibrary;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      };\n    });\n  }\n\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n  return result;\n}\n\nmodule.exports = executeOperation;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/execute_operation.js"],"names":["MongoError","require","Aspect","OperationBase","ReadPreference","isRetryableError","maxWireVersion","isUnifiedTopology","executeOperation","topology","operation","callback","TypeError","hasAspect","SKIP_SESSION","shouldCheckForSessionSupport","selectServerForSessionSupport","Promise","s","promiseLibrary","session","owner","hasSessionSupport","Symbol","startSession","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","err","result","endSession","clearSession","handler","EXECUTE_WITH_SELECTION","executeWithServerSelection","execute","e","supportsRetryableReads","server","readPreference","primary","inTransaction","equals","mode","serverSelectionOptions","callbackWithRetry","selectServer","shouldRetryReads","options","retryReads","canRetryRead","RETRYABLE","primaryPreferred","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst MongoError = require('../core/error').MongoError;\r\nconst Aspect = require('./operation').Aspect;\r\nconst OperationBase = require('./operation').OperationBase;\r\nconst ReadPreference = require('../core/topologies/read_preference');\r\nconst isRetryableError = require('../core/error').isRetryableError;\r\nconst maxWireVersion = require('../core/utils').maxWireVersion;\r\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\r\n\r\n/**\r\n * Executes the given operation with provided arguments.\r\n *\r\n * This method reduces large amounts of duplication in the entire codebase by providing\r\n * a single point for determining whether callbacks or promises should be used. Additionally\r\n * it allows for a single point of entry to provide features such as implicit sessions, which\r\n * are required by the Driver Sessions specification in the event that a ClientSession is\r\n * not provided\r\n *\r\n * @param {object} topology The topology to execute this operation on\r\n * @param {Operation} operation The operation to execute\r\n * @param {function} callback The command result callback\r\n */\r\nfunction executeOperation(topology, operation, callback) {\r\n  if (topology == null) {\r\n    throw new TypeError('This method requires a valid topology instance');\r\n  }\r\n\r\n  if (!(operation instanceof OperationBase)) {\r\n    throw new TypeError('This method requires a valid operation instance');\r\n  }\r\n\r\n  if (\r\n    isUnifiedTopology(topology) &&\r\n    !operation.hasAspect(Aspect.SKIP_SESSION) &&\r\n    topology.shouldCheckForSessionSupport()\r\n  ) {\r\n    return selectServerForSessionSupport(topology, operation, callback);\r\n  }\r\n\r\n  const Promise = topology.s.promiseLibrary;\r\n\r\n  // The driver sessions spec mandates that we implicitly create sessions for operations\r\n  // that are not explicitly provided with a session.\r\n  let session, owner;\r\n  if (!operation.hasAspect(Aspect.SKIP_SESSION) && topology.hasSessionSupport()) {\r\n    if (operation.session == null) {\r\n      owner = Symbol();\r\n      session = topology.startSession({ owner });\r\n      operation.session = session;\r\n    } else if (operation.session.hasEnded) {\r\n      throw new MongoError('Use of expired sessions is not permitted');\r\n    }\r\n  }\r\n\r\n  const makeExecuteCallback = (resolve, reject) =>\r\n    function executeCallback(err, result) {\r\n      if (session && session.owner === owner) {\r\n        session.endSession(() => {\r\n          if (operation.session === session) {\r\n            operation.clearSession();\r\n          }\r\n          if (err) return reject(err);\r\n          resolve(result);\r\n        });\r\n      } else {\r\n        if (err) return reject(err);\r\n        resolve(result);\r\n      }\r\n    };\r\n\r\n  // Execute using callback\r\n  if (typeof callback === 'function') {\r\n    const handler = makeExecuteCallback(\r\n      result => callback(null, result),\r\n      err => callback(err, null)\r\n    );\r\n\r\n    try {\r\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\r\n        return executeWithServerSelection(topology, operation, handler);\r\n      } else {\r\n        return operation.execute(handler);\r\n      }\r\n    } catch (e) {\r\n      handler(e);\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    const handler = makeExecuteCallback(resolve, reject);\r\n\r\n    try {\r\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\r\n        return executeWithServerSelection(topology, operation, handler);\r\n      } else {\r\n        return operation.execute(handler);\r\n      }\r\n    } catch (e) {\r\n      handler(e);\r\n    }\r\n  });\r\n}\r\n\r\nfunction supportsRetryableReads(server) {\r\n  return maxWireVersion(server) >= 6;\r\n}\r\n\r\nfunction executeWithServerSelection(topology, operation, callback) {\r\n  const readPreference = operation.readPreference || ReadPreference.primary;\r\n  const inTransaction = operation.session && operation.session.inTransaction();\r\n\r\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\r\n    callback(\r\n      new MongoError(\r\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\r\n      )\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  const serverSelectionOptions = {\r\n    readPreference,\r\n    session: operation.session\r\n  };\r\n\r\n  function callbackWithRetry(err, result) {\r\n    if (err == null) {\r\n      return callback(null, result);\r\n    }\r\n\r\n    if (!isRetryableError(err)) {\r\n      return callback(err);\r\n    }\r\n\r\n    // select a new server, and attempt to retry the operation\r\n    topology.selectServer(serverSelectionOptions, (err, server) => {\r\n      if (err || !supportsRetryableReads(server)) {\r\n        callback(err, null);\r\n        return;\r\n      }\r\n\r\n      operation.execute(server, callback);\r\n    });\r\n  }\r\n\r\n  // select a server, and execute the operation against it\r\n  topology.selectServer(serverSelectionOptions, (err, server) => {\r\n    if (err) {\r\n      callback(err, null);\r\n      return;\r\n    }\r\n\r\n    const shouldRetryReads =\r\n      topology.s.options.retryReads !== false &&\r\n      (operation.session && !inTransaction) &&\r\n      supportsRetryableReads(server) &&\r\n      operation.canRetryRead;\r\n\r\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\r\n      operation.execute(server, callbackWithRetry);\r\n      return;\r\n    }\r\n\r\n    operation.execute(server, callback);\r\n  });\r\n}\r\n\r\n// TODO: This is only supported for unified topology, it should go away once\r\n//       we remove support for legacy topology types.\r\nfunction selectServerForSessionSupport(topology, operation, callback) {\r\n  const Promise = topology.s.promiseLibrary;\r\n\r\n  let result;\r\n  if (typeof callback !== 'function') {\r\n    result = new Promise((resolve, reject) => {\r\n      callback = (err, result) => {\r\n        if (err) return reject(err);\r\n        resolve(result);\r\n      };\r\n    });\r\n  }\r\n\r\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    executeOperation(topology, operation, callback);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = executeOperation;\r\n"]},"metadata":{},"sourceType":"script"}