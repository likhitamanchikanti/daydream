{"ast":null,"code":"'use strict';\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n/**\r\n * Published when server description changes, but does NOT include changes to the RTT.\r\n *\r\n * @property {Object} topologyId A unique identifier for the topology\r\n * @property {ServerAddress} address The address (host/port pair) of the server\r\n * @property {ServerDescription} previousDescription The previous server description\r\n * @property {ServerDescription} newDescription The new server description\r\n */\n\n\nclass ServerDescriptionChangedEvent {\n  constructor(topologyId, address, previousDescription, newDescription) {\n    Object.assign(this, {\n      topologyId,\n      address,\n      previousDescription,\n      newDescription\n    });\n  }\n\n}\n/**\r\n * Published when server is initialized.\r\n *\r\n * @property {Object} topologyId A unique identifier for the topology\r\n * @property {ServerAddress} address The address (host/port pair) of the server\r\n */\n\n\nclass ServerOpeningEvent {\n  constructor(topologyId, address) {\n    Object.assign(this, {\n      topologyId,\n      address\n    });\n  }\n\n}\n/**\r\n * Published when server is closed.\r\n *\r\n * @property {ServerAddress} address The address (host/port pair) of the server\r\n * @property {Object} topologyId A unique identifier for the topology\r\n */\n\n\nclass ServerClosedEvent {\n  constructor(topologyId, address) {\n    Object.assign(this, {\n      topologyId,\n      address\n    });\n  }\n\n}\n/**\r\n * Published when topology description changes.\r\n *\r\n * @property {Object} topologyId\r\n * @property {TopologyDescription} previousDescription The old topology description\r\n * @property {TopologyDescription} newDescription The new topology description\r\n */\n\n\nclass TopologyDescriptionChangedEvent {\n  constructor(topologyId, previousDescription, newDescription) {\n    Object.assign(this, {\n      topologyId,\n      previousDescription,\n      newDescription\n    });\n  }\n\n}\n/**\r\n * Published when topology is initialized.\r\n *\r\n * @param {Object} topologyId A unique identifier for the topology\r\n */\n\n\nclass TopologyOpeningEvent {\n  constructor(topologyId) {\n    Object.assign(this, {\n      topologyId\n    });\n  }\n\n}\n/**\r\n * Published when topology is closed.\r\n *\r\n * @param {Object} topologyId A unique identifier for the topology\r\n */\n\n\nclass TopologyClosedEvent {\n  constructor(topologyId) {\n    Object.assign(this, {\n      topologyId\n    });\n  }\n\n}\n/**\r\n * Fired when the server monitor’s ismaster command is started - immediately before\r\n * the ismaster command is serialized into raw BSON and written to the socket.\r\n *\r\n * @property {Object} connectionId The connection id for the command\r\n */\n\n\nclass ServerHeartbeatStartedEvent {\n  constructor(connectionId) {\n    Object.assign(this, {\n      connectionId\n    });\n  }\n\n}\n/**\r\n * Fired when the server monitor’s ismaster succeeds.\r\n *\r\n * @param {Number} duration The execution time of the event in ms\r\n * @param {Object} reply The command reply\r\n * @param {Object} connectionId The connection id for the command\r\n */\n\n\nclass ServerHeartbeatSucceededEvent {\n  constructor(duration, reply, connectionId) {\n    Object.assign(this, {\n      duration,\n      reply,\n      connectionId\n    });\n  }\n\n}\n/**\r\n * Fired when the server monitor’s ismaster fails, either with an “ok: 0” or a socket exception.\r\n *\r\n * @param {Number} duration The execution time of the event in ms\r\n * @param {MongoError|Object} failure The command failure\r\n * @param {Object} connectionId The connection id for the command\r\n */\n\n\nclass ServerHeartbeatFailedEvent {\n  constructor(duration, failure, connectionId) {\n    Object.assign(this, {\n      duration,\n      failure,\n      connectionId\n    });\n  }\n\n}\n/**\r\n * Performs a server check as described by the SDAM spec.\r\n *\r\n * NOTE: This method automatically reschedules itself, so that there is always an active\r\n * monitoring process\r\n *\r\n * @param {Server} server The server to monitor\r\n */\n\n\nfunction monitorServer(server, options) {\n  options = options || {};\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n\n  if (options.initial === true) {\n    server.s.monitorId = setTimeout(() => monitorServer(server), heartbeatFrequencyMS);\n    return;\n  } // executes a single check of a server\n\n\n  const checkServer = callback => {\n    let start = process.hrtime(); // emit a signal indicating we have started the heartbeat\n\n    server.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(server.name)); // NOTE: legacy monitoring event\n\n    process.nextTick(() => server.emit('monitoring', server));\n    server.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true,\n      socketTimeout: server.s.options.connectionTimeout || 2000\n    }, (err, result) => {\n      let duration = calculateDurationInMs(start);\n\n      if (err) {\n        server.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(duration, err, server.name));\n        return callback(err, null);\n      }\n\n      const isMaster = result.result;\n      server.emit('serverHeartbeatSucceded', new ServerHeartbeatSucceededEvent(duration, isMaster, server.name));\n      return callback(null, isMaster);\n    });\n  };\n\n  const successHandler = isMaster => {\n    server.s.monitoring = false; // emit an event indicating that our description has changed\n\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, isMaster)); // schedule the next monitoring process\n\n    server.s.monitorId = setTimeout(() => monitorServer(server), heartbeatFrequencyMS);\n  }; // run the actual monitoring loop\n\n\n  server.s.monitoring = true;\n  checkServer((err, isMaster) => {\n    if (!err) {\n      successHandler(isMaster);\n      return;\n    } // According to the SDAM specification's \"Network error during server check\" section, if\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\n    // change its type to `Unknown` only after retrying once.\n\n\n    server.s.pool.reset(() => {\n      // otherwise re-attempt monitoring once\n      checkServer((error, isMaster) => {\n        if (error) {\n          server.s.monitoring = false; // we revert to an `Unknown` by emitting a default description with no isMaster\n\n          server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n            error\n          })); // we do not reschedule monitoring in this case\n\n          return;\n        }\n\n        successHandler(isMaster);\n      });\n    });\n  });\n}\n\nmodule.exports = {\n  ServerDescriptionChangedEvent,\n  ServerOpeningEvent,\n  ServerClosedEvent,\n  TopologyDescriptionChangedEvent,\n  TopologyOpeningEvent,\n  TopologyClosedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent,\n  ServerHeartbeatFailedEvent,\n  monitorServer\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/sdam/monitoring.js"],"names":["ServerDescription","require","calculateDurationInMs","ServerDescriptionChangedEvent","constructor","topologyId","address","previousDescription","newDescription","Object","assign","ServerOpeningEvent","ServerClosedEvent","TopologyDescriptionChangedEvent","TopologyOpeningEvent","TopologyClosedEvent","ServerHeartbeatStartedEvent","connectionId","ServerHeartbeatSucceededEvent","duration","reply","ServerHeartbeatFailedEvent","failure","monitorServer","server","options","heartbeatFrequencyMS","initial","s","monitorId","setTimeout","checkServer","callback","start","process","hrtime","emit","name","nextTick","command","ismaster","monitoring","socketTimeout","connectionTimeout","err","result","isMaster","successHandler","description","pool","reset","error","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst ServerDescription = require('./server_description').ServerDescription;\r\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\r\n\r\n/**\r\n * Published when server description changes, but does NOT include changes to the RTT.\r\n *\r\n * @property {Object} topologyId A unique identifier for the topology\r\n * @property {ServerAddress} address The address (host/port pair) of the server\r\n * @property {ServerDescription} previousDescription The previous server description\r\n * @property {ServerDescription} newDescription The new server description\r\n */\r\nclass ServerDescriptionChangedEvent {\r\n  constructor(topologyId, address, previousDescription, newDescription) {\r\n    Object.assign(this, { topologyId, address, previousDescription, newDescription });\r\n  }\r\n}\r\n\r\n/**\r\n * Published when server is initialized.\r\n *\r\n * @property {Object} topologyId A unique identifier for the topology\r\n * @property {ServerAddress} address The address (host/port pair) of the server\r\n */\r\nclass ServerOpeningEvent {\r\n  constructor(topologyId, address) {\r\n    Object.assign(this, { topologyId, address });\r\n  }\r\n}\r\n\r\n/**\r\n * Published when server is closed.\r\n *\r\n * @property {ServerAddress} address The address (host/port pair) of the server\r\n * @property {Object} topologyId A unique identifier for the topology\r\n */\r\nclass ServerClosedEvent {\r\n  constructor(topologyId, address) {\r\n    Object.assign(this, { topologyId, address });\r\n  }\r\n}\r\n\r\n/**\r\n * Published when topology description changes.\r\n *\r\n * @property {Object} topologyId\r\n * @property {TopologyDescription} previousDescription The old topology description\r\n * @property {TopologyDescription} newDescription The new topology description\r\n */\r\nclass TopologyDescriptionChangedEvent {\r\n  constructor(topologyId, previousDescription, newDescription) {\r\n    Object.assign(this, { topologyId, previousDescription, newDescription });\r\n  }\r\n}\r\n\r\n/**\r\n * Published when topology is initialized.\r\n *\r\n * @param {Object} topologyId A unique identifier for the topology\r\n */\r\nclass TopologyOpeningEvent {\r\n  constructor(topologyId) {\r\n    Object.assign(this, { topologyId });\r\n  }\r\n}\r\n\r\n/**\r\n * Published when topology is closed.\r\n *\r\n * @param {Object} topologyId A unique identifier for the topology\r\n */\r\nclass TopologyClosedEvent {\r\n  constructor(topologyId) {\r\n    Object.assign(this, { topologyId });\r\n  }\r\n}\r\n\r\n/**\r\n * Fired when the server monitor’s ismaster command is started - immediately before\r\n * the ismaster command is serialized into raw BSON and written to the socket.\r\n *\r\n * @property {Object} connectionId The connection id for the command\r\n */\r\nclass ServerHeartbeatStartedEvent {\r\n  constructor(connectionId) {\r\n    Object.assign(this, { connectionId });\r\n  }\r\n}\r\n\r\n/**\r\n * Fired when the server monitor’s ismaster succeeds.\r\n *\r\n * @param {Number} duration The execution time of the event in ms\r\n * @param {Object} reply The command reply\r\n * @param {Object} connectionId The connection id for the command\r\n */\r\nclass ServerHeartbeatSucceededEvent {\r\n  constructor(duration, reply, connectionId) {\r\n    Object.assign(this, { duration, reply, connectionId });\r\n  }\r\n}\r\n\r\n/**\r\n * Fired when the server monitor’s ismaster fails, either with an “ok: 0” or a socket exception.\r\n *\r\n * @param {Number} duration The execution time of the event in ms\r\n * @param {MongoError|Object} failure The command failure\r\n * @param {Object} connectionId The connection id for the command\r\n */\r\nclass ServerHeartbeatFailedEvent {\r\n  constructor(duration, failure, connectionId) {\r\n    Object.assign(this, { duration, failure, connectionId });\r\n  }\r\n}\r\n\r\n/**\r\n * Performs a server check as described by the SDAM spec.\r\n *\r\n * NOTE: This method automatically reschedules itself, so that there is always an active\r\n * monitoring process\r\n *\r\n * @param {Server} server The server to monitor\r\n */\r\nfunction monitorServer(server, options) {\r\n  options = options || {};\r\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\r\n\r\n  if (options.initial === true) {\r\n    server.s.monitorId = setTimeout(() => monitorServer(server), heartbeatFrequencyMS);\r\n    return;\r\n  }\r\n\r\n  // executes a single check of a server\r\n  const checkServer = callback => {\r\n    let start = process.hrtime();\r\n\r\n    // emit a signal indicating we have started the heartbeat\r\n    server.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(server.name));\r\n\r\n    // NOTE: legacy monitoring event\r\n    process.nextTick(() => server.emit('monitoring', server));\r\n\r\n    server.command(\r\n      'admin.$cmd',\r\n      { ismaster: true },\r\n      {\r\n        monitoring: true,\r\n        socketTimeout: server.s.options.connectionTimeout || 2000\r\n      },\r\n      (err, result) => {\r\n        let duration = calculateDurationInMs(start);\r\n\r\n        if (err) {\r\n          server.emit(\r\n            'serverHeartbeatFailed',\r\n            new ServerHeartbeatFailedEvent(duration, err, server.name)\r\n          );\r\n\r\n          return callback(err, null);\r\n        }\r\n\r\n        const isMaster = result.result;\r\n        server.emit(\r\n          'serverHeartbeatSucceded',\r\n          new ServerHeartbeatSucceededEvent(duration, isMaster, server.name)\r\n        );\r\n\r\n        return callback(null, isMaster);\r\n      }\r\n    );\r\n  };\r\n\r\n  const successHandler = isMaster => {\r\n    server.s.monitoring = false;\r\n\r\n    // emit an event indicating that our description has changed\r\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, isMaster));\r\n\r\n    // schedule the next monitoring process\r\n    server.s.monitorId = setTimeout(() => monitorServer(server), heartbeatFrequencyMS);\r\n  };\r\n\r\n  // run the actual monitoring loop\r\n  server.s.monitoring = true;\r\n  checkServer((err, isMaster) => {\r\n    if (!err) {\r\n      successHandler(isMaster);\r\n      return;\r\n    }\r\n\r\n    // According to the SDAM specification's \"Network error during server check\" section, if\r\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\r\n    // change its type to `Unknown` only after retrying once.\r\n    server.s.pool.reset(() => {\r\n      // otherwise re-attempt monitoring once\r\n      checkServer((error, isMaster) => {\r\n        if (error) {\r\n          server.s.monitoring = false;\r\n\r\n          // we revert to an `Unknown` by emitting a default description with no isMaster\r\n          server.emit(\r\n            'descriptionReceived',\r\n            new ServerDescription(server.description.address, null, { error })\r\n          );\r\n\r\n          // we do not reschedule monitoring in this case\r\n          return;\r\n        }\r\n\r\n        successHandler(isMaster);\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  ServerDescriptionChangedEvent,\r\n  ServerOpeningEvent,\r\n  ServerClosedEvent,\r\n  TopologyDescriptionChangedEvent,\r\n  TopologyOpeningEvent,\r\n  TopologyClosedEvent,\r\n  ServerHeartbeatStartedEvent,\r\n  ServerHeartbeatSucceededEvent,\r\n  ServerHeartbeatFailedEvent,\r\n  monitorServer\r\n};\r\n"]},"metadata":{},"sourceType":"script"}