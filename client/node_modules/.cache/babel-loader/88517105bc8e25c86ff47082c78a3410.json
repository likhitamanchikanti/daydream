{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../error').MongoError;\n/**\r\n * Creates a new AuthProvider, which dictates how to authenticate for a given\r\n * mechanism.\r\n * @class\r\n */\n\n\nclass AuthProvider {\n  constructor(bson) {\n    this.bson = bson;\n    this.authStore = [];\n  }\n  /**\r\n   * Authenticate\r\n   * @method\r\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\r\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\r\n   * @param {MongoCredentials} credentials Authentication credentials\r\n   * @param {authResultCallback} callback The callback to return the result from the authentication\r\n   */\n\n\n  auth(sendAuthCommand, connections, credentials, callback) {\n    // Total connections\n    let count = connections.length;\n\n    if (count === 0) {\n      callback(null, null);\n      return;\n    } // Valid connections\n\n\n    let numberOfValidConnections = 0;\n    let errorObject = null;\n\n    const execute = connection => {\n      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {\n        // Adjust count\n        count = count - 1; // If we have an error\n\n        if (err) {\n          errorObject = new MongoError(err);\n        } else if (r && (r.$err || r.errmsg)) {\n          errorObject = new MongoError(r);\n        } else {\n          numberOfValidConnections = numberOfValidConnections + 1;\n        } // Still authenticating against other connections.\n\n\n        if (count !== 0) {\n          return;\n        } // We have authenticated all connections\n\n\n        if (numberOfValidConnections > 0) {\n          // Store the auth details\n          this.addCredentials(credentials); // Return correct authentication\n\n          callback(null, true);\n        } else {\n          if (errorObject == null) {\n            errorObject = new MongoError(`failed to authenticate using ${credentials.mechanism}`);\n          }\n\n          callback(errorObject, false);\n        }\n      });\n    };\n\n    const executeInNextTick = _connection => process.nextTick(() => execute(_connection)); // For each connection we need to authenticate\n\n\n    while (connections.length > 0) {\n      executeInNextTick(connections.shift());\n    }\n  }\n  /**\r\n   * Implementation of a single connection authenticating. Is meant to be overridden.\r\n   * Will error if called directly\r\n   * @ignore\r\n   */\n\n\n  _authenticateSingleConnection()\n  /*sendAuthCommand, connection, credentials, callback*/\n  {\n    throw new Error('_authenticateSingleConnection must be overridden');\n  }\n  /**\r\n   * Adds credentials to store only if it does not exist\r\n   * @param {MongoCredentials} credentials credentials to add to store\r\n   */\n\n\n  addCredentials(credentials) {\n    const found = this.authStore.some(cred => cred.equals(credentials));\n\n    if (!found) {\n      this.authStore.push(credentials);\n    }\n  }\n  /**\r\n   * Re authenticate pool\r\n   * @method\r\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\r\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\r\n   * @param {authResultCallback} callback The callback to return the result from the authentication\r\n   */\n\n\n  reauthenticate(sendAuthCommand, connections, callback) {\n    const authStore = this.authStore.slice(0);\n    let count = authStore.length;\n\n    if (count === 0) {\n      return callback(null, null);\n    }\n\n    for (let i = 0; i < authStore.length; i++) {\n      this.auth(sendAuthCommand, connections, authStore[i], function (err) {\n        count = count - 1;\n\n        if (count === 0) {\n          callback(err, null);\n        }\n      });\n    }\n  }\n  /**\r\n   * Remove credentials that have been previously stored in the auth provider\r\n   * @method\r\n   * @param {string} source Name of database we are removing authStore details about\r\n   * @return {object}\r\n   */\n\n\n  logout(source) {\n    this.authStore = this.authStore.filter(credentials => credentials.source !== source);\n  }\n\n}\n/**\r\n * A function that writes authentication commands to a specific connection\r\n * @callback SendAuthCommand\r\n * @param {Connection} connection The connection to write to\r\n * @param {Command} command A command with a toBin method that can be written to a connection\r\n * @param {AuthWriteCallback} callback Callback called when command response is received\r\n */\n\n/**\r\n * A callback for a specific auth command\r\n * @callback AuthWriteCallback\r\n * @param {Error} err If command failed, an error from the server\r\n * @param {object} r The response from the server\r\n */\n\n/**\r\n * This is a result from an authentication strategy\r\n *\r\n * @callback authResultCallback\r\n * @param {error} error An error object. Set to null if no error present\r\n * @param {boolean} result The result of the authentication process\r\n */\n\n\nmodule.exports = {\n  AuthProvider\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/auth/auth_provider.js"],"names":["MongoError","require","AuthProvider","constructor","bson","authStore","auth","sendAuthCommand","connections","credentials","callback","count","length","numberOfValidConnections","errorObject","execute","connection","_authenticateSingleConnection","err","r","$err","errmsg","addCredentials","mechanism","executeInNextTick","_connection","process","nextTick","shift","Error","found","some","cred","equals","push","reauthenticate","slice","i","logout","source","filter","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst MongoError = require('../error').MongoError;\r\n\r\n/**\r\n * Creates a new AuthProvider, which dictates how to authenticate for a given\r\n * mechanism.\r\n * @class\r\n */\r\nclass AuthProvider {\r\n  constructor(bson) {\r\n    this.bson = bson;\r\n    this.authStore = [];\r\n  }\r\n\r\n  /**\r\n   * Authenticate\r\n   * @method\r\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\r\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\r\n   * @param {MongoCredentials} credentials Authentication credentials\r\n   * @param {authResultCallback} callback The callback to return the result from the authentication\r\n   */\r\n  auth(sendAuthCommand, connections, credentials, callback) {\r\n    // Total connections\r\n    let count = connections.length;\r\n\r\n    if (count === 0) {\r\n      callback(null, null);\r\n      return;\r\n    }\r\n\r\n    // Valid connections\r\n    let numberOfValidConnections = 0;\r\n    let errorObject = null;\r\n\r\n    const execute = connection => {\r\n      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {\r\n        // Adjust count\r\n        count = count - 1;\r\n\r\n        // If we have an error\r\n        if (err) {\r\n          errorObject = new MongoError(err);\r\n        } else if (r && (r.$err || r.errmsg)) {\r\n          errorObject = new MongoError(r);\r\n        } else {\r\n          numberOfValidConnections = numberOfValidConnections + 1;\r\n        }\r\n\r\n        // Still authenticating against other connections.\r\n        if (count !== 0) {\r\n          return;\r\n        }\r\n\r\n        // We have authenticated all connections\r\n        if (numberOfValidConnections > 0) {\r\n          // Store the auth details\r\n          this.addCredentials(credentials);\r\n          // Return correct authentication\r\n          callback(null, true);\r\n        } else {\r\n          if (errorObject == null) {\r\n            errorObject = new MongoError(`failed to authenticate using ${credentials.mechanism}`);\r\n          }\r\n          callback(errorObject, false);\r\n        }\r\n      });\r\n    };\r\n\r\n    const executeInNextTick = _connection => process.nextTick(() => execute(_connection));\r\n\r\n    // For each connection we need to authenticate\r\n    while (connections.length > 0) {\r\n      executeInNextTick(connections.shift());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implementation of a single connection authenticating. Is meant to be overridden.\r\n   * Will error if called directly\r\n   * @ignore\r\n   */\r\n  _authenticateSingleConnection(/*sendAuthCommand, connection, credentials, callback*/) {\r\n    throw new Error('_authenticateSingleConnection must be overridden');\r\n  }\r\n\r\n  /**\r\n   * Adds credentials to store only if it does not exist\r\n   * @param {MongoCredentials} credentials credentials to add to store\r\n   */\r\n  addCredentials(credentials) {\r\n    const found = this.authStore.some(cred => cred.equals(credentials));\r\n\r\n    if (!found) {\r\n      this.authStore.push(credentials);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Re authenticate pool\r\n   * @method\r\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\r\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\r\n   * @param {authResultCallback} callback The callback to return the result from the authentication\r\n   */\r\n  reauthenticate(sendAuthCommand, connections, callback) {\r\n    const authStore = this.authStore.slice(0);\r\n    let count = authStore.length;\r\n    if (count === 0) {\r\n      return callback(null, null);\r\n    }\r\n\r\n    for (let i = 0; i < authStore.length; i++) {\r\n      this.auth(sendAuthCommand, connections, authStore[i], function(err) {\r\n        count = count - 1;\r\n        if (count === 0) {\r\n          callback(err, null);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove credentials that have been previously stored in the auth provider\r\n   * @method\r\n   * @param {string} source Name of database we are removing authStore details about\r\n   * @return {object}\r\n   */\r\n  logout(source) {\r\n    this.authStore = this.authStore.filter(credentials => credentials.source !== source);\r\n  }\r\n}\r\n\r\n/**\r\n * A function that writes authentication commands to a specific connection\r\n * @callback SendAuthCommand\r\n * @param {Connection} connection The connection to write to\r\n * @param {Command} command A command with a toBin method that can be written to a connection\r\n * @param {AuthWriteCallback} callback Callback called when command response is received\r\n */\r\n\r\n/**\r\n * A callback for a specific auth command\r\n * @callback AuthWriteCallback\r\n * @param {Error} err If command failed, an error from the server\r\n * @param {object} r The response from the server\r\n */\r\n\r\n/**\r\n * This is a result from an authentication strategy\r\n *\r\n * @callback authResultCallback\r\n * @param {error} error An error object. Set to null if no error present\r\n * @param {boolean} result The result of the authentication process\r\n */\r\n\r\nmodule.exports = { AuthProvider };\r\n"]},"metadata":{},"sourceType":"script"}