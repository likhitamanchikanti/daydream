{"ast":null,"code":"'use strict';\n\nconst os = require('os');\n\nconst f = require('util').format;\n\nconst ReadPreference = require('./read_preference');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst TopologyType = require('../sdam/topology_description').TopologyType;\n\nconst MongoError = require('../error').MongoError;\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n/**\r\n * Emit event if it exists\r\n * @method\r\n */\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n} // Get package.json variable\n\n\nvar driverVersion = require('../../../package.json').version;\n\nvar nodejsversion = f('Node.js %s, %s', process.version, os.endianness());\nvar type = os.type();\nvar name = process.platform;\nvar architecture = process.arch;\nvar release = os.release();\n\nfunction createClientInfo(options) {\n  // Build default client information\n  var clientInfo = options.clientInfo ? clone(options.clientInfo) : {\n    driver: {\n      name: 'nodejs-core',\n      version: driverVersion\n    },\n    os: {\n      type: type,\n      name: name,\n      architecture: architecture,\n      version: release\n    }\n  }; // Is platform specified\n\n  if (clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') === -1) {\n    clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);\n  } else if (!clientInfo.platform) {\n    clientInfo.platform = nodejsversion;\n  } // Do we have an application specific string\n\n\n  if (options.appname) {\n    // Cut at 128 bytes\n    var buffer = Buffer.from(options.appname); // Return the truncated appname\n\n    var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname; // Add to the clientInfo\n\n    clientInfo.application = {\n      name: appname\n    };\n  }\n\n  return clientInfo;\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  } // Check that all supplied compressors are valid\n\n\n  options.compression.compressors.forEach(function (compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function (self) {\n  return function (callback) {\n    if (self.s.state === 'destroyed') return; // Record response time\n\n    var start = new Date().getTime(); // emitSDAMEvent\n\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    }); // Attempt to execute ismaster command\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self); // Calculate latencyMS\n\n        var latencyMS = new Date().getTime() - start; // Server heart beat event\n\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        }); // Did the server change\n\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        } // Updat ismaster view\n\n\n        self.s.ismaster = r.result; // Set server response time\n\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      } // Peforming an ismaster monitoring callback operation\n\n\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      } // Perform another sweep\n\n\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    if (timer && timer._called) return false;\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  }; // Previous entry\n\n  if (!previous) {\n    previous = {\n      servers: []\n    };\n  } // Check if we have any previous servers missing in the current ones\n\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  } // Check if there are any severs that don't exist\n\n\n  for (j = 0; j < current.servers.length; j++) {\n    found = false; // Go over all the previous servers\n\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    } // Add the server to the diff\n\n\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  } // Got through all the servers\n\n\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i]; // Go through all current servers\n\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j]; // Matching server\n\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  } // Return difference\n\n\n  return diff;\n}\n/**\r\n * Shared function to determine clusterTime for a given topology\r\n *\r\n * @param {*} topology\r\n * @param {*} clusterTime\r\n */\n\n\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n} // NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\n\n\nconst SessionMixins = {\n  endSessions: function (sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    } // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n\n\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n/**\r\n * Determines whether the provided topology supports retryable writes\r\n *\r\n * @param {Mongos|Replset} topology\r\n */\n\nconst isRetryableWritesSupported = function (topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  } // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n\n\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n}\n\nmodule.exports.SessionMixins = SessionMixins;\nmodule.exports.resolveClusterTime = resolveClusterTime;\nmodule.exports.inquireServerState = inquireServerState;\nmodule.exports.getTopologyType = getTopologyType;\nmodule.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;\nmodule.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;\nmodule.exports.cloneOptions = cloneOptions;\nmodule.exports.createClientInfo = createClientInfo;\nmodule.exports.createCompressionInfo = createCompressionInfo;\nmodule.exports.clone = clone;\nmodule.exports.diff = diff;\nmodule.exports.Interval = Interval;\nmodule.exports.Timeout = Timeout;\nmodule.exports.isRetryableWritesSupported = isRetryableWritesSupported;\nmodule.exports.getMMAPError = getMMAPError;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/topologies/shared.js"],"names":["os","require","f","format","ReadPreference","Buffer","TopologyType","MongoError","MMAPv1_RETRY_WRITES_ERROR_CODE","emitSDAMEvent","self","event","description","listeners","length","emit","driverVersion","version","nodejsversion","process","endianness","type","name","platform","architecture","arch","release","createClientInfo","options","clientInfo","clone","driver","indexOf","appname","buffer","from","slice","toString","application","createCompressionInfo","compression","compressors","forEach","compressor","Error","object","JSON","parse","stringify","getPreviousDescription","s","serverDescription","address","arbiters","hosts","passives","emitServerDescriptionChanged","topologyId","id","previousDescription","newDescription","getPreviousTopologyDescription","topologyDescription","topologyType","servers","emitTopologyDescriptionChanged","changedIsMaster","currentIsmaster","ismaster","currentType","getTopologyType","newType","msg","secondary","arbiterOnly","inquireServerState","callback","state","start","Date","getTime","connectionId","command","monitoring","err","r","latencyMS","durationMS","reply","result","inTopology","isMasterLatencyMS","failure","inquireServerStateTimeout","setTimeout","haInterval","cloneOptions","opts","Interval","fn","time","timer","isRunning","setInterval","stop","clearInterval","Timeout","clearTimeout","_called","diff","previous","current","i","found","j","toLowerCase","push","to","prevServer","currServer","resolveClusterTime","topology","$clusterTime","clusterTime","greaterThan","SessionMixins","endSessions","sessions","Array","isArray","readPreference","primaryPreferred","Sharded","ReplicaSetWithPrimary","Single","RETRYABLE_WIRE_VERSION","isRetryableWritesSupported","maxWireVersion","lastIsMaster","logicalSessionTimeoutMinutes","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","getMMAPError","code","errmsg","includes","newErr","message","originalError","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,CAAC,GAAGD,OAAO,CAAC,MAAD,CAAP,CAAgBE,MAA1B;;AACA,MAAMC,cAAc,GAAGH,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,aAAD,CAAP,CAAuBI,MAAtC;;AACA,MAAMC,YAAY,GAAGL,OAAO,CAAC,8BAAD,CAAP,CAAwCK,YAA7D;;AACA,MAAMC,UAAU,GAAGN,OAAO,CAAC,UAAD,CAAP,CAAoBM,UAAvC;;AAEA,MAAMC,8BAA8B,GAAG,EAAvC;AAEA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAoCC,WAApC,EAAiD;AAC/C,MAAIF,IAAI,CAACG,SAAL,CAAeF,KAAf,EAAsBG,MAAtB,GAA+B,CAAnC,EAAsC;AACpCJ,IAAAA,IAAI,CAACK,IAAL,CAAUJ,KAAV,EAAiBC,WAAjB;AACD;AACF,C,CAED;;;AACA,IAAII,aAAa,GAAGf,OAAO,CAAC,uBAAD,CAAP,CAAiCgB,OAArD;;AACA,IAAIC,aAAa,GAAGhB,CAAC,CAAC,gBAAD,EAAmBiB,OAAO,CAACF,OAA3B,EAAoCjB,EAAE,CAACoB,UAAH,EAApC,CAArB;AACA,IAAIC,IAAI,GAAGrB,EAAE,CAACqB,IAAH,EAAX;AACA,IAAIC,IAAI,GAAGH,OAAO,CAACI,QAAnB;AACA,IAAIC,YAAY,GAAGL,OAAO,CAACM,IAA3B;AACA,IAAIC,OAAO,GAAG1B,EAAE,CAAC0B,OAAH,EAAd;;AAEA,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;AACjC;AACA,MAAIC,UAAU,GAAGD,OAAO,CAACC,UAAR,GACbC,KAAK,CAACF,OAAO,CAACC,UAAT,CADQ,GAEb;AACEE,IAAAA,MAAM,EAAE;AACNT,MAAAA,IAAI,EAAE,aADA;AAENL,MAAAA,OAAO,EAAED;AAFH,KADV;AAKEhB,IAAAA,EAAE,EAAE;AACFqB,MAAAA,IAAI,EAAEA,IADJ;AAEFC,MAAAA,IAAI,EAAEA,IAFJ;AAGFE,MAAAA,YAAY,EAAEA,YAHZ;AAIFP,MAAAA,OAAO,EAAES;AAJP;AALN,GAFJ,CAFiC,CAiBjC;;AACA,MAAIG,UAAU,CAACN,QAAX,IAAuBM,UAAU,CAACN,QAAX,CAAoBS,OAApB,CAA4B,cAA5B,MAAgD,CAAC,CAA5E,EAA+E;AAC7EH,IAAAA,UAAU,CAACN,QAAX,GAAsBrB,CAAC,CAAC,sBAAD,EAAyB2B,UAAU,CAACN,QAApC,EAA8CP,aAA9C,CAAvB;AACD,GAFD,MAEO,IAAI,CAACa,UAAU,CAACN,QAAhB,EAA0B;AAC/BM,IAAAA,UAAU,CAACN,QAAX,GAAsBL,aAAtB;AACD,GAtBgC,CAwBjC;;;AACA,MAAIU,OAAO,CAACK,OAAZ,EAAqB;AACnB;AACA,QAAIC,MAAM,GAAG7B,MAAM,CAAC8B,IAAP,CAAYP,OAAO,CAACK,OAApB,CAAb,CAFmB,CAGnB;;AACA,QAAIA,OAAO,GAAGC,MAAM,CAACpB,MAAP,GAAgB,GAAhB,GAAsBoB,MAAM,CAACE,KAAP,CAAa,CAAb,EAAgB,GAAhB,EAAqBC,QAArB,CAA8B,MAA9B,CAAtB,GAA8DT,OAAO,CAACK,OAApF,CAJmB,CAKnB;;AACAJ,IAAAA,UAAU,CAACS,WAAX,GAAyB;AAAEhB,MAAAA,IAAI,EAAEW;AAAR,KAAzB;AACD;;AAED,SAAOJ,UAAP;AACD;;AAED,SAASU,qBAAT,CAA+BX,OAA/B,EAAwC;AACtC,MAAI,CAACA,OAAO,CAACY,WAAT,IAAwB,CAACZ,OAAO,CAACY,WAAR,CAAoBC,WAAjD,EAA8D;AAC5D,WAAO,EAAP;AACD,GAHqC,CAKtC;;;AACAb,EAAAA,OAAO,CAACY,WAAR,CAAoBC,WAApB,CAAgCC,OAAhC,CAAwC,UAASC,UAAT,EAAqB;AAC3D,QAAIA,UAAU,KAAK,QAAf,IAA2BA,UAAU,KAAK,MAA9C,EAAsD;AACpD,YAAM,IAAIC,KAAJ,CAAU,oDAAV,CAAN;AACD;AACF,GAJD;AAMA,SAAOhB,OAAO,CAACY,WAAR,CAAoBC,WAA3B;AACD;;AAED,SAASX,KAAT,CAAee,MAAf,EAAuB;AACrB,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeH,MAAf,CAAX,CAAP;AACD;;AAED,IAAII,sBAAsB,GAAG,UAASvC,IAAT,EAAe;AAC1C,MAAI,CAACA,IAAI,CAACwC,CAAL,CAAOC,iBAAZ,EAA+B;AAC7BzC,IAAAA,IAAI,CAACwC,CAAL,CAAOC,iBAAP,GAA2B;AACzBC,MAAAA,OAAO,EAAE1C,IAAI,CAACY,IADW;AAEzB+B,MAAAA,QAAQ,EAAE,EAFe;AAGzBC,MAAAA,KAAK,EAAE,EAHkB;AAIzBC,MAAAA,QAAQ,EAAE,EAJe;AAKzBlC,MAAAA,IAAI,EAAE;AALmB,KAA3B;AAOD;;AAED,SAAOX,IAAI,CAACwC,CAAL,CAAOC,iBAAd;AACD,CAZD;;AAcA,IAAIK,4BAA4B,GAAG,UAAS9C,IAAT,EAAeE,WAAf,EAA4B;AAC7D,MAAIF,IAAI,CAACG,SAAL,CAAe,0BAAf,EAA2CC,MAA3C,GAAoD,CAAxD,EAA2D;AACzD;AACAJ,IAAAA,IAAI,CAACK,IAAL,CAAU,0BAAV,EAAsC;AACpC0C,MAAAA,UAAU,EAAE/C,IAAI,CAACwC,CAAL,CAAOO,UAAP,KAAsB,CAAC,CAAvB,GAA2B/C,IAAI,CAACwC,CAAL,CAAOO,UAAlC,GAA+C/C,IAAI,CAACgD,EAD5B;AAEpCN,MAAAA,OAAO,EAAE1C,IAAI,CAACY,IAFsB;AAGpCqC,MAAAA,mBAAmB,EAAEV,sBAAsB,CAACvC,IAAD,CAHP;AAIpCkD,MAAAA,cAAc,EAAEhD;AAJoB,KAAtC;AAOAF,IAAAA,IAAI,CAACwC,CAAL,CAAOC,iBAAP,GAA2BvC,WAA3B;AACD;AACF,CAZD;;AAcA,IAAIiD,8BAA8B,GAAG,UAASnD,IAAT,EAAe;AAClD,MAAI,CAACA,IAAI,CAACwC,CAAL,CAAOY,mBAAZ,EAAiC;AAC/BpD,IAAAA,IAAI,CAACwC,CAAL,CAAOY,mBAAP,GAA6B;AAC3BC,MAAAA,YAAY,EAAE,SADa;AAE3BC,MAAAA,OAAO,EAAE,CACP;AACEZ,QAAAA,OAAO,EAAE1C,IAAI,CAACY,IADhB;AAEE+B,QAAAA,QAAQ,EAAE,EAFZ;AAGEC,QAAAA,KAAK,EAAE,EAHT;AAIEC,QAAAA,QAAQ,EAAE,EAJZ;AAKElC,QAAAA,IAAI,EAAE;AALR,OADO;AAFkB,KAA7B;AAYD;;AAED,SAAOX,IAAI,CAACwC,CAAL,CAAOY,mBAAd;AACD,CAjBD;;AAmBA,IAAIG,8BAA8B,GAAG,UAASvD,IAAT,EAAeE,WAAf,EAA4B;AAC/D,MAAIF,IAAI,CAACG,SAAL,CAAe,4BAAf,EAA6CC,MAA7C,GAAsD,CAA1D,EAA6D;AAC3D;AACAJ,IAAAA,IAAI,CAACK,IAAL,CAAU,4BAAV,EAAwC;AACtC0C,MAAAA,UAAU,EAAE/C,IAAI,CAACwC,CAAL,CAAOO,UAAP,KAAsB,CAAC,CAAvB,GAA2B/C,IAAI,CAACwC,CAAL,CAAOO,UAAlC,GAA+C/C,IAAI,CAACgD,EAD1B;AAEtCN,MAAAA,OAAO,EAAE1C,IAAI,CAACY,IAFwB;AAGtCqC,MAAAA,mBAAmB,EAAEE,8BAA8B,CAACnD,IAAD,CAHb;AAItCkD,MAAAA,cAAc,EAAEhD;AAJsB,KAAxC;AAOAF,IAAAA,IAAI,CAACwC,CAAL,CAAOC,iBAAP,GAA2BvC,WAA3B;AACD;AACF,CAZD;;AAcA,IAAIsD,eAAe,GAAG,UAASxD,IAAT,EAAeyD,eAAf,EAAgCC,QAAhC,EAA0C;AAC9D,MAAIC,WAAW,GAAGC,eAAe,CAAC5D,IAAD,EAAOyD,eAAP,CAAjC;AACA,MAAII,OAAO,GAAGD,eAAe,CAAC5D,IAAD,EAAO0D,QAAP,CAA7B;AACA,MAAIG,OAAO,KAAKF,WAAhB,EAA6B,OAAO,IAAP;AAC7B,SAAO,KAAP;AACD,CALD;;AAOA,IAAIC,eAAe,GAAG,UAAS5D,IAAT,EAAe0D,QAAf,EAAyB;AAC7C,MAAI,CAACA,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAhB;AACD;;AAED,MAAI,CAACA,QAAL,EAAe,OAAO,SAAP;AACf,MAAIA,QAAQ,CAACA,QAAT,IAAqBA,QAAQ,CAACI,GAAT,KAAiB,UAA1C,EAAsD,OAAO,QAAP;AACtD,MAAIJ,QAAQ,CAACA,QAAT,IAAqB,CAACA,QAAQ,CAACd,KAAnC,EAA0C,OAAO,YAAP;AAC1C,MAAIc,QAAQ,CAACA,QAAb,EAAuB,OAAO,WAAP;AACvB,MAAIA,QAAQ,CAACK,SAAb,EAAwB,OAAO,aAAP;AACxB,MAAIL,QAAQ,CAACM,WAAb,EAA0B,OAAO,WAAP;AAC1B,SAAO,SAAP;AACD,CAZD;;AAcA,IAAIC,kBAAkB,GAAG,UAASjE,IAAT,EAAe;AACtC,SAAO,UAASkE,QAAT,EAAmB;AACxB,QAAIlE,IAAI,CAACwC,CAAL,CAAO2B,KAAP,KAAiB,WAArB,EAAkC,OADV,CAExB;;AACA,QAAIC,KAAK,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ,CAHwB,CAKxB;;AACAvE,IAAAA,aAAa,CAACC,IAAD,EAAO,wBAAP,EAAiC;AAAEuE,MAAAA,YAAY,EAAEvE,IAAI,CAACY;AAArB,KAAjC,CAAb,CANwB,CAQxB;;AACAZ,IAAAA,IAAI,CAACwE,OAAL,CAAa,YAAb,EAA2B;AAAEd,MAAAA,QAAQ,EAAE;AAAZ,KAA3B,EAA+C;AAAEe,MAAAA,UAAU,EAAE;AAAd,KAA/C,EAAqE,UAASC,GAAT,EAAcC,CAAd,EAAiB;AACpF,UAAI,CAACD,GAAL,EAAU;AACR;AACA1E,QAAAA,IAAI,CAACK,IAAL,CAAU,UAAV,EAAsBsE,CAAtB,EAAyB3E,IAAzB,EAFQ,CAIR;;AACA,YAAI4E,SAAS,GAAG,IAAIP,IAAJ,GAAWC,OAAX,KAAuBF,KAAvC,CALQ,CAOR;;AACArE,QAAAA,aAAa,CAACC,IAAD,EAAO,0BAAP,EAAmC;AAC9C6E,UAAAA,UAAU,EAAED,SADkC;AAE9CE,UAAAA,KAAK,EAAEH,CAAC,CAACI,MAFqC;AAG9CR,UAAAA,YAAY,EAAEvE,IAAI,CAACY;AAH2B,SAAnC,CAAb,CARQ,CAcR;;AACA,YAAI4C,eAAe,CAACxD,IAAD,EAAOA,IAAI,CAACwC,CAAL,CAAOkB,QAAd,EAAwBiB,CAAC,CAACI,MAA1B,CAAnB,EAAsD;AACpD;AACAjC,UAAAA,4BAA4B,CAAC9C,IAAD,EAAO;AACjC0C,YAAAA,OAAO,EAAE1C,IAAI,CAACY,IADmB;AAEjC+B,YAAAA,QAAQ,EAAE,EAFuB;AAGjCC,YAAAA,KAAK,EAAE,EAH0B;AAIjCC,YAAAA,QAAQ,EAAE,EAJuB;AAKjClC,YAAAA,IAAI,EAAE,CAACX,IAAI,CAACwC,CAAL,CAAOwC,UAAR,GAAqB,YAArB,GAAoCpB,eAAe,CAAC5D,IAAD;AALxB,WAAP,CAA5B;AAOD,SAxBO,CA0BR;;;AACAA,QAAAA,IAAI,CAACwC,CAAL,CAAOkB,QAAP,GAAkBiB,CAAC,CAACI,MAApB,CA3BQ,CA6BR;;AACA/E,QAAAA,IAAI,CAACwC,CAAL,CAAOyC,iBAAP,GAA2BL,SAA3B;AACD,OA/BD,MA+BO;AACL7E,QAAAA,aAAa,CAACC,IAAD,EAAO,uBAAP,EAAgC;AAC3C6E,UAAAA,UAAU,EAAED,SAD+B;AAE3CM,UAAAA,OAAO,EAAER,GAFkC;AAG3CH,UAAAA,YAAY,EAAEvE,IAAI,CAACY;AAHwB,SAAhC,CAAb;AAKD,OAtCmF,CAwCpF;;;AACA,UAAI,OAAOsD,QAAP,KAAoB,UAAxB,EAAoC;AAClC,eAAOA,QAAQ,CAACQ,GAAD,EAAMC,CAAN,CAAf;AACD,OA3CmF,CA6CpF;;;AACA3E,MAAAA,IAAI,CAACwC,CAAL,CAAO2C,yBAAP,GAAmCC,UAAU,CAACnB,kBAAkB,CAACjE,IAAD,CAAnB,EAA2BA,IAAI,CAACwC,CAAL,CAAO6C,UAAlC,CAA7C;AACD,KA/CD;AAgDD,GAzDD;AA0DD,CA3DD,C,CA6DA;AACA;;;AACA,IAAIC,YAAY,GAAG,UAASpE,OAAT,EAAkB;AACnC,MAAIqE,IAAI,GAAG,EAAX;;AACA,OAAK,IAAI3E,IAAT,IAAiBM,OAAjB,EAA0B;AACxBqE,IAAAA,IAAI,CAAC3E,IAAD,CAAJ,GAAaM,OAAO,CAACN,IAAD,CAApB;AACD;;AACD,SAAO2E,IAAP;AACD,CAND;;AAQA,SAASC,QAAT,CAAkBC,EAAlB,EAAsBC,IAAtB,EAA4B;AAC1B,MAAIC,KAAK,GAAG,KAAZ;;AAEA,OAAKvB,KAAL,GAAa,YAAW;AACtB,QAAI,CAAC,KAAKwB,SAAL,EAAL,EAAuB;AACrBD,MAAAA,KAAK,GAAGE,WAAW,CAACJ,EAAD,EAAKC,IAAL,CAAnB;AACD;;AAED,WAAO,IAAP;AACD,GAND;;AAQA,OAAKI,IAAL,GAAY,YAAW;AACrBC,IAAAA,aAAa,CAACJ,KAAD,CAAb;AACAA,IAAAA,KAAK,GAAG,KAAR;AACA,WAAO,IAAP;AACD,GAJD;;AAMA,OAAKC,SAAL,GAAiB,YAAW;AAC1B,WAAOD,KAAK,KAAK,KAAjB;AACD,GAFD;AAGD;;AAED,SAASK,OAAT,CAAiBP,EAAjB,EAAqBC,IAArB,EAA2B;AACzB,MAAIC,KAAK,GAAG,KAAZ;;AAEA,OAAKvB,KAAL,GAAa,YAAW;AACtB,QAAI,CAAC,KAAKwB,SAAL,EAAL,EAAuB;AACrBD,MAAAA,KAAK,GAAGP,UAAU,CAACK,EAAD,EAAKC,IAAL,CAAlB;AACD;;AACD,WAAO,IAAP;AACD,GALD;;AAOA,OAAKI,IAAL,GAAY,YAAW;AACrBG,IAAAA,YAAY,CAACN,KAAD,CAAZ;AACAA,IAAAA,KAAK,GAAG,KAAR;AACA,WAAO,IAAP;AACD,GAJD;;AAMA,OAAKC,SAAL,GAAiB,YAAW;AAC1B,QAAID,KAAK,IAAIA,KAAK,CAACO,OAAnB,EAA4B,OAAO,KAAP;AAC5B,WAAOP,KAAK,KAAK,KAAjB;AACD,GAHD;AAID;;AAED,SAASQ,IAAT,CAAcC,QAAd,EAAwBC,OAAxB,EAAiC;AAC/B;AACA,MAAIF,IAAI,GAAG;AACT7C,IAAAA,OAAO,EAAE;AADA,GAAX,CAF+B,CAM/B;;AACA,MAAI,CAAC8C,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAG;AAAE9C,MAAAA,OAAO,EAAE;AAAX,KAAX;AACD,GAT8B,CAW/B;;;AACA,OAAK,IAAIgD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAAC9C,OAAT,CAAiBlD,MAArC,EAA6CkG,CAAC,EAA9C,EAAkD;AAChD,QAAIC,KAAK,GAAG,KAAZ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAAC/C,OAAR,CAAgBlD,MAApC,EAA4CoG,CAAC,EAA7C,EAAiD;AAC/C,UAAIH,OAAO,CAAC/C,OAAR,CAAgBkD,CAAhB,EAAmB9D,OAAnB,CAA2B+D,WAA3B,OAA6CL,QAAQ,CAAC9C,OAAT,CAAiBgD,CAAjB,EAAoB5D,OAApB,CAA4B+D,WAA5B,EAAjD,EAA4F;AAC1FF,QAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;;AAED,QAAI,CAACA,KAAL,EAAY;AACV;AACAJ,MAAAA,IAAI,CAAC7C,OAAL,CAAaoD,IAAb,CAAkB;AAChBhE,QAAAA,OAAO,EAAE0D,QAAQ,CAAC9C,OAAT,CAAiBgD,CAAjB,EAAoB5D,OADb;AAEhBjB,QAAAA,IAAI,EAAE2E,QAAQ,CAAC9C,OAAT,CAAiBgD,CAAjB,EAAoB3F,IAFV;AAGhBgG,QAAAA,EAAE,EAAE;AAHY,OAAlB;AAKD;AACF,GA9B8B,CAgC/B;;;AACA,OAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGH,OAAO,CAAC/C,OAAR,CAAgBlD,MAAhC,EAAwCoG,CAAC,EAAzC,EAA6C;AAC3CD,IAAAA,KAAK,GAAG,KAAR,CAD2C,CAG3C;;AACA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,QAAQ,CAAC9C,OAAT,CAAiBlD,MAAjC,EAAyCkG,CAAC,EAA1C,EAA8C;AAC5C,UAAIF,QAAQ,CAAC9C,OAAT,CAAiBgD,CAAjB,EAAoB5D,OAApB,CAA4B+D,WAA5B,OAA8CJ,OAAO,CAAC/C,OAAR,CAAgBkD,CAAhB,EAAmB9D,OAAnB,CAA2B+D,WAA3B,EAAlD,EAA4F;AAC1FF,QAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF,KAT0C,CAW3C;;;AACA,QAAI,CAACA,KAAL,EAAY;AACVJ,MAAAA,IAAI,CAAC7C,OAAL,CAAaoD,IAAb,CAAkB;AAChBhE,QAAAA,OAAO,EAAE2D,OAAO,CAAC/C,OAAR,CAAgBkD,CAAhB,EAAmB9D,OADZ;AAEhBjB,QAAAA,IAAI,EAAE,SAFU;AAGhBkF,QAAAA,EAAE,EAAEN,OAAO,CAAC/C,OAAR,CAAgBkD,CAAhB,EAAmB7F;AAHP,OAAlB;AAKD;AACF,GApD8B,CAsD/B;;;AACA,OAAK2F,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,QAAQ,CAAC9C,OAAT,CAAiBlD,MAAjC,EAAyCkG,CAAC,EAA1C,EAA8C;AAC5C,QAAIM,UAAU,GAAGR,QAAQ,CAAC9C,OAAT,CAAiBgD,CAAjB,CAAjB,CAD4C,CAG5C;;AACA,SAAKE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGH,OAAO,CAAC/C,OAAR,CAAgBlD,MAAhC,EAAwCoG,CAAC,EAAzC,EAA6C;AAC3C,UAAIK,UAAU,GAAGR,OAAO,CAAC/C,OAAR,CAAgBkD,CAAhB,CAAjB,CAD2C,CAG3C;;AACA,UAAII,UAAU,CAAClE,OAAX,CAAmB+D,WAAnB,OAAqCI,UAAU,CAACnE,OAAX,CAAmB+D,WAAnB,EAAzC,EAA2E;AACzE;AACA,YAAIG,UAAU,CAACjG,IAAX,KAAoBkG,UAAU,CAAClG,IAAnC,EAAyC;AACvCwF,UAAAA,IAAI,CAAC7C,OAAL,CAAaoD,IAAb,CAAkB;AAChBhE,YAAAA,OAAO,EAAEkE,UAAU,CAAClE,OADJ;AAEhBjB,YAAAA,IAAI,EAAEmF,UAAU,CAACjG,IAFD;AAGhBgG,YAAAA,EAAE,EAAEE,UAAU,CAAClG;AAHC,WAAlB;AAKD;AACF;AACF;AACF,GA1E8B,CA4E/B;;;AACA,SAAOwF,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,kBAAT,CAA4BC,QAA5B,EAAsCC,YAAtC,EAAoD;AAClD,MAAID,QAAQ,CAACE,WAAT,IAAwB,IAA5B,EAAkC;AAChCF,IAAAA,QAAQ,CAACE,WAAT,GAAuBD,YAAvB;AACD,GAFD,MAEO;AACL,QAAIA,YAAY,CAACC,WAAb,CAAyBC,WAAzB,CAAqCH,QAAQ,CAACE,WAAT,CAAqBA,WAA1D,CAAJ,EAA4E;AAC1EF,MAAAA,QAAQ,CAACE,WAAT,GAAuBD,YAAvB;AACD;AACF;AACF,C,CAED;AACA;;;AACA,MAAMG,aAAa,GAAG;AACpBC,EAAAA,WAAW,EAAE,UAASC,QAAT,EAAmBnD,QAAnB,EAA6B;AACxC,QAAI,CAACoD,KAAK,CAACC,OAAN,CAAcF,QAAd,CAAL,EAA8B;AAC5BA,MAAAA,QAAQ,GAAG,CAACA,QAAD,CAAX;AACD,KAHuC,CAKxC;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAK7C,OAAL,CACE,YADF,EAEE;AAAE4C,MAAAA,WAAW,EAAEC;AAAf,KAFF,EAGE;AAAEG,MAAAA,cAAc,EAAE9H,cAAc,CAAC+H;AAAjC,KAHF,EAIE,MAAM;AACJ;AACA,UAAI,OAAOvD,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ;AAC7C,KAPH;AASD;AArBmB,CAAtB;;AAwBA,SAASb,YAAT,CAAsB0D,QAAtB,EAAgC;AAC9B,MAAIA,QAAQ,CAAC7G,WAAb,EAA0B;AACxB,WAAO6G,QAAQ,CAAC7G,WAAT,CAAqBS,IAA5B;AACD;;AAED,MAAIoG,QAAQ,CAACpG,IAAT,KAAkB,QAAtB,EAAgC;AAC9B,WAAOf,YAAY,CAAC8H,OAApB;AACD,GAFD,MAEO,IAAIX,QAAQ,CAACpG,IAAT,KAAkB,SAAtB,EAAiC;AACtC,WAAOf,YAAY,CAAC+H,qBAApB;AACD;;AAED,SAAO/H,YAAY,CAACgI,MAApB;AACD;;AAED,MAAMC,sBAAsB,GAAG,CAA/B;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,0BAA0B,GAAG,UAASf,QAAT,EAAmB;AACpD,QAAMgB,cAAc,GAAGhB,QAAQ,CAACiB,YAAT,GAAwBD,cAA/C;;AACA,MAAIA,cAAc,GAAGF,sBAArB,EAA6C;AAC3C,WAAO,KAAP;AACD;;AAED,MAAI,CAACd,QAAQ,CAACkB,4BAAd,EAA4C;AAC1C,WAAO,KAAP;AACD;;AAED,MAAI5E,YAAY,CAAC0D,QAAD,CAAZ,KAA2BnH,YAAY,CAACgI,MAA5C,EAAoD;AAClD,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD,CAfD;;AAiBA,MAAMM,iCAAiC,GACrC,oHADF;;AAGA,SAASC,YAAT,CAAsBzD,GAAtB,EAA2B;AACzB,MAAIA,GAAG,CAAC0D,IAAJ,KAAatI,8BAAb,IAA+C,CAAC4E,GAAG,CAAC2D,MAAJ,CAAWC,QAAX,CAAoB,qBAApB,CAApD,EAAgG;AAC9F,WAAO5D,GAAP;AACD,GAHwB,CAKzB;AACA;;;AACA,QAAM6D,MAAM,GAAG,IAAI1I,UAAJ,CAAe;AAC5B2I,IAAAA,OAAO,EAAEN,iCADmB;AAE5BG,IAAAA,MAAM,EAAEH,iCAFoB;AAG5BO,IAAAA,aAAa,EAAE/D;AAHa,GAAf,CAAf;AAKA,SAAO6D,MAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,CAAexB,aAAf,GAA+BA,aAA/B;AACAuB,MAAM,CAACC,OAAP,CAAe7B,kBAAf,GAAoCA,kBAApC;AACA4B,MAAM,CAACC,OAAP,CAAe1E,kBAAf,GAAoCA,kBAApC;AACAyE,MAAM,CAACC,OAAP,CAAe/E,eAAf,GAAiCA,eAAjC;AACA8E,MAAM,CAACC,OAAP,CAAe7F,4BAAf,GAA8CA,4BAA9C;AACA4F,MAAM,CAACC,OAAP,CAAepF,8BAAf,GAAgDA,8BAAhD;AACAmF,MAAM,CAACC,OAAP,CAAerD,YAAf,GAA8BA,YAA9B;AACAoD,MAAM,CAACC,OAAP,CAAe1H,gBAAf,GAAkCA,gBAAlC;AACAyH,MAAM,CAACC,OAAP,CAAe9G,qBAAf,GAAuCA,qBAAvC;AACA6G,MAAM,CAACC,OAAP,CAAevH,KAAf,GAAuBA,KAAvB;AACAsH,MAAM,CAACC,OAAP,CAAexC,IAAf,GAAsBA,IAAtB;AACAuC,MAAM,CAACC,OAAP,CAAenD,QAAf,GAA0BA,QAA1B;AACAkD,MAAM,CAACC,OAAP,CAAe3C,OAAf,GAAyBA,OAAzB;AACA0C,MAAM,CAACC,OAAP,CAAeb,0BAAf,GAA4CA,0BAA5C;AACAY,MAAM,CAACC,OAAP,CAAeR,YAAf,GAA8BA,YAA9B","sourcesContent":["'use strict';\r\n\r\nconst os = require('os');\r\nconst f = require('util').format;\r\nconst ReadPreference = require('./read_preference');\r\nconst Buffer = require('safe-buffer').Buffer;\r\nconst TopologyType = require('../sdam/topology_description').TopologyType;\r\nconst MongoError = require('../error').MongoError;\r\n\r\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\r\n\r\n/**\r\n * Emit event if it exists\r\n * @method\r\n */\r\nfunction emitSDAMEvent(self, event, description) {\r\n  if (self.listeners(event).length > 0) {\r\n    self.emit(event, description);\r\n  }\r\n}\r\n\r\n// Get package.json variable\r\nvar driverVersion = require('../../../package.json').version;\r\nvar nodejsversion = f('Node.js %s, %s', process.version, os.endianness());\r\nvar type = os.type();\r\nvar name = process.platform;\r\nvar architecture = process.arch;\r\nvar release = os.release();\r\n\r\nfunction createClientInfo(options) {\r\n  // Build default client information\r\n  var clientInfo = options.clientInfo\r\n    ? clone(options.clientInfo)\r\n    : {\r\n        driver: {\r\n          name: 'nodejs-core',\r\n          version: driverVersion\r\n        },\r\n        os: {\r\n          type: type,\r\n          name: name,\r\n          architecture: architecture,\r\n          version: release\r\n        }\r\n      };\r\n\r\n  // Is platform specified\r\n  if (clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') === -1) {\r\n    clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);\r\n  } else if (!clientInfo.platform) {\r\n    clientInfo.platform = nodejsversion;\r\n  }\r\n\r\n  // Do we have an application specific string\r\n  if (options.appname) {\r\n    // Cut at 128 bytes\r\n    var buffer = Buffer.from(options.appname);\r\n    // Return the truncated appname\r\n    var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname;\r\n    // Add to the clientInfo\r\n    clientInfo.application = { name: appname };\r\n  }\r\n\r\n  return clientInfo;\r\n}\r\n\r\nfunction createCompressionInfo(options) {\r\n  if (!options.compression || !options.compression.compressors) {\r\n    return [];\r\n  }\r\n\r\n  // Check that all supplied compressors are valid\r\n  options.compression.compressors.forEach(function(compressor) {\r\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\r\n      throw new Error('compressors must be at least one of snappy or zlib');\r\n    }\r\n  });\r\n\r\n  return options.compression.compressors;\r\n}\r\n\r\nfunction clone(object) {\r\n  return JSON.parse(JSON.stringify(object));\r\n}\r\n\r\nvar getPreviousDescription = function(self) {\r\n  if (!self.s.serverDescription) {\r\n    self.s.serverDescription = {\r\n      address: self.name,\r\n      arbiters: [],\r\n      hosts: [],\r\n      passives: [],\r\n      type: 'Unknown'\r\n    };\r\n  }\r\n\r\n  return self.s.serverDescription;\r\n};\r\n\r\nvar emitServerDescriptionChanged = function(self, description) {\r\n  if (self.listeners('serverDescriptionChanged').length > 0) {\r\n    // Emit the server description changed events\r\n    self.emit('serverDescriptionChanged', {\r\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\r\n      address: self.name,\r\n      previousDescription: getPreviousDescription(self),\r\n      newDescription: description\r\n    });\r\n\r\n    self.s.serverDescription = description;\r\n  }\r\n};\r\n\r\nvar getPreviousTopologyDescription = function(self) {\r\n  if (!self.s.topologyDescription) {\r\n    self.s.topologyDescription = {\r\n      topologyType: 'Unknown',\r\n      servers: [\r\n        {\r\n          address: self.name,\r\n          arbiters: [],\r\n          hosts: [],\r\n          passives: [],\r\n          type: 'Unknown'\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  return self.s.topologyDescription;\r\n};\r\n\r\nvar emitTopologyDescriptionChanged = function(self, description) {\r\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\r\n    // Emit the server description changed events\r\n    self.emit('topologyDescriptionChanged', {\r\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\r\n      address: self.name,\r\n      previousDescription: getPreviousTopologyDescription(self),\r\n      newDescription: description\r\n    });\r\n\r\n    self.s.serverDescription = description;\r\n  }\r\n};\r\n\r\nvar changedIsMaster = function(self, currentIsmaster, ismaster) {\r\n  var currentType = getTopologyType(self, currentIsmaster);\r\n  var newType = getTopologyType(self, ismaster);\r\n  if (newType !== currentType) return true;\r\n  return false;\r\n};\r\n\r\nvar getTopologyType = function(self, ismaster) {\r\n  if (!ismaster) {\r\n    ismaster = self.ismaster;\r\n  }\r\n\r\n  if (!ismaster) return 'Unknown';\r\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\r\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\r\n  if (ismaster.ismaster) return 'RSPrimary';\r\n  if (ismaster.secondary) return 'RSSecondary';\r\n  if (ismaster.arbiterOnly) return 'RSArbiter';\r\n  return 'Unknown';\r\n};\r\n\r\nvar inquireServerState = function(self) {\r\n  return function(callback) {\r\n    if (self.s.state === 'destroyed') return;\r\n    // Record response time\r\n    var start = new Date().getTime();\r\n\r\n    // emitSDAMEvent\r\n    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });\r\n\r\n    // Attempt to execute ismaster command\r\n    self.command('admin.$cmd', { ismaster: true }, { monitoring: true }, function(err, r) {\r\n      if (!err) {\r\n        // Legacy event sender\r\n        self.emit('ismaster', r, self);\r\n\r\n        // Calculate latencyMS\r\n        var latencyMS = new Date().getTime() - start;\r\n\r\n        // Server heart beat event\r\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\r\n          durationMS: latencyMS,\r\n          reply: r.result,\r\n          connectionId: self.name\r\n        });\r\n\r\n        // Did the server change\r\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\r\n          // Emit server description changed if something listening\r\n          emitServerDescriptionChanged(self, {\r\n            address: self.name,\r\n            arbiters: [],\r\n            hosts: [],\r\n            passives: [],\r\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\r\n          });\r\n        }\r\n\r\n        // Updat ismaster view\r\n        self.s.ismaster = r.result;\r\n\r\n        // Set server response time\r\n        self.s.isMasterLatencyMS = latencyMS;\r\n      } else {\r\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\r\n          durationMS: latencyMS,\r\n          failure: err,\r\n          connectionId: self.name\r\n        });\r\n      }\r\n\r\n      // Peforming an ismaster monitoring callback operation\r\n      if (typeof callback === 'function') {\r\n        return callback(err, r);\r\n      }\r\n\r\n      // Perform another sweep\r\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\r\n    });\r\n  };\r\n};\r\n\r\n//\r\n// Clone the options\r\nvar cloneOptions = function(options) {\r\n  var opts = {};\r\n  for (var name in options) {\r\n    opts[name] = options[name];\r\n  }\r\n  return opts;\r\n};\r\n\r\nfunction Interval(fn, time) {\r\n  var timer = false;\r\n\r\n  this.start = function() {\r\n    if (!this.isRunning()) {\r\n      timer = setInterval(fn, time);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  this.stop = function() {\r\n    clearInterval(timer);\r\n    timer = false;\r\n    return this;\r\n  };\r\n\r\n  this.isRunning = function() {\r\n    return timer !== false;\r\n  };\r\n}\r\n\r\nfunction Timeout(fn, time) {\r\n  var timer = false;\r\n\r\n  this.start = function() {\r\n    if (!this.isRunning()) {\r\n      timer = setTimeout(fn, time);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  this.stop = function() {\r\n    clearTimeout(timer);\r\n    timer = false;\r\n    return this;\r\n  };\r\n\r\n  this.isRunning = function() {\r\n    if (timer && timer._called) return false;\r\n    return timer !== false;\r\n  };\r\n}\r\n\r\nfunction diff(previous, current) {\r\n  // Difference document\r\n  var diff = {\r\n    servers: []\r\n  };\r\n\r\n  // Previous entry\r\n  if (!previous) {\r\n    previous = { servers: [] };\r\n  }\r\n\r\n  // Check if we have any previous servers missing in the current ones\r\n  for (var i = 0; i < previous.servers.length; i++) {\r\n    var found = false;\r\n\r\n    for (var j = 0; j < current.servers.length; j++) {\r\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!found) {\r\n      // Add to the diff\r\n      diff.servers.push({\r\n        address: previous.servers[i].address,\r\n        from: previous.servers[i].type,\r\n        to: 'Unknown'\r\n      });\r\n    }\r\n  }\r\n\r\n  // Check if there are any severs that don't exist\r\n  for (j = 0; j < current.servers.length; j++) {\r\n    found = false;\r\n\r\n    // Go over all the previous servers\r\n    for (i = 0; i < previous.servers.length; i++) {\r\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Add the server to the diff\r\n    if (!found) {\r\n      diff.servers.push({\r\n        address: current.servers[j].address,\r\n        from: 'Unknown',\r\n        to: current.servers[j].type\r\n      });\r\n    }\r\n  }\r\n\r\n  // Got through all the servers\r\n  for (i = 0; i < previous.servers.length; i++) {\r\n    var prevServer = previous.servers[i];\r\n\r\n    // Go through all current servers\r\n    for (j = 0; j < current.servers.length; j++) {\r\n      var currServer = current.servers[j];\r\n\r\n      // Matching server\r\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\r\n        // We had a change in state\r\n        if (prevServer.type !== currServer.type) {\r\n          diff.servers.push({\r\n            address: prevServer.address,\r\n            from: prevServer.type,\r\n            to: currServer.type\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return difference\r\n  return diff;\r\n}\r\n\r\n/**\r\n * Shared function to determine clusterTime for a given topology\r\n *\r\n * @param {*} topology\r\n * @param {*} clusterTime\r\n */\r\nfunction resolveClusterTime(topology, $clusterTime) {\r\n  if (topology.clusterTime == null) {\r\n    topology.clusterTime = $clusterTime;\r\n  } else {\r\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\r\n      topology.clusterTime = $clusterTime;\r\n    }\r\n  }\r\n}\r\n\r\n// NOTE: this is a temporary move until the topologies can be more formally refactored\r\n//       to share code.\r\nconst SessionMixins = {\r\n  endSessions: function(sessions, callback) {\r\n    if (!Array.isArray(sessions)) {\r\n      sessions = [sessions];\r\n    }\r\n\r\n    // TODO:\r\n    //   When connected to a sharded cluster the endSessions command\r\n    //   can be sent to any mongos. When connected to a replica set the\r\n    //   endSessions command MUST be sent to the primary if the primary\r\n    //   is available, otherwise it MUST be sent to any available secondary.\r\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\r\n    this.command(\r\n      'admin.$cmd',\r\n      { endSessions: sessions },\r\n      { readPreference: ReadPreference.primaryPreferred },\r\n      () => {\r\n        // intentionally ignored, per spec\r\n        if (typeof callback === 'function') callback();\r\n      }\r\n    );\r\n  }\r\n};\r\n\r\nfunction topologyType(topology) {\r\n  if (topology.description) {\r\n    return topology.description.type;\r\n  }\r\n\r\n  if (topology.type === 'mongos') {\r\n    return TopologyType.Sharded;\r\n  } else if (topology.type === 'replset') {\r\n    return TopologyType.ReplicaSetWithPrimary;\r\n  }\r\n\r\n  return TopologyType.Single;\r\n}\r\n\r\nconst RETRYABLE_WIRE_VERSION = 6;\r\n\r\n/**\r\n * Determines whether the provided topology supports retryable writes\r\n *\r\n * @param {Mongos|Replset} topology\r\n */\r\nconst isRetryableWritesSupported = function(topology) {\r\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\r\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\r\n    return false;\r\n  }\r\n\r\n  if (!topology.logicalSessionTimeoutMinutes) {\r\n    return false;\r\n  }\r\n\r\n  if (topologyType(topology) === TopologyType.Single) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\r\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\r\n\r\nfunction getMMAPError(err) {\r\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\r\n    return err;\r\n  }\r\n\r\n  // According to the retryable writes spec, we must replace the error message in this case.\r\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\r\n  const newErr = new MongoError({\r\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\r\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\r\n    originalError: err\r\n  });\r\n  return newErr;\r\n}\r\n\r\nmodule.exports.SessionMixins = SessionMixins;\r\nmodule.exports.resolveClusterTime = resolveClusterTime;\r\nmodule.exports.inquireServerState = inquireServerState;\r\nmodule.exports.getTopologyType = getTopologyType;\r\nmodule.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;\r\nmodule.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;\r\nmodule.exports.cloneOptions = cloneOptions;\r\nmodule.exports.createClientInfo = createClientInfo;\r\nmodule.exports.createCompressionInfo = createCompressionInfo;\r\nmodule.exports.clone = clone;\r\nmodule.exports.diff = diff;\r\nmodule.exports.Interval = Interval;\r\nmodule.exports.Timeout = Timeout;\r\nmodule.exports.isRetryableWritesSupported = isRetryableWritesSupported;\r\nmodule.exports.getMMAPError = getMMAPError;\r\n"]},"metadata":{},"sourceType":"script"}