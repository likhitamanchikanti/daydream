{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    EventEmitter = require('events').EventEmitter,\n    ReadPreference = require('./read_preference'),\n    Logger = require('../connection/logger'),\n    debugOptions = require('../connection/utils').debugOptions,\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    Pool = require('../connection/pool'),\n    MongoError = require('../error').MongoError,\n    MongoNetworkError = require('../error').MongoNetworkError,\n    wireProtocol = require('../wireprotocol'),\n    CoreCursor = require('../cursor').CoreCursor,\n    sdam = require('./shared'),\n    createClientInfo = require('./shared').createClientInfo,\n    createCompressionInfo = require('./shared').createCompressionInfo,\n    resolveClusterTime = require('./shared').resolveClusterTime,\n    SessionMixins = require('./shared').SessionMixins,\n    relayEvents = require('../utils').relayEvents;\n\nconst collationNotSupported = require('../utils').collationNotSupported; // Used for filtering out fields for loggin\n\n\nvar debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername']; // Server instance id\n\nvar id = 0;\nvar serverAccounting = false;\nvar servers = {};\nvar BSON = retrieveBSON();\n/**\r\n * Creates a new Server instance\r\n * @class\r\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\r\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\r\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\r\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\r\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\r\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\r\n * @param {string} options.host The server host\r\n * @param {number} options.port The server port\r\n * @param {number} [options.size=5] Server connection pool size\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passphrase] SSL Certificate pass phrase\r\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\r\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\r\n * @return {Server} A cursor instance\r\n * @fires Server#connect\r\n * @fires Server#close\r\n * @fires Server#error\r\n * @fires Server#timeout\r\n * @fires Server#parseError\r\n * @fires Server#reconnect\r\n * @fires Server#reconnectFailed\r\n * @fires Server#serverHeartbeatStarted\r\n * @fires Server#serverHeartbeatSucceeded\r\n * @fires Server#serverHeartbeatFailed\r\n * @fires Server#topologyOpening\r\n * @fires Server#topologyClosed\r\n * @fires Server#topologyDescriptionChanged\r\n * @property {string} type the topology type.\r\n * @property {string} parserType the parser type used (c++ or js).\r\n */\n\nvar Server = function (options) {\n  options = options || {}; // Add event listener\n\n  EventEmitter.call(this); // Server instance id\n\n  this.id = id++; // Internal state\n\n  this.s = {\n    // Options\n    options: options,\n    // Logger\n    logger: Logger('Server', options),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Pool\n    pool: null,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Monitor thread (keeps the connection alive)\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\n    // Is the server in a topology\n    inTopology: !!options.parent,\n    // Monitoring timeout\n    monitoringInterval: typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\n    // Topology id\n    topologyId: -1,\n    compression: {\n      compressors: createCompressionInfo(options)\n    },\n    // Optional parent topology\n    parent: options.parent\n  }; // If this is a single deployment we need to track the clusterTime here\n\n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  } // Curent ismaster\n\n\n  this.ismaster = null; // Current ping time\n\n  this.lastIsMasterMS = -1; // The monitoringProcessId\n\n  this.monitoringProcessId = null; // Initial connection\n\n  this.initialConnect = true; // Default type\n\n  this._type = 'server'; // Set the client info\n\n  this.clientInfo = createClientInfo(options); // Max Stalleness values\n  // last time we updated the ismaster state\n\n  this.lastUpdateTime = 0; // Last write time\n\n  this.lastWriteDate = 0; // Stalleness\n\n  this.staleness = 0;\n};\n\ninherits(Server, EventEmitter);\nObject.assign(Server.prototype, SessionMixins);\nObject.defineProperty(Server.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return this._type;\n  }\n});\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function () {\n    if (!this.ismaster) return null;\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\n  }\n}); // In single server deployments we track the clusterTime directly on the topology, however\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\n// tracking objects so we can ensure we are gossiping the maximum time received from the\n// server.\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  enumerable: true,\n  set: function (clusterTime) {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    resolveClusterTime(settings, clusterTime);\n  },\n  get: function () {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    return settings.clusterTime || null;\n  }\n});\n\nServer.enableServerAccounting = function () {\n  serverAccounting = true;\n  servers = {};\n};\n\nServer.disableServerAccounting = function () {\n  serverAccounting = false;\n};\n\nServer.servers = function () {\n  return servers;\n};\n\nObject.defineProperty(Server.prototype, 'name', {\n  enumerable: true,\n  get: function () {\n    return this.s.options.host + ':' + this.s.options.port;\n  }\n});\n\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\n  // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n  if (!self.s.pool.isConnected() && self.s.options.reconnect && self.s.disconnectHandler != null && !options.monitoring) {\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\n    return true;\n  } // If we have no connection error\n\n\n  if (!self.s.pool.isConnected()) {\n    callback(new MongoError(f('no connection available to server %s', self.name)));\n    return true;\n  }\n}\n\nfunction monitoringProcess(self) {\n  return function () {\n    // Pool was destroyed do not continue process\n    if (self.s.pool.isDestroyed()) return; // Emit monitoring Process event\n\n    self.emit('monitoring', self); // Perform ismaster call\n    // Get start time\n\n    var start = new Date().getTime(); // Execute the ismaster query\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: typeof self.s.options.connectionTimeout !== 'number' ? 2000 : self.s.options.connectionTimeout,\n      monitoring: true\n    }, (err, result) => {\n      // Set initial lastIsMasterMS\n      self.lastIsMasterMS = new Date().getTime() - start;\n      if (self.s.pool.isDestroyed()) return; // Update the ismaster view if we have a result\n\n      if (result) {\n        self.ismaster = result.result;\n      } // Re-schedule the monitoring process\n\n\n      self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n    });\n  };\n}\n\nvar eventHandler = function (self, event) {\n  return function (err, conn) {\n    // Log information of received information if in info mode\n    if (self.s.logger.isInfo()) {\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\n      self.s.logger.info(f('server %s fired event %s out with message %s', self.name, event, object));\n    } // Handle connect event\n\n\n    if (event === 'connect') {\n      self.initialConnect = false;\n      self.ismaster = conn.ismaster;\n      self.lastIsMasterMS = conn.lastIsMasterMS;\n\n      if (conn.agreedCompressor) {\n        self.s.pool.options.agreedCompressor = conn.agreedCompressor;\n      }\n\n      if (conn.zlibCompressionLevel) {\n        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n      }\n\n      if (conn.ismaster.$clusterTime) {\n        const $clusterTime = conn.ismaster.$clusterTime;\n        self.clusterTime = $clusterTime;\n      } // It's a proxy change the type so\n      // the wireprotocol will send $readPreference\n\n\n      if (self.ismaster.msg === 'isdbgrid') {\n        self._type = 'mongos';\n      } // Have we defined self monitoring\n\n\n      if (self.s.monitoring) {\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      } // Emit server description changed if something listening\n\n\n      sdam.emitServerDescriptionChanged(self, {\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: sdam.getTopologyType(self)\n      });\n\n      if (!self.s.inTopology) {\n        // Emit topology description changed if something listening\n        sdam.emitTopologyDescriptionChanged(self, {\n          topologyType: 'Single',\n          servers: [{\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: sdam.getTopologyType(self)\n          }]\n        });\n      } // Log the ismaster if available\n\n\n      if (self.s.logger.isInfo()) {\n        self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));\n      } // Emit connect\n\n\n      self.emit('connect', self);\n    } else if (event === 'error' || event === 'parseError' || event === 'close' || event === 'timeout' || event === 'reconnect' || event === 'attemptReconnect' || 'reconnectFailed') {\n      // Remove server instance from accounting\n      if (serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1) {\n        // Emit toplogy opening event if not in topology\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', {\n            topologyId: self.id\n          });\n        }\n\n        delete servers[self.id];\n      }\n\n      if (event === 'close') {\n        // Closing emits a server description changed event going to unknown.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        });\n      } // Reconnect failed return error\n\n\n      if (event === 'reconnectFailed') {\n        self.emit('reconnectFailed', err); // Emit error if any listeners\n\n        if (self.listeners('error').length > 0) {\n          self.emit('error', err);\n        } // Terminate\n\n\n        return;\n      } // On first connect fail\n\n\n      if (['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 && self.initialConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1) {\n        self.initialConnect = false;\n        return self.emit('error', new MongoNetworkError(f('failed to connect to server [%s] on first connect [%s]', self.name, err)));\n      } // Reconnect event, emit the server\n\n\n      if (event === 'reconnect') {\n        // Reconnecting emits a server description changed event going from unknown to the\n        // current server type.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n        return self.emit(event, self);\n      } // Emit the event\n\n\n      self.emit(event, err);\n    }\n  };\n};\n/**\r\n * Initiate server connect\r\n */\n\n\nServer.prototype.connect = function (options) {\n  var self = this;\n  options = options || {}; // Set the connections\n\n  if (serverAccounting) servers[this.id] = this; // Do not allow connect to be called on anything that's not disconnected\n\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\n  } // Create a pool\n\n\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, {\n    bson: this.s.bson\n  })); // Set up listeners\n\n  self.s.pool.on('close', eventHandler(self, 'close'));\n  self.s.pool.on('error', eventHandler(self, 'error'));\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed')); // Set up listeners for command monitoring\n\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']); // Emit toplogy opening event if not in topology\n\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', {\n      topologyId: self.id\n    });\n  } // Emit opening server event\n\n\n  self.emit('serverOpening', {\n    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n    address: self.name\n  });\n  self.s.pool.connect();\n};\n/**\r\n * Authenticate the topology.\r\n * @method\r\n * @param {MongoCredentials} credentials The credentials for authentication we are using\r\n * @param {authResultCallback} callback A callback function\r\n */\n\n\nServer.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\r\n * Get the server description\r\n * @method\r\n * @return {object}\r\n */\n\n\nServer.prototype.getDescription = function () {\n  var ismaster = this.ismaster || {};\n  var description = {\n    type: sdam.getTopologyType(this),\n    address: this.name\n  }; // Add fields if available\n\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n/**\r\n * Returns the last known ismaster document for this server\r\n * @method\r\n * @return {object}\r\n */\n\n\nServer.prototype.lastIsMaster = function () {\n  return this.ismaster;\n};\n/**\r\n * Unref all connections belong to this server\r\n * @method\r\n */\n\n\nServer.prototype.unref = function () {\n  this.s.pool.unref();\n};\n/**\r\n * Figure out if the server is connected\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nServer.prototype.isConnected = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isConnected();\n};\n/**\r\n * Figure out if the server instance was destroyed by calling destroy\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nServer.prototype.isDestroyed = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isDestroyed();\n};\n\nfunction basicWriteValidations(self) {\n  if (!self.s.pool) return new MongoError('server instance is not connected');\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\n}\n\nfunction basicReadValidations(self, options) {\n  basicWriteValidations(self, options);\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error('readPreference must be an instance of ReadPreference');\n  }\n}\n/**\r\n * Execute a command\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cmd The command hash\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nServer.prototype.command = function (ns, cmd, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicReadValidations(self, options);\n  if (result) return callback(result); // Clone the options\n\n  options = Object.assign({}, options, {\n    wireProtocolCommand: false\n  }); // Debug log\n\n  if (self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({\n    ns: ns,\n    cmd: cmd,\n    options: debugOptions(debugFields, options)\n  }), self.name)); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, cmd)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  wireProtocol.command(self, ns, cmd, options, callback);\n};\n/**\r\n * Execute a query against the server\r\n *\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cmd The command document for the query\r\n * @param {object} options Optional settings\r\n * @param {function} callback\r\n */\n\n\nServer.prototype.query = function (ns, cmd, cursorState, options, callback) {\n  wireProtocol.query(this, ns, cmd, cursorState, options, callback);\n};\n/**\r\n * Execute a `getMore` against the server\r\n *\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cursorState State data associated with the cursor calling this method\r\n * @param {object} options Optional settings\r\n * @param {function} callback\r\n */\n\n\nServer.prototype.getMore = function (ns, cursorState, batchSize, options, callback) {\n  wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);\n};\n/**\r\n * Execute a `killCursors` command against the server\r\n *\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cursorState State data associated with the cursor calling this method\r\n * @param {function} callback\r\n */\n\n\nServer.prototype.killCursors = function (ns, cursorState, callback) {\n  wireProtocol.killCursors(this, ns, cursorState, callback);\n};\n/**\r\n * Insert one or more documents\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of documents to insert\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nServer.prototype.insert = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return; // Setup the docs as an array\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return wireProtocol.insert(self, ns, ops, options, callback);\n};\n/**\r\n * Perform one or more update operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of updates\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nServer.prototype.update = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return wireProtocol.update(self, ns, ops, options, callback);\n};\n/**\r\n * Perform one or more remove operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of removes\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nServer.prototype.remove = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return wireProtocol.remove(self, ns, ops, options, callback);\n};\n/**\r\n * Get a new cursor\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\r\n * @param {object} [options] Options for the cursor\r\n * @param {object} [options.batchSize=0] Batchsize for the operation\r\n * @param {array} [options.documents=[]] Initial documents list for cursor\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {object} [options.topology] The internal topology of the created cursor\r\n * @returns {Cursor}\r\n */\n\n\nServer.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this; // Set up final cursor type\n\n  var FinalCursor = options.cursorFactory || this.s.Cursor; // Return the cursor\n\n  return new FinalCursor(topology, ns, cmd, options);\n};\n/**\r\n * Compare two server instances\r\n * @method\r\n * @param {Server} server Server to compare equality against\r\n * @return {boolean}\r\n */\n\n\nServer.prototype.equals = function (server) {\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\n  return false;\n};\n/**\r\n * All raw connections\r\n * @method\r\n * @return {Connection[]}\r\n */\n\n\nServer.prototype.connections = function () {\n  return this.s.pool.allConnections();\n};\n/**\r\n * Selects a server\r\n * @method\r\n * @param {function} selector Unused\r\n * @param {ReadPreference} [options.readPreference] Unused\r\n * @param {ClientSession} [options.session] Unused\r\n * @return {Server}\r\n */\n\n\nServer.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector, selector = undefined;\n  callback(null, this);\n};\n\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\n/**\r\n * Destroy the server connection\r\n * @method\r\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\r\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\r\n * @param {boolean} [options.force=false] Force destroy the pool\r\n */\n\nServer.prototype.destroy = function (options, callback) {\n  if (this._destroyed) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  options = options || {};\n  var self = this; // Set the connections\n\n  if (serverAccounting) delete servers[this.id]; // Destroy the monitoring process if any\n\n  if (this.monitoringProcessId) {\n    clearTimeout(this.monitoringProcessId);\n  } // No pool, return\n\n\n  if (!self.s.pool) {\n    this._destroyed = true;\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  } // Emit close event\n\n\n  if (options.emitClose) {\n    self.emit('close', self);\n  } // Emit destroy event\n\n\n  if (options.emitDestroy) {\n    self.emit('destroy', self);\n  } // Remove all listeners\n\n\n  listeners.forEach(function (event) {\n    self.s.pool.removeAllListeners(event);\n  }); // Emit opening server event\n\n  if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n    address: self.name\n  }); // Emit toplogy opening event if not in topology\n\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', {\n      topologyId: self.id\n    });\n  }\n\n  if (self.s.logger.isDebug()) {\n    self.s.logger.debug(f('destroy called on server %s', self.name));\n  } // Destroy the pool\n\n\n  this.s.pool.destroy(options.force, callback);\n  this._destroyed = true;\n};\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Server#connect\r\n * @type {Server}\r\n */\n\n/**\r\n * A server reconnect event, used to verify that the server topology has reconnected\r\n *\r\n * @event Server#reconnect\r\n * @type {Server}\r\n */\n\n/**\r\n * A server opening SDAM monitoring event\r\n *\r\n * @event Server#serverOpening\r\n * @type {object}\r\n */\n\n/**\r\n * A server closed SDAM monitoring event\r\n *\r\n * @event Server#serverClosed\r\n * @type {object}\r\n */\n\n/**\r\n * A server description SDAM change monitoring event\r\n *\r\n * @event Server#serverDescriptionChanged\r\n * @type {object}\r\n */\n\n/**\r\n * A topology open SDAM event\r\n *\r\n * @event Server#topologyOpening\r\n * @type {object}\r\n */\n\n/**\r\n * A topology closed SDAM event\r\n *\r\n * @event Server#topologyClosed\r\n * @type {object}\r\n */\n\n/**\r\n * A topology structure SDAM change event\r\n *\r\n * @event Server#topologyDescriptionChanged\r\n * @type {object}\r\n */\n\n/**\r\n * Server reconnect failed\r\n *\r\n * @event Server#reconnectFailed\r\n * @type {Error}\r\n */\n\n/**\r\n * Server connection pool closed\r\n *\r\n * @event Server#close\r\n * @type {object}\r\n */\n\n/**\r\n * Server connection pool caused an error\r\n *\r\n * @event Server#error\r\n * @type {Error}\r\n */\n\n/**\r\n * Server destroyed was called\r\n *\r\n * @event Server#destroy\r\n * @type {Server}\r\n */\n\n\nmodule.exports = Server;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/topologies/server.js"],"names":["inherits","require","f","format","EventEmitter","ReadPreference","Logger","debugOptions","retrieveBSON","Pool","MongoError","MongoNetworkError","wireProtocol","CoreCursor","sdam","createClientInfo","createCompressionInfo","resolveClusterTime","SessionMixins","relayEvents","collationNotSupported","debugFields","id","serverAccounting","servers","BSON","Server","options","call","s","logger","Cursor","cursorFactory","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","pool","disconnectHandler","monitoring","inTopology","parent","monitoringInterval","topologyId","compression","compressors","clusterTime","ismaster","lastIsMasterMS","monitoringProcessId","initialConnect","_type","clientInfo","lastUpdateTime","lastWriteDate","staleness","Object","assign","prototype","defineProperty","enumerable","get","native","logicalSessionTimeoutMinutes","set","settings","enableServerAccounting","disableServerAccounting","host","port","self","type","ns","cmd","callback","isConnected","reconnect","add","name","monitoringProcess","isDestroyed","emit","start","Date","getTime","command","socketTimeout","connectionTimeout","err","result","setTimeout","eventHandler","event","conn","isInfo","object","JSON","stringify","info","agreedCompressor","zlibCompressionLevel","$clusterTime","msg","emitServerDescriptionChanged","address","arbiters","hosts","passives","getTopologyType","emitTopologyDescriptionChanged","topologyType","indexOf","listeners","length","state","connect","isDisconnected","on","auth","credentials","getDescription","description","setName","lastIsMaster","unref","basicWriteValidations","basicReadValidations","readPreference","Error","wireProtocolCommand","isDebug","debug","query","cursorState","getMore","batchSize","killCursors","insert","ops","Array","isArray","update","remove","cursor","topology","FinalCursor","equals","server","toLowerCase","connections","allConnections","selectServer","selector","undefined","destroy","_destroyed","clearTimeout","emitClose","emitDestroy","forEach","removeAllListeners","force","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar inherits = require('util').inherits,\r\n  f = require('util').format,\r\n  EventEmitter = require('events').EventEmitter,\r\n  ReadPreference = require('./read_preference'),\r\n  Logger = require('../connection/logger'),\r\n  debugOptions = require('../connection/utils').debugOptions,\r\n  retrieveBSON = require('../connection/utils').retrieveBSON,\r\n  Pool = require('../connection/pool'),\r\n  MongoError = require('../error').MongoError,\r\n  MongoNetworkError = require('../error').MongoNetworkError,\r\n  wireProtocol = require('../wireprotocol'),\r\n  CoreCursor = require('../cursor').CoreCursor,\r\n  sdam = require('./shared'),\r\n  createClientInfo = require('./shared').createClientInfo,\r\n  createCompressionInfo = require('./shared').createCompressionInfo,\r\n  resolveClusterTime = require('./shared').resolveClusterTime,\r\n  SessionMixins = require('./shared').SessionMixins,\r\n  relayEvents = require('../utils').relayEvents;\r\n\r\nconst collationNotSupported = require('../utils').collationNotSupported;\r\n\r\n// Used for filtering out fields for loggin\r\nvar debugFields = [\r\n  'reconnect',\r\n  'reconnectTries',\r\n  'reconnectInterval',\r\n  'emitError',\r\n  'cursorFactory',\r\n  'host',\r\n  'port',\r\n  'size',\r\n  'keepAlive',\r\n  'keepAliveInitialDelay',\r\n  'noDelay',\r\n  'connectionTimeout',\r\n  'checkServerIdentity',\r\n  'socketTimeout',\r\n  'ssl',\r\n  'ca',\r\n  'crl',\r\n  'cert',\r\n  'key',\r\n  'rejectUnauthorized',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'servername'\r\n];\r\n\r\n// Server instance id\r\nvar id = 0;\r\nvar serverAccounting = false;\r\nvar servers = {};\r\nvar BSON = retrieveBSON();\r\n\r\n/**\r\n * Creates a new Server instance\r\n * @class\r\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\r\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\r\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\r\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\r\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\r\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\r\n * @param {string} options.host The server host\r\n * @param {number} options.port The server port\r\n * @param {number} [options.size=5] Server connection pool size\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passphrase] SSL Certificate pass phrase\r\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\r\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\r\n * @return {Server} A cursor instance\r\n * @fires Server#connect\r\n * @fires Server#close\r\n * @fires Server#error\r\n * @fires Server#timeout\r\n * @fires Server#parseError\r\n * @fires Server#reconnect\r\n * @fires Server#reconnectFailed\r\n * @fires Server#serverHeartbeatStarted\r\n * @fires Server#serverHeartbeatSucceeded\r\n * @fires Server#serverHeartbeatFailed\r\n * @fires Server#topologyOpening\r\n * @fires Server#topologyClosed\r\n * @fires Server#topologyDescriptionChanged\r\n * @property {string} type the topology type.\r\n * @property {string} parserType the parser type used (c++ or js).\r\n */\r\nvar Server = function(options) {\r\n  options = options || {};\r\n\r\n  // Add event listener\r\n  EventEmitter.call(this);\r\n\r\n  // Server instance id\r\n  this.id = id++;\r\n\r\n  // Internal state\r\n  this.s = {\r\n    // Options\r\n    options: options,\r\n    // Logger\r\n    logger: Logger('Server', options),\r\n    // Factory overrides\r\n    Cursor: options.cursorFactory || CoreCursor,\r\n    // BSON instance\r\n    bson:\r\n      options.bson ||\r\n      new BSON([\r\n        BSON.Binary,\r\n        BSON.Code,\r\n        BSON.DBRef,\r\n        BSON.Decimal128,\r\n        BSON.Double,\r\n        BSON.Int32,\r\n        BSON.Long,\r\n        BSON.Map,\r\n        BSON.MaxKey,\r\n        BSON.MinKey,\r\n        BSON.ObjectId,\r\n        BSON.BSONRegExp,\r\n        BSON.Symbol,\r\n        BSON.Timestamp\r\n      ]),\r\n    // Pool\r\n    pool: null,\r\n    // Disconnect handler\r\n    disconnectHandler: options.disconnectHandler,\r\n    // Monitor thread (keeps the connection alive)\r\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\r\n    // Is the server in a topology\r\n    inTopology: !!options.parent,\r\n    // Monitoring timeout\r\n    monitoringInterval:\r\n      typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\r\n    // Topology id\r\n    topologyId: -1,\r\n    compression: { compressors: createCompressionInfo(options) },\r\n    // Optional parent topology\r\n    parent: options.parent\r\n  };\r\n\r\n  // If this is a single deployment we need to track the clusterTime here\r\n  if (!this.s.parent) {\r\n    this.s.clusterTime = null;\r\n  }\r\n\r\n  // Curent ismaster\r\n  this.ismaster = null;\r\n  // Current ping time\r\n  this.lastIsMasterMS = -1;\r\n  // The monitoringProcessId\r\n  this.monitoringProcessId = null;\r\n  // Initial connection\r\n  this.initialConnect = true;\r\n  // Default type\r\n  this._type = 'server';\r\n  // Set the client info\r\n  this.clientInfo = createClientInfo(options);\r\n\r\n  // Max Stalleness values\r\n  // last time we updated the ismaster state\r\n  this.lastUpdateTime = 0;\r\n  // Last write time\r\n  this.lastWriteDate = 0;\r\n  // Stalleness\r\n  this.staleness = 0;\r\n};\r\n\r\ninherits(Server, EventEmitter);\r\nObject.assign(Server.prototype, SessionMixins);\r\n\r\nObject.defineProperty(Server.prototype, 'type', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this._type;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Server.prototype, 'parserType', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return BSON.native ? 'c++' : 'js';\r\n  }\r\n});\r\n\r\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\r\n  enumerable: true,\r\n  get: function() {\r\n    if (!this.ismaster) return null;\r\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\r\n  }\r\n});\r\n\r\n// In single server deployments we track the clusterTime directly on the topology, however\r\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\r\n// tracking objects so we can ensure we are gossiping the maximum time received from the\r\n// server.\r\nObject.defineProperty(Server.prototype, 'clusterTime', {\r\n  enumerable: true,\r\n  set: function(clusterTime) {\r\n    const settings = this.s.parent ? this.s.parent : this.s;\r\n    resolveClusterTime(settings, clusterTime);\r\n  },\r\n  get: function() {\r\n    const settings = this.s.parent ? this.s.parent : this.s;\r\n    return settings.clusterTime || null;\r\n  }\r\n});\r\n\r\nServer.enableServerAccounting = function() {\r\n  serverAccounting = true;\r\n  servers = {};\r\n};\r\n\r\nServer.disableServerAccounting = function() {\r\n  serverAccounting = false;\r\n};\r\n\r\nServer.servers = function() {\r\n  return servers;\r\n};\r\n\r\nObject.defineProperty(Server.prototype, 'name', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.s.options.host + ':' + this.s.options.port;\r\n  }\r\n});\r\n\r\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\r\n  // Topology is not connected, save the call in the provided store to be\r\n  // Executed at some point when the handler deems it's reconnected\r\n  if (\r\n    !self.s.pool.isConnected() &&\r\n    self.s.options.reconnect &&\r\n    self.s.disconnectHandler != null &&\r\n    !options.monitoring\r\n  ) {\r\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\r\n    return true;\r\n  }\r\n\r\n  // If we have no connection error\r\n  if (!self.s.pool.isConnected()) {\r\n    callback(new MongoError(f('no connection available to server %s', self.name)));\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction monitoringProcess(self) {\r\n  return function() {\r\n    // Pool was destroyed do not continue process\r\n    if (self.s.pool.isDestroyed()) return;\r\n    // Emit monitoring Process event\r\n    self.emit('monitoring', self);\r\n    // Perform ismaster call\r\n    // Get start time\r\n    var start = new Date().getTime();\r\n\r\n    // Execute the ismaster query\r\n    self.command(\r\n      'admin.$cmd',\r\n      { ismaster: true },\r\n      {\r\n        socketTimeout:\r\n          typeof self.s.options.connectionTimeout !== 'number'\r\n            ? 2000\r\n            : self.s.options.connectionTimeout,\r\n        monitoring: true\r\n      },\r\n      (err, result) => {\r\n        // Set initial lastIsMasterMS\r\n        self.lastIsMasterMS = new Date().getTime() - start;\r\n        if (self.s.pool.isDestroyed()) return;\r\n        // Update the ismaster view if we have a result\r\n        if (result) {\r\n          self.ismaster = result.result;\r\n        }\r\n        // Re-schedule the monitoring process\r\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\r\n      }\r\n    );\r\n  };\r\n}\r\n\r\nvar eventHandler = function(self, event) {\r\n  return function(err, conn) {\r\n    // Log information of received information if in info mode\r\n    if (self.s.logger.isInfo()) {\r\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\r\n      self.s.logger.info(\r\n        f('server %s fired event %s out with message %s', self.name, event, object)\r\n      );\r\n    }\r\n\r\n    // Handle connect event\r\n    if (event === 'connect') {\r\n      self.initialConnect = false;\r\n      self.ismaster = conn.ismaster;\r\n      self.lastIsMasterMS = conn.lastIsMasterMS;\r\n      if (conn.agreedCompressor) {\r\n        self.s.pool.options.agreedCompressor = conn.agreedCompressor;\r\n      }\r\n\r\n      if (conn.zlibCompressionLevel) {\r\n        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\r\n      }\r\n\r\n      if (conn.ismaster.$clusterTime) {\r\n        const $clusterTime = conn.ismaster.$clusterTime;\r\n        self.clusterTime = $clusterTime;\r\n      }\r\n\r\n      // It's a proxy change the type so\r\n      // the wireprotocol will send $readPreference\r\n      if (self.ismaster.msg === 'isdbgrid') {\r\n        self._type = 'mongos';\r\n      }\r\n\r\n      // Have we defined self monitoring\r\n      if (self.s.monitoring) {\r\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\r\n      }\r\n\r\n      // Emit server description changed if something listening\r\n      sdam.emitServerDescriptionChanged(self, {\r\n        address: self.name,\r\n        arbiters: [],\r\n        hosts: [],\r\n        passives: [],\r\n        type: sdam.getTopologyType(self)\r\n      });\r\n\r\n      if (!self.s.inTopology) {\r\n        // Emit topology description changed if something listening\r\n        sdam.emitTopologyDescriptionChanged(self, {\r\n          topologyType: 'Single',\r\n          servers: [\r\n            {\r\n              address: self.name,\r\n              arbiters: [],\r\n              hosts: [],\r\n              passives: [],\r\n              type: sdam.getTopologyType(self)\r\n            }\r\n          ]\r\n        });\r\n      }\r\n\r\n      // Log the ismaster if available\r\n      if (self.s.logger.isInfo()) {\r\n        self.s.logger.info(\r\n          f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster))\r\n        );\r\n      }\r\n\r\n      // Emit connect\r\n      self.emit('connect', self);\r\n    } else if (\r\n      event === 'error' ||\r\n      event === 'parseError' ||\r\n      event === 'close' ||\r\n      event === 'timeout' ||\r\n      event === 'reconnect' ||\r\n      event === 'attemptReconnect' ||\r\n      'reconnectFailed'\r\n    ) {\r\n      // Remove server instance from accounting\r\n      if (\r\n        serverAccounting &&\r\n        ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1\r\n      ) {\r\n        // Emit toplogy opening event if not in topology\r\n        if (!self.s.inTopology) {\r\n          self.emit('topologyOpening', { topologyId: self.id });\r\n        }\r\n\r\n        delete servers[self.id];\r\n      }\r\n\r\n      if (event === 'close') {\r\n        // Closing emits a server description changed event going to unknown.\r\n        sdam.emitServerDescriptionChanged(self, {\r\n          address: self.name,\r\n          arbiters: [],\r\n          hosts: [],\r\n          passives: [],\r\n          type: 'Unknown'\r\n        });\r\n      }\r\n\r\n      // Reconnect failed return error\r\n      if (event === 'reconnectFailed') {\r\n        self.emit('reconnectFailed', err);\r\n        // Emit error if any listeners\r\n        if (self.listeners('error').length > 0) {\r\n          self.emit('error', err);\r\n        }\r\n        // Terminate\r\n        return;\r\n      }\r\n\r\n      // On first connect fail\r\n      if (\r\n        ['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 &&\r\n        self.initialConnect &&\r\n        ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1\r\n      ) {\r\n        self.initialConnect = false;\r\n        return self.emit(\r\n          'error',\r\n          new MongoNetworkError(\r\n            f('failed to connect to server [%s] on first connect [%s]', self.name, err)\r\n          )\r\n        );\r\n      }\r\n\r\n      // Reconnect event, emit the server\r\n      if (event === 'reconnect') {\r\n        // Reconnecting emits a server description changed event going from unknown to the\r\n        // current server type.\r\n        sdam.emitServerDescriptionChanged(self, {\r\n          address: self.name,\r\n          arbiters: [],\r\n          hosts: [],\r\n          passives: [],\r\n          type: sdam.getTopologyType(self)\r\n        });\r\n        return self.emit(event, self);\r\n      }\r\n\r\n      // Emit the event\r\n      self.emit(event, err);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Initiate server connect\r\n */\r\nServer.prototype.connect = function(options) {\r\n  var self = this;\r\n  options = options || {};\r\n\r\n  // Set the connections\r\n  if (serverAccounting) servers[this.id] = this;\r\n\r\n  // Do not allow connect to be called on anything that's not disconnected\r\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\r\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\r\n  }\r\n\r\n  // Create a pool\r\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, { bson: this.s.bson }));\r\n\r\n  // Set up listeners\r\n  self.s.pool.on('close', eventHandler(self, 'close'));\r\n  self.s.pool.on('error', eventHandler(self, 'error'));\r\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\r\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\r\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\r\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\r\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));\r\n\r\n  // Set up listeners for command monitoring\r\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\r\n\r\n  // Emit toplogy opening event if not in topology\r\n  if (!self.s.inTopology) {\r\n    this.emit('topologyOpening', { topologyId: self.id });\r\n  }\r\n\r\n  // Emit opening server event\r\n  self.emit('serverOpening', {\r\n    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\r\n    address: self.name\r\n  });\r\n\r\n  self.s.pool.connect();\r\n};\r\n\r\n/**\r\n * Authenticate the topology.\r\n * @method\r\n * @param {MongoCredentials} credentials The credentials for authentication we are using\r\n * @param {authResultCallback} callback A callback function\r\n */\r\nServer.prototype.auth = function(credentials, callback) {\r\n  if (typeof callback === 'function') callback(null, null);\r\n};\r\n\r\n/**\r\n * Get the server description\r\n * @method\r\n * @return {object}\r\n */\r\nServer.prototype.getDescription = function() {\r\n  var ismaster = this.ismaster || {};\r\n  var description = {\r\n    type: sdam.getTopologyType(this),\r\n    address: this.name\r\n  };\r\n\r\n  // Add fields if available\r\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\r\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\r\n  if (ismaster.passives) description.passives = ismaster.passives;\r\n  if (ismaster.setName) description.setName = ismaster.setName;\r\n  return description;\r\n};\r\n\r\n/**\r\n * Returns the last known ismaster document for this server\r\n * @method\r\n * @return {object}\r\n */\r\nServer.prototype.lastIsMaster = function() {\r\n  return this.ismaster;\r\n};\r\n\r\n/**\r\n * Unref all connections belong to this server\r\n * @method\r\n */\r\nServer.prototype.unref = function() {\r\n  this.s.pool.unref();\r\n};\r\n\r\n/**\r\n * Figure out if the server is connected\r\n * @method\r\n * @return {boolean}\r\n */\r\nServer.prototype.isConnected = function() {\r\n  if (!this.s.pool) return false;\r\n  return this.s.pool.isConnected();\r\n};\r\n\r\n/**\r\n * Figure out if the server instance was destroyed by calling destroy\r\n * @method\r\n * @return {boolean}\r\n */\r\nServer.prototype.isDestroyed = function() {\r\n  if (!this.s.pool) return false;\r\n  return this.s.pool.isDestroyed();\r\n};\r\n\r\nfunction basicWriteValidations(self) {\r\n  if (!self.s.pool) return new MongoError('server instance is not connected');\r\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\r\n}\r\n\r\nfunction basicReadValidations(self, options) {\r\n  basicWriteValidations(self, options);\r\n\r\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\r\n    throw new Error('readPreference must be an instance of ReadPreference');\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a command\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cmd The command hash\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nServer.prototype.command = function(ns, cmd, options, callback) {\r\n  var self = this;\r\n  if (typeof options === 'function') {\r\n    (callback = options), (options = {}), (options = options || {});\r\n  }\r\n\r\n  var result = basicReadValidations(self, options);\r\n  if (result) return callback(result);\r\n\r\n  // Clone the options\r\n  options = Object.assign({}, options, { wireProtocolCommand: false });\r\n\r\n  // Debug log\r\n  if (self.s.logger.isDebug())\r\n    self.s.logger.debug(\r\n      f(\r\n        'executing command [%s] against %s',\r\n        JSON.stringify({\r\n          ns: ns,\r\n          cmd: cmd,\r\n          options: debugOptions(debugFields, options)\r\n        }),\r\n        self.name\r\n      )\r\n    );\r\n\r\n  // If we are not connected or have a disconnectHandler specified\r\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;\r\n\r\n  // error if collation not supported\r\n  if (collationNotSupported(this, cmd)) {\r\n    return callback(new MongoError(`server ${this.name} does not support collation`));\r\n  }\r\n\r\n  wireProtocol.command(self, ns, cmd, options, callback);\r\n};\r\n\r\n/**\r\n * Execute a query against the server\r\n *\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cmd The command document for the query\r\n * @param {object} options Optional settings\r\n * @param {function} callback\r\n */\r\nServer.prototype.query = function(ns, cmd, cursorState, options, callback) {\r\n  wireProtocol.query(this, ns, cmd, cursorState, options, callback);\r\n};\r\n\r\n/**\r\n * Execute a `getMore` against the server\r\n *\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cursorState State data associated with the cursor calling this method\r\n * @param {object} options Optional settings\r\n * @param {function} callback\r\n */\r\nServer.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {\r\n  wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);\r\n};\r\n\r\n/**\r\n * Execute a `killCursors` command against the server\r\n *\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cursorState State data associated with the cursor calling this method\r\n * @param {function} callback\r\n */\r\nServer.prototype.killCursors = function(ns, cursorState, callback) {\r\n  wireProtocol.killCursors(this, ns, cursorState, callback);\r\n};\r\n\r\n/**\r\n * Insert one or more documents\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of documents to insert\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nServer.prototype.insert = function(ns, ops, options, callback) {\r\n  var self = this;\r\n  if (typeof options === 'function') {\r\n    (callback = options), (options = {}), (options = options || {});\r\n  }\r\n\r\n  var result = basicWriteValidations(self, options);\r\n  if (result) return callback(result);\r\n\r\n  // If we are not connected or have a disconnectHandler specified\r\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;\r\n\r\n  // Setup the docs as an array\r\n  ops = Array.isArray(ops) ? ops : [ops];\r\n\r\n  // Execute write\r\n  return wireProtocol.insert(self, ns, ops, options, callback);\r\n};\r\n\r\n/**\r\n * Perform one or more update operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of updates\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nServer.prototype.update = function(ns, ops, options, callback) {\r\n  var self = this;\r\n  if (typeof options === 'function') {\r\n    (callback = options), (options = {}), (options = options || {});\r\n  }\r\n\r\n  var result = basicWriteValidations(self, options);\r\n  if (result) return callback(result);\r\n\r\n  // If we are not connected or have a disconnectHandler specified\r\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;\r\n\r\n  // error if collation not supported\r\n  if (collationNotSupported(this, options)) {\r\n    return callback(new MongoError(`server ${this.name} does not support collation`));\r\n  }\r\n\r\n  // Setup the docs as an array\r\n  ops = Array.isArray(ops) ? ops : [ops];\r\n  // Execute write\r\n  return wireProtocol.update(self, ns, ops, options, callback);\r\n};\r\n\r\n/**\r\n * Perform one or more remove operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of removes\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nServer.prototype.remove = function(ns, ops, options, callback) {\r\n  var self = this;\r\n  if (typeof options === 'function') {\r\n    (callback = options), (options = {}), (options = options || {});\r\n  }\r\n\r\n  var result = basicWriteValidations(self, options);\r\n  if (result) return callback(result);\r\n\r\n  // If we are not connected or have a disconnectHandler specified\r\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;\r\n\r\n  // error if collation not supported\r\n  if (collationNotSupported(this, options)) {\r\n    return callback(new MongoError(`server ${this.name} does not support collation`));\r\n  }\r\n\r\n  // Setup the docs as an array\r\n  ops = Array.isArray(ops) ? ops : [ops];\r\n  // Execute write\r\n  return wireProtocol.remove(self, ns, ops, options, callback);\r\n};\r\n\r\n/**\r\n * Get a new cursor\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\r\n * @param {object} [options] Options for the cursor\r\n * @param {object} [options.batchSize=0] Batchsize for the operation\r\n * @param {array} [options.documents=[]] Initial documents list for cursor\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {object} [options.topology] The internal topology of the created cursor\r\n * @returns {Cursor}\r\n */\r\nServer.prototype.cursor = function(ns, cmd, options) {\r\n  options = options || {};\r\n  const topology = options.topology || this;\r\n\r\n  // Set up final cursor type\r\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\r\n\r\n  // Return the cursor\r\n  return new FinalCursor(topology, ns, cmd, options);\r\n};\r\n\r\n/**\r\n * Compare two server instances\r\n * @method\r\n * @param {Server} server Server to compare equality against\r\n * @return {boolean}\r\n */\r\nServer.prototype.equals = function(server) {\r\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\r\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\r\n  return false;\r\n};\r\n\r\n/**\r\n * All raw connections\r\n * @method\r\n * @return {Connection[]}\r\n */\r\nServer.prototype.connections = function() {\r\n  return this.s.pool.allConnections();\r\n};\r\n\r\n/**\r\n * Selects a server\r\n * @method\r\n * @param {function} selector Unused\r\n * @param {ReadPreference} [options.readPreference] Unused\r\n * @param {ClientSession} [options.session] Unused\r\n * @return {Server}\r\n */\r\nServer.prototype.selectServer = function(selector, options, callback) {\r\n  if (typeof selector === 'function' && typeof callback === 'undefined')\r\n    (callback = selector), (selector = undefined), (options = {});\r\n  if (typeof options === 'function')\r\n    (callback = options), (options = selector), (selector = undefined);\r\n\r\n  callback(null, this);\r\n};\r\n\r\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\r\n\r\n/**\r\n * Destroy the server connection\r\n * @method\r\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\r\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\r\n * @param {boolean} [options.force=false] Force destroy the pool\r\n */\r\nServer.prototype.destroy = function(options, callback) {\r\n  if (this._destroyed) {\r\n    if (typeof callback === 'function') callback(null, null);\r\n    return;\r\n  }\r\n\r\n  options = options || {};\r\n  var self = this;\r\n\r\n  // Set the connections\r\n  if (serverAccounting) delete servers[this.id];\r\n\r\n  // Destroy the monitoring process if any\r\n  if (this.monitoringProcessId) {\r\n    clearTimeout(this.monitoringProcessId);\r\n  }\r\n\r\n  // No pool, return\r\n  if (!self.s.pool) {\r\n    this._destroyed = true;\r\n    if (typeof callback === 'function') callback(null, null);\r\n    return;\r\n  }\r\n\r\n  // Emit close event\r\n  if (options.emitClose) {\r\n    self.emit('close', self);\r\n  }\r\n\r\n  // Emit destroy event\r\n  if (options.emitDestroy) {\r\n    self.emit('destroy', self);\r\n  }\r\n\r\n  // Remove all listeners\r\n  listeners.forEach(function(event) {\r\n    self.s.pool.removeAllListeners(event);\r\n  });\r\n\r\n  // Emit opening server event\r\n  if (self.listeners('serverClosed').length > 0)\r\n    self.emit('serverClosed', {\r\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\r\n      address: self.name\r\n    });\r\n\r\n  // Emit toplogy opening event if not in topology\r\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\r\n    self.emit('topologyClosed', { topologyId: self.id });\r\n  }\r\n\r\n  if (self.s.logger.isDebug()) {\r\n    self.s.logger.debug(f('destroy called on server %s', self.name));\r\n  }\r\n\r\n  // Destroy the pool\r\n  this.s.pool.destroy(options.force, callback);\r\n  this._destroyed = true;\r\n};\r\n\r\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Server#connect\r\n * @type {Server}\r\n */\r\n\r\n/**\r\n * A server reconnect event, used to verify that the server topology has reconnected\r\n *\r\n * @event Server#reconnect\r\n * @type {Server}\r\n */\r\n\r\n/**\r\n * A server opening SDAM monitoring event\r\n *\r\n * @event Server#serverOpening\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A server closed SDAM monitoring event\r\n *\r\n * @event Server#serverClosed\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A server description SDAM change monitoring event\r\n *\r\n * @event Server#serverDescriptionChanged\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology open SDAM event\r\n *\r\n * @event Server#topologyOpening\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology closed SDAM event\r\n *\r\n * @event Server#topologyClosed\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology structure SDAM change event\r\n *\r\n * @event Server#topologyDescriptionChanged\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * Server reconnect failed\r\n *\r\n * @event Server#reconnectFailed\r\n * @type {Error}\r\n */\r\n\r\n/**\r\n * Server connection pool closed\r\n *\r\n * @event Server#close\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * Server connection pool caused an error\r\n *\r\n * @event Server#error\r\n * @type {Error}\r\n */\r\n\r\n/**\r\n * Server destroyed was called\r\n *\r\n * @event Server#destroy\r\n * @type {Server}\r\n */\r\n\r\nmodule.exports = Server;\r\n"]},"metadata":{},"sourceType":"script"}