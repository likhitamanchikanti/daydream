{"ast":null,"code":"'use strict';\n\nconst Msg = require('../connection/msg').Msg;\n\nconst KillCursor = require('../connection/commands').KillCursor;\n\nconst GetMore = require('../connection/commands').GetMore;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst generateConnectionId = pool => `${pool.options.host}:${pool.options.port}`;\n\nconst maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/**\r\n * Extract the actual command from the query, possibly upconverting if it's a legacy\r\n * format\r\n *\r\n * @param {Object} command the command\r\n */\n\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  } // is this a legacy find command?\n\n\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  } // in the event of a `noResponse` command, just return\n\n\n  if (reply === null) return reply;\n  return reply.result;\n};\n/** An event indicating the start of a given command */\n\n\nclass CommandStartedEvent {\n  /**\r\n   * Create a started event\r\n   *\r\n   * @param {Pool} pool the pool that originated the command\r\n   * @param {Object} command the command\r\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd); // NOTE: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, {\n      command: cmd,\n      databaseName: databaseName(command),\n      commandName,\n      requestId: command.requestId,\n      connectionId: generateConnectionId(pool)\n    });\n  }\n\n}\n/** An event indicating the success of a given command */\n\n\nclass CommandSucceededEvent {\n  /**\r\n   * Create a succeeded event\r\n   *\r\n   * @param {Pool} pool the pool that originated the command\r\n   * @param {Object} command the command\r\n   * @param {Object} reply the reply for this command from the server\r\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\r\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    Object.assign(this, {\n      duration: calculateDurationInMs(started),\n      commandName,\n      reply: maybeRedact(commandName, extractReply(command, reply)),\n      requestId: command.requestId,\n      connectionId: generateConnectionId(pool)\n    });\n  }\n\n}\n/** An event indicating the failure of a given command */\n\n\nclass CommandFailedEvent {\n  /**\r\n   * Create a failure event\r\n   *\r\n   * @param {Pool} pool the pool that originated the command\r\n   * @param {Object} command the command\r\n   * @param {MongoError|Object} error the generated error or a server error response\r\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\r\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    Object.assign(this, {\n      duration: calculateDurationInMs(started),\n      commandName,\n      failure: maybeRedact(commandName, error),\n      requestId: command.requestId,\n      connectionId: generateConnectionId(pool)\n    });\n  }\n\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/connection/apm.js"],"names":["Msg","require","KillCursor","GetMore","calculateDurationInMs","SENSITIVE_COMMANDS","Set","extractCommandName","commandDoc","Object","keys","namespace","command","ns","databaseName","split","collectionName","generateConnectionId","pool","options","host","port","maybeRedact","commandName","result","has","LEGACY_FIND_QUERY_MAP","$query","$orderby","$hint","$comment","$maxScan","$max","$min","$returnKey","$showDiskLoc","$maxTimeMS","$snapshot","LEGACY_FIND_OPTIONS_MAP","numberToSkip","numberToReturn","returnFieldsSelector","OP_QUERY_KEYS","extractCommand","getMore","cursorId","collection","batchSize","killCursors","cursors","cursorIds","query","assign","find","forEach","key","pre32Limit","limit","$explain","explain","extractReply","reply","ok","cursor","id","message","nextBatch","documents","cursorsUnknown","firstBatch","CommandStartedEvent","constructor","cmd","commandObj","requestId","connectionId","CommandSucceededEvent","started","duration","CommandFailedEvent","error","failure","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\nconst Msg = require('../connection/msg').Msg;\r\nconst KillCursor = require('../connection/commands').KillCursor;\r\nconst GetMore = require('../connection/commands').GetMore;\r\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\r\n\r\n/** Commands that we want to redact because of the sensitive nature of their contents */\r\nconst SENSITIVE_COMMANDS = new Set([\r\n  'authenticate',\r\n  'saslStart',\r\n  'saslContinue',\r\n  'getnonce',\r\n  'createUser',\r\n  'updateUser',\r\n  'copydbgetnonce',\r\n  'copydbsaslstart',\r\n  'copydb'\r\n]);\r\n\r\n// helper methods\r\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\r\nconst namespace = command => command.ns;\r\nconst databaseName = command => command.ns.split('.')[0];\r\nconst collectionName = command => command.ns.split('.')[1];\r\nconst generateConnectionId = pool => `${pool.options.host}:${pool.options.port}`;\r\nconst maybeRedact = (commandName, result) => (SENSITIVE_COMMANDS.has(commandName) ? {} : result);\r\n\r\nconst LEGACY_FIND_QUERY_MAP = {\r\n  $query: 'filter',\r\n  $orderby: 'sort',\r\n  $hint: 'hint',\r\n  $comment: 'comment',\r\n  $maxScan: 'maxScan',\r\n  $max: 'max',\r\n  $min: 'min',\r\n  $returnKey: 'returnKey',\r\n  $showDiskLoc: 'showRecordId',\r\n  $maxTimeMS: 'maxTimeMS',\r\n  $snapshot: 'snapshot'\r\n};\r\n\r\nconst LEGACY_FIND_OPTIONS_MAP = {\r\n  numberToSkip: 'skip',\r\n  numberToReturn: 'batchSize',\r\n  returnFieldsSelector: 'projection'\r\n};\r\n\r\nconst OP_QUERY_KEYS = [\r\n  'tailable',\r\n  'oplogReplay',\r\n  'noCursorTimeout',\r\n  'awaitData',\r\n  'partial',\r\n  'exhaust'\r\n];\r\n\r\n/**\r\n * Extract the actual command from the query, possibly upconverting if it's a legacy\r\n * format\r\n *\r\n * @param {Object} command the command\r\n */\r\nconst extractCommand = command => {\r\n  if (command instanceof GetMore) {\r\n    return {\r\n      getMore: command.cursorId,\r\n      collection: collectionName(command),\r\n      batchSize: command.numberToReturn\r\n    };\r\n  }\r\n\r\n  if (command instanceof KillCursor) {\r\n    return {\r\n      killCursors: collectionName(command),\r\n      cursors: command.cursorIds\r\n    };\r\n  }\r\n\r\n  if (command instanceof Msg) {\r\n    return command.command;\r\n  }\r\n\r\n  if (command.query && command.query.$query) {\r\n    let result;\r\n    if (command.ns === 'admin.$cmd') {\r\n      // upconvert legacy command\r\n      result = Object.assign({}, command.query.$query);\r\n    } else {\r\n      // upconvert legacy find command\r\n      result = { find: collectionName(command) };\r\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\r\n        if (typeof command.query[key] !== 'undefined')\r\n          result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\r\n      });\r\n    }\r\n\r\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\r\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\r\n    });\r\n\r\n    OP_QUERY_KEYS.forEach(key => {\r\n      if (command[key]) result[key] = command[key];\r\n    });\r\n\r\n    if (typeof command.pre32Limit !== 'undefined') {\r\n      result.limit = command.pre32Limit;\r\n    }\r\n\r\n    if (command.query.$explain) {\r\n      return { explain: result };\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  return command.query ? command.query : command;\r\n};\r\n\r\nconst extractReply = (command, reply) => {\r\n  if (command instanceof GetMore) {\r\n    return {\r\n      ok: 1,\r\n      cursor: {\r\n        id: reply.message.cursorId,\r\n        ns: namespace(command),\r\n        nextBatch: reply.message.documents\r\n      }\r\n    };\r\n  }\r\n\r\n  if (command instanceof KillCursor) {\r\n    return {\r\n      ok: 1,\r\n      cursorsUnknown: command.cursorIds\r\n    };\r\n  }\r\n\r\n  // is this a legacy find command?\r\n  if (command.query && typeof command.query.$query !== 'undefined') {\r\n    return {\r\n      ok: 1,\r\n      cursor: {\r\n        id: reply.message.cursorId,\r\n        ns: namespace(command),\r\n        firstBatch: reply.message.documents\r\n      }\r\n    };\r\n  }\r\n\r\n  // in the event of a `noResponse` command, just return\r\n  if (reply === null) return reply;\r\n\r\n  return reply.result;\r\n};\r\n\r\n/** An event indicating the start of a given command */\r\nclass CommandStartedEvent {\r\n  /**\r\n   * Create a started event\r\n   *\r\n   * @param {Pool} pool the pool that originated the command\r\n   * @param {Object} command the command\r\n   */\r\n  constructor(pool, command) {\r\n    const cmd = extractCommand(command);\r\n    const commandName = extractCommandName(cmd);\r\n\r\n    // NOTE: remove in major revision, this is not spec behavior\r\n    if (SENSITIVE_COMMANDS.has(commandName)) {\r\n      this.commandObj = {};\r\n      this.commandObj[commandName] = true;\r\n    }\r\n\r\n    Object.assign(this, {\r\n      command: cmd,\r\n      databaseName: databaseName(command),\r\n      commandName,\r\n      requestId: command.requestId,\r\n      connectionId: generateConnectionId(pool)\r\n    });\r\n  }\r\n}\r\n\r\n/** An event indicating the success of a given command */\r\nclass CommandSucceededEvent {\r\n  /**\r\n   * Create a succeeded event\r\n   *\r\n   * @param {Pool} pool the pool that originated the command\r\n   * @param {Object} command the command\r\n   * @param {Object} reply the reply for this command from the server\r\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\r\n   */\r\n  constructor(pool, command, reply, started) {\r\n    const cmd = extractCommand(command);\r\n    const commandName = extractCommandName(cmd);\r\n\r\n    Object.assign(this, {\r\n      duration: calculateDurationInMs(started),\r\n      commandName,\r\n      reply: maybeRedact(commandName, extractReply(command, reply)),\r\n      requestId: command.requestId,\r\n      connectionId: generateConnectionId(pool)\r\n    });\r\n  }\r\n}\r\n\r\n/** An event indicating the failure of a given command */\r\nclass CommandFailedEvent {\r\n  /**\r\n   * Create a failure event\r\n   *\r\n   * @param {Pool} pool the pool that originated the command\r\n   * @param {Object} command the command\r\n   * @param {MongoError|Object} error the generated error or a server error response\r\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\r\n   */\r\n  constructor(pool, command, error, started) {\r\n    const cmd = extractCommand(command);\r\n    const commandName = extractCommandName(cmd);\r\n\r\n    Object.assign(this, {\r\n      duration: calculateDurationInMs(started),\r\n      commandName,\r\n      failure: maybeRedact(commandName, error),\r\n      requestId: command.requestId,\r\n      connectionId: generateConnectionId(pool)\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  CommandStartedEvent,\r\n  CommandSucceededEvent,\r\n  CommandFailedEvent\r\n};\r\n"]},"metadata":{},"sourceType":"script"}