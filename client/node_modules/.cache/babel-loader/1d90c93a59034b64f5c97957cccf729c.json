{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst crypto = require('crypto');\n\nconst debugOptions = require('./utils').debugOptions;\n\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\n\nconst decompress = require('../wireprotocol/compression').decompress;\n\nconst Response = require('./commands').Response;\n\nconst BinMsg = require('./msg').BinMsg;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoError = require('../error').MongoError;\n\nconst Logger = require('./logger');\n\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst Buffer = require('safe-buffer').Buffer;\n\nlet _id = 0;\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n/**\r\n * A class representing a single connection to a MongoDB server\r\n *\r\n * @fires Connection#connect\r\n * @fires Connection#close\r\n * @fires Connection#error\r\n * @fires Connection#timeout\r\n * @fires Connection#parseError\r\n * @fires Connection#message\r\n */\n\nclass Connection extends EventEmitter {\n  /**\r\n   * Creates a new Connection instance\r\n   *\r\n   * @param {Socket} socket The socket this connection wraps\r\n   * @param {Object} [options] Optional settings\r\n   * @param {string} [options.host] The host the socket is connected to\r\n   * @param {number} [options.port] The port used for the socket connection\r\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\r\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\r\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\r\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\r\n   */\n  constructor(socket, options) {\n    super();\n    options = options || {};\n\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000; // These values are inspected directly in tests, but maybe not necessary to keep around\n\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n    this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    } // Debug information\n\n\n    if (this.logger.isDebug()) {\n      this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);\n    } // Response options\n\n\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    }; // Flushing\n\n    this.flushing = false;\n    this.queue = []; // Internal state\n\n    this.writeStream = null;\n    this.destroyed = false; // Create hash method\n\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n    this.workItems = []; // setup socket\n\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n  /**\r\n   * Unref this connection\r\n   * @method\r\n   * @return {boolean}\r\n   */\n\n\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n  /**\r\n   * Destroy connection\r\n   * @method\r\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n  /**\r\n   * Write to connection\r\n   * @method\r\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\r\n   */\n\n\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++) this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    } // Double check that the connection is not destroyed\n\n\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      } // Iterate over all buffers and write them in order to the socket\n\n\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    } // Connection is destroyed return write failed\n\n\n    return false;\n  }\n  /**\r\n   * Return id of connection as a string\r\n   * @method\r\n   * @return {string}\r\n   */\n\n\n  toString() {\n    return '' + this.id;\n  }\n  /**\r\n   * Return json object of connection\r\n   * @method\r\n   * @return {object}\r\n   */\n\n\n  toJSON() {\n    return {\n      id: this.id,\n      host: this.host,\n      port: this.port\n    };\n  }\n  /**\r\n   * Is the connection connected\r\n   * @method\r\n   * @return {boolean}\r\n   */\n\n\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n\n}\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id); // Debug information\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.emit('timeout', new MongoNetworkError(`connection ${conn.id} to ${conn.address} timed out`), conn);\n  };\n}\n\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);\n    }\n  };\n} // Handle a message once it is received\n\n\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\n\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          conn.bytesRead = conn.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          const emitBuffer = conn.buffer; // Reset state of buffer\n\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            conn.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, conn.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(conn.buffer, 0); // Update bytes read\n\n              conn.bytesRead = data.length; // Update sizeOfMessage\n\n              conn.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              const emitBuffer = data; // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn); // Clear out the state of the parser\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(conn.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Connection#connect\r\n * @type {Connection}\r\n */\n\n/**\r\n * The server connection closed, all pool connections closed\r\n *\r\n * @event Connection#close\r\n * @type {Connection}\r\n */\n\n/**\r\n * The server connection caused an error, all pool connections closed\r\n *\r\n * @event Connection#error\r\n * @type {Connection}\r\n */\n\n/**\r\n * The server connection timed out, all pool connections closed\r\n *\r\n * @event Connection#timeout\r\n * @type {Connection}\r\n */\n\n/**\r\n * The driver experienced an invalid message, all pool connections closed\r\n *\r\n * @event Connection#parseError\r\n * @type {Connection}\r\n */\n\n/**\r\n * An event emitted each time the connection receives a parsed message from the wire\r\n *\r\n * @event Connection#message\r\n * @type {Connection}\r\n */\n\n\nmodule.exports = Connection;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/connection/connection.js"],"names":["EventEmitter","require","crypto","debugOptions","parseHeader","decompress","Response","BinMsg","MongoNetworkError","MongoError","Logger","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","Buffer","_id","DEFAULT_MAX_BSON_MESSAGE_SIZE","DEBUG_FIELDS","connectionAccountingSpy","undefined","connectionAccounting","connections","Connection","constructor","socket","options","bson","TypeError","id","logger","tag","maxBsonMessageSize","port","host","socketTimeout","keepAlive","keepAliveInitialDelay","connectionTimeout","Math","round","isDebug","debug","JSON","stringify","responseOptions","promoteLongs","promoteValues","promoteBuffers","flushing","queue","writeStream","destroyed","hash","createHash","update","address","hashedName","digest","workItems","once","errorHandler","timeoutHandler","closeHandler","on","dataHandler","addConnection","setSocketTimeout","value","setTimeout","resetSocketTimeout","enableConnectionAccounting","spy","disableConnectionAccounting","unref","destroy","callback","Object","assign","force","deleteConnection","end","err","write","buffer","Array","isArray","toString","i","length","toJSON","isConnected","writable","connection","conn","emit","hadError","processMessage","message","msgHeader","opCode","ResponseConstructor","slice","fromCompressed","index","readInt32LE","compressorID","decompressedMsgBody","data","bytesRead","sizeOfMessage","remainingBytesToRead","copy","alloc","emitBuffer","stubBuffer","newData","newStubBuffer","errorObject","trace","bin","parseState","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst crypto = require('crypto');\r\nconst debugOptions = require('./utils').debugOptions;\r\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\r\nconst decompress = require('../wireprotocol/compression').decompress;\r\nconst Response = require('./commands').Response;\r\nconst BinMsg = require('./msg').BinMsg;\r\nconst MongoNetworkError = require('../error').MongoNetworkError;\r\nconst MongoError = require('../error').MongoError;\r\nconst Logger = require('./logger');\r\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\r\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\r\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\r\nconst Buffer = require('safe-buffer').Buffer;\r\n\r\nlet _id = 0;\r\n\r\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\r\nconst DEBUG_FIELDS = [\r\n  'host',\r\n  'port',\r\n  'size',\r\n  'keepAlive',\r\n  'keepAliveInitialDelay',\r\n  'noDelay',\r\n  'connectionTimeout',\r\n  'socketTimeout',\r\n  'ssl',\r\n  'ca',\r\n  'crl',\r\n  'cert',\r\n  'rejectUnauthorized',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'checkServerIdentity'\r\n];\r\n\r\nlet connectionAccountingSpy = undefined;\r\nlet connectionAccounting = false;\r\nlet connections = {};\r\n\r\n/**\r\n * A class representing a single connection to a MongoDB server\r\n *\r\n * @fires Connection#connect\r\n * @fires Connection#close\r\n * @fires Connection#error\r\n * @fires Connection#timeout\r\n * @fires Connection#parseError\r\n * @fires Connection#message\r\n */\r\nclass Connection extends EventEmitter {\r\n  /**\r\n   * Creates a new Connection instance\r\n   *\r\n   * @param {Socket} socket The socket this connection wraps\r\n   * @param {Object} [options] Optional settings\r\n   * @param {string} [options.host] The host the socket is connected to\r\n   * @param {number} [options.port] The port used for the socket connection\r\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\r\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\r\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\r\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\r\n   */\r\n  constructor(socket, options) {\r\n    super();\r\n\r\n    options = options || {};\r\n    if (!options.bson) {\r\n      throw new TypeError('must pass in valid bson parser');\r\n    }\r\n\r\n    this.id = _id++;\r\n    this.options = options;\r\n    this.logger = Logger('Connection', options);\r\n    this.bson = options.bson;\r\n    this.tag = options.tag;\r\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\r\n\r\n    this.port = options.port || 27017;\r\n    this.host = options.host || 'localhost';\r\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\r\n\r\n    // These values are inspected directly in tests, but maybe not necessary to keep around\r\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\r\n    this.keepAliveInitialDelay =\r\n      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\r\n    this.connectionTimeout =\r\n      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\r\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\r\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\r\n    }\r\n\r\n    // Debug information\r\n    if (this.logger.isDebug()) {\r\n      this.logger.debug(\r\n        `creating connection ${this.id} with options [${JSON.stringify(\r\n          debugOptions(DEBUG_FIELDS, options)\r\n        )}]`\r\n      );\r\n    }\r\n\r\n    // Response options\r\n    this.responseOptions = {\r\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\r\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\r\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\r\n    };\r\n\r\n    // Flushing\r\n    this.flushing = false;\r\n    this.queue = [];\r\n\r\n    // Internal state\r\n    this.writeStream = null;\r\n    this.destroyed = false;\r\n\r\n    // Create hash method\r\n    const hash = crypto.createHash('sha1');\r\n    hash.update(this.address);\r\n    this.hashedName = hash.digest('hex');\r\n\r\n    // All operations in flight on the connection\r\n    this.workItems = [];\r\n\r\n    // setup socket\r\n    this.socket = socket;\r\n    this.socket.once('error', errorHandler(this));\r\n    this.socket.once('timeout', timeoutHandler(this));\r\n    this.socket.once('close', closeHandler(this));\r\n    this.socket.on('data', dataHandler(this));\r\n\r\n    if (connectionAccounting) {\r\n      addConnection(this.id, this);\r\n    }\r\n  }\r\n\r\n  setSocketTimeout(value) {\r\n    if (this.socket) {\r\n      this.socket.setTimeout(value);\r\n    }\r\n  }\r\n\r\n  resetSocketTimeout() {\r\n    if (this.socket) {\r\n      this.socket.setTimeout(this.socketTimeout);\r\n    }\r\n  }\r\n\r\n  static enableConnectionAccounting(spy) {\r\n    if (spy) {\r\n      connectionAccountingSpy = spy;\r\n    }\r\n\r\n    connectionAccounting = true;\r\n    connections = {};\r\n  }\r\n\r\n  static disableConnectionAccounting() {\r\n    connectionAccounting = false;\r\n    connectionAccountingSpy = undefined;\r\n  }\r\n\r\n  static connections() {\r\n    return connections;\r\n  }\r\n\r\n  get address() {\r\n    return `${this.host}:${this.port}`;\r\n  }\r\n\r\n  /**\r\n   * Unref this connection\r\n   * @method\r\n   * @return {boolean}\r\n   */\r\n  unref() {\r\n    if (this.socket == null) {\r\n      this.once('connect', () => this.socket.unref());\r\n      return;\r\n    }\r\n\r\n    this.socket.unref();\r\n  }\r\n\r\n  /**\r\n   * Destroy connection\r\n   * @method\r\n   */\r\n  destroy(options, callback) {\r\n    if (typeof options === 'function') {\r\n      callback = options;\r\n      options = {};\r\n    }\r\n\r\n    options = Object.assign({ force: false }, options);\r\n\r\n    if (connectionAccounting) {\r\n      deleteConnection(this.id);\r\n    }\r\n\r\n    if (this.socket == null) {\r\n      this.destroyed = true;\r\n      return;\r\n    }\r\n\r\n    if (options.force) {\r\n      this.socket.destroy();\r\n      this.destroyed = true;\r\n      if (typeof callback === 'function') callback(null, null);\r\n      return;\r\n    }\r\n\r\n    this.socket.end(err => {\r\n      this.destroyed = true;\r\n      if (typeof callback === 'function') callback(err, null);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Write to connection\r\n   * @method\r\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\r\n   */\r\n  write(buffer) {\r\n    // Debug Log\r\n    if (this.logger.isDebug()) {\r\n      if (!Array.isArray(buffer)) {\r\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\r\n      } else {\r\n        for (let i = 0; i < buffer.length; i++)\r\n          this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\r\n      }\r\n    }\r\n\r\n    // Double check that the connection is not destroyed\r\n    if (this.socket.destroyed === false) {\r\n      // Write out the command\r\n      if (!Array.isArray(buffer)) {\r\n        this.socket.write(buffer, 'binary');\r\n        return true;\r\n      }\r\n\r\n      // Iterate over all buffers and write them in order to the socket\r\n      for (let i = 0; i < buffer.length; i++) {\r\n        this.socket.write(buffer[i], 'binary');\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    // Connection is destroyed return write failed\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return id of connection as a string\r\n   * @method\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return '' + this.id;\r\n  }\r\n\r\n  /**\r\n   * Return json object of connection\r\n   * @method\r\n   * @return {object}\r\n   */\r\n  toJSON() {\r\n    return { id: this.id, host: this.host, port: this.port };\r\n  }\r\n\r\n  /**\r\n   * Is the connection connected\r\n   * @method\r\n   * @return {boolean}\r\n   */\r\n  isConnected() {\r\n    if (this.destroyed) return false;\r\n    return !this.socket.destroyed && this.socket.writable;\r\n  }\r\n}\r\n\r\nfunction deleteConnection(id) {\r\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\r\n  delete connections[id];\r\n\r\n  if (connectionAccountingSpy) {\r\n    connectionAccountingSpy.deleteConnection(id);\r\n  }\r\n}\r\n\r\nfunction addConnection(id, connection) {\r\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\r\n  connections[id] = connection;\r\n\r\n  if (connectionAccountingSpy) {\r\n    connectionAccountingSpy.addConnection(id, connection);\r\n  }\r\n}\r\n\r\n//\r\n// Connection handlers\r\nfunction errorHandler(conn) {\r\n  return function(err) {\r\n    if (connectionAccounting) deleteConnection(conn.id);\r\n    // Debug information\r\n    if (conn.logger.isDebug()) {\r\n      conn.logger.debug(\r\n        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`\r\n      );\r\n    }\r\n\r\n    conn.emit('error', new MongoNetworkError(err), conn);\r\n  };\r\n}\r\n\r\nfunction timeoutHandler(conn) {\r\n  return function() {\r\n    if (connectionAccounting) deleteConnection(conn.id);\r\n\r\n    if (conn.logger.isDebug()) {\r\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\r\n    }\r\n\r\n    conn.emit(\r\n      'timeout',\r\n      new MongoNetworkError(`connection ${conn.id} to ${conn.address} timed out`),\r\n      conn\r\n    );\r\n  };\r\n}\r\n\r\nfunction closeHandler(conn) {\r\n  return function(hadError) {\r\n    if (connectionAccounting) deleteConnection(conn.id);\r\n\r\n    if (conn.logger.isDebug()) {\r\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\r\n    }\r\n\r\n    if (!hadError) {\r\n      conn.emit(\r\n        'close',\r\n        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),\r\n        conn\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n// Handle a message once it is received\r\nfunction processMessage(conn, message) {\r\n  const msgHeader = parseHeader(message);\r\n  if (msgHeader.opCode !== OP_COMPRESSED) {\r\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\r\n    conn.emit(\r\n      'message',\r\n      new ResponseConstructor(\r\n        conn.bson,\r\n        message,\r\n        msgHeader,\r\n        message.slice(MESSAGE_HEADER_SIZE),\r\n        conn.responseOptions\r\n      ),\r\n      conn\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  msgHeader.fromCompressed = true;\r\n  let index = MESSAGE_HEADER_SIZE;\r\n  msgHeader.opCode = message.readInt32LE(index);\r\n  index += 4;\r\n  msgHeader.length = message.readInt32LE(index);\r\n  index += 4;\r\n  const compressorID = message[index];\r\n  index++;\r\n\r\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\r\n    if (err) {\r\n      conn.emit('error', err);\r\n      return;\r\n    }\r\n\r\n    if (decompressedMsgBody.length !== msgHeader.length) {\r\n      conn.emit(\r\n        'error',\r\n        new MongoError(\r\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\r\n        )\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\r\n    conn.emit(\r\n      'message',\r\n      new ResponseConstructor(\r\n        conn.bson,\r\n        message,\r\n        msgHeader,\r\n        decompressedMsgBody,\r\n        conn.responseOptions\r\n      ),\r\n      conn\r\n    );\r\n  });\r\n}\r\n\r\nfunction dataHandler(conn) {\r\n  return function(data) {\r\n    // Parse until we are done with the data\r\n    while (data.length > 0) {\r\n      // If we still have bytes to read on the current message\r\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\r\n        // Calculate the amount of remaining bytes\r\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\r\n        // Check if the current chunk contains the rest of the message\r\n        if (remainingBytesToRead > data.length) {\r\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\r\n          data.copy(conn.buffer, conn.bytesRead);\r\n          // Adjust the number of bytes read so it point to the correct index in the buffer\r\n          conn.bytesRead = conn.bytesRead + data.length;\r\n\r\n          // Reset state of buffer\r\n          data = Buffer.alloc(0);\r\n        } else {\r\n          // Copy the missing part of the data into our current buffer\r\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\r\n          // Slice the overflow into a new buffer that we will then re-parse\r\n          data = data.slice(remainingBytesToRead);\r\n\r\n          // Emit current complete message\r\n          const emitBuffer = conn.buffer;\r\n          // Reset state of buffer\r\n          conn.buffer = null;\r\n          conn.sizeOfMessage = 0;\r\n          conn.bytesRead = 0;\r\n          conn.stubBuffer = null;\r\n\r\n          processMessage(conn, emitBuffer);\r\n        }\r\n      } else {\r\n        // Stub buffer is kept in case we don't get enough bytes to determine the\r\n        // size of the message (< 4 bytes)\r\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\r\n          // If we have enough bytes to determine the message size let's do it\r\n          if (conn.stubBuffer.length + data.length > 4) {\r\n            // Prepad the data\r\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\r\n            conn.stubBuffer.copy(newData, 0);\r\n            data.copy(newData, conn.stubBuffer.length);\r\n            // Reassign for parsing\r\n            data = newData;\r\n\r\n            // Reset state of buffer\r\n            conn.buffer = null;\r\n            conn.sizeOfMessage = 0;\r\n            conn.bytesRead = 0;\r\n            conn.stubBuffer = null;\r\n          } else {\r\n            // Add the the bytes to the stub buffer\r\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\r\n            // Copy existing stub buffer\r\n            conn.stubBuffer.copy(newStubBuffer, 0);\r\n            // Copy missing part of the data\r\n            data.copy(newStubBuffer, conn.stubBuffer.length);\r\n            // Exit parsing loop\r\n            data = Buffer.alloc(0);\r\n          }\r\n        } else {\r\n          if (data.length > 4) {\r\n            // Retrieve the message size\r\n            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\r\n            // If we have a negative sizeOfMessage emit error and return\r\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\r\n              const errorObject = {\r\n                err: 'socketHandler',\r\n                trace: '',\r\n                bin: conn.buffer,\r\n                parseState: {\r\n                  sizeOfMessage: sizeOfMessage,\r\n                  bytesRead: conn.bytesRead,\r\n                  stubBuffer: conn.stubBuffer\r\n                }\r\n              };\r\n              // We got a parse Error fire it off then keep going\r\n              conn.emit('parseError', errorObject, conn);\r\n              return;\r\n            }\r\n\r\n            // Ensure that the size of message is larger than 0 and less than the max allowed\r\n            if (\r\n              sizeOfMessage > 4 &&\r\n              sizeOfMessage < conn.maxBsonMessageSize &&\r\n              sizeOfMessage > data.length\r\n            ) {\r\n              conn.buffer = Buffer.alloc(sizeOfMessage);\r\n              // Copy all the data into the buffer\r\n              data.copy(conn.buffer, 0);\r\n              // Update bytes read\r\n              conn.bytesRead = data.length;\r\n              // Update sizeOfMessage\r\n              conn.sizeOfMessage = sizeOfMessage;\r\n              // Ensure stub buffer is null\r\n              conn.stubBuffer = null;\r\n              // Exit parsing loop\r\n              data = Buffer.alloc(0);\r\n            } else if (\r\n              sizeOfMessage > 4 &&\r\n              sizeOfMessage < conn.maxBsonMessageSize &&\r\n              sizeOfMessage === data.length\r\n            ) {\r\n              const emitBuffer = data;\r\n              // Reset state of buffer\r\n              conn.buffer = null;\r\n              conn.sizeOfMessage = 0;\r\n              conn.bytesRead = 0;\r\n              conn.stubBuffer = null;\r\n              // Exit parsing loop\r\n              data = Buffer.alloc(0);\r\n              // Emit the message\r\n              processMessage(conn, emitBuffer);\r\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\r\n              const errorObject = {\r\n                err: 'socketHandler',\r\n                trace: null,\r\n                bin: data,\r\n                parseState: {\r\n                  sizeOfMessage: sizeOfMessage,\r\n                  bytesRead: 0,\r\n                  buffer: null,\r\n                  stubBuffer: null\r\n                }\r\n              };\r\n              // We got a parse Error fire it off then keep going\r\n              conn.emit('parseError', errorObject, conn);\r\n\r\n              // Clear out the state of the parser\r\n              conn.buffer = null;\r\n              conn.sizeOfMessage = 0;\r\n              conn.bytesRead = 0;\r\n              conn.stubBuffer = null;\r\n              // Exit parsing loop\r\n              data = Buffer.alloc(0);\r\n            } else {\r\n              const emitBuffer = data.slice(0, sizeOfMessage);\r\n              // Reset state of buffer\r\n              conn.buffer = null;\r\n              conn.sizeOfMessage = 0;\r\n              conn.bytesRead = 0;\r\n              conn.stubBuffer = null;\r\n              // Copy rest of message\r\n              data = data.slice(sizeOfMessage);\r\n              // Emit the message\r\n              processMessage(conn, emitBuffer);\r\n            }\r\n          } else {\r\n            // Create a buffer that contains the space for the non-complete message\r\n            conn.stubBuffer = Buffer.alloc(data.length);\r\n            // Copy the data to the stub buffer\r\n            data.copy(conn.stubBuffer, 0);\r\n            // Exit parsing loop\r\n            data = Buffer.alloc(0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Connection#connect\r\n * @type {Connection}\r\n */\r\n\r\n/**\r\n * The server connection closed, all pool connections closed\r\n *\r\n * @event Connection#close\r\n * @type {Connection}\r\n */\r\n\r\n/**\r\n * The server connection caused an error, all pool connections closed\r\n *\r\n * @event Connection#error\r\n * @type {Connection}\r\n */\r\n\r\n/**\r\n * The server connection timed out, all pool connections closed\r\n *\r\n * @event Connection#timeout\r\n * @type {Connection}\r\n */\r\n\r\n/**\r\n * The driver experienced an invalid message, all pool connections closed\r\n *\r\n * @event Connection#parseError\r\n * @type {Connection}\r\n */\r\n\r\n/**\r\n * An event emitted each time the connection receives a parsed message from the wire\r\n *\r\n * @event Connection#message\r\n * @type {Connection}\r\n */\r\n\r\nmodule.exports = Connection;\r\n"]},"metadata":{},"sourceType":"script"}