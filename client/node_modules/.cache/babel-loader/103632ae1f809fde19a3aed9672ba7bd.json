{"ast":null,"code":"'use strict';\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst Aspect = require('./operation').Aspect;\n\nconst deprecate = require('util').deprecate;\n\nconst Logger = require('../core').Logger;\n\nconst MongoCredentials = require('../core').MongoCredentials;\n\nconst MongoError = require('../core').MongoError;\n\nconst Mongos = require('../topologies/mongos');\n\nconst NativeTopology = require('../topologies/native_topology');\n\nconst parse = require('../core').parseConnectionString;\n\nconst ReadConcern = require('../read_concern');\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst ReplSet = require('../topologies/replset');\n\nconst Server = require('../topologies/server');\n\nconst ServerSessionPool = require('../core').Sessions.ServerSessionPool;\n\nlet client;\n\nfunction loadClient() {\n  if (!client) {\n    client = require('../mongo_client');\n  }\n\n  return client;\n}\n\nconst legacyParse = deprecate(require('../url_parser'), 'current URL string parser is deprecated, and will be removed in a future version. ' + 'To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.');\nconst AUTH_MECHANISM_INTERNAL_MAP = {\n  DEFAULT: 'default',\n  'MONGODB-CR': 'mongocr',\n  PLAIN: 'plain',\n  'MONGODB-X509': 'x509',\n  'SCRAM-SHA-1': 'scram-sha-1',\n  'SCRAM-SHA-256': 'scram-sha-256'\n};\nconst monitoringEvents = ['timeout', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup', 'open'];\nconst VALID_AUTH_MECHANISMS = new Set(['DEFAULT', 'MONGODB-CR', 'PLAIN', 'MONGODB-X509', 'SCRAM-SHA-1', 'SCRAM-SHA-256', 'GSSAPI']);\nconst validOptionNames = ['poolSize', 'ssl', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'sslCRL', 'autoReconnect', 'noDelay', 'keepAlive', 'keepAliveInitialDelay', 'connectTimeoutMS', 'family', 'socketTimeoutMS', 'reconnectTries', 'reconnectInterval', 'ha', 'haInterval', 'replicaSet', 'secondaryAcceptableLatencyMS', 'acceptableLatencyMS', 'connectWithNoPrimary', 'authSource', 'w', 'wtimeout', 'j', 'forceServerObjectId', 'serializeFunctions', 'ignoreUndefined', 'raw', 'bufferMaxEntries', 'readPreference', 'pkFactory', 'promiseLibrary', 'readConcern', 'maxStalenessSeconds', 'loggerLevel', 'logger', 'promoteValues', 'promoteBuffers', 'promoteLongs', 'domainsEnabled', 'checkServerIdentity', 'validateOptions', 'appname', 'auth', 'user', 'password', 'authMechanism', 'compression', 'fsync', 'readPreferenceTags', 'numberOfRetries', 'auto_reconnect', 'minSize', 'monitorCommands', 'retryWrites', 'retryReads', 'useNewUrlParser', 'useUnifiedTopology', 'serverSelectionTimeoutMS', 'useRecoveryToken', 'autoEncryption'];\nconst ignoreOptionNames = ['native_parser'];\nconst legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db']; // Validate options object\n\nfunction validOptions(options) {\n  const _validOptions = validOptionNames.concat(legacyOptionNames);\n\n  for (const name in options) {\n    if (ignoreOptionNames.indexOf(name) !== -1) {\n      continue;\n    }\n\n    if (_validOptions.indexOf(name) === -1) {\n      if (options.validateOptions) {\n        return new MongoError(`option ${name} is not supported`);\n      } else {\n        console.warn(`the options [${name}] is not supported`);\n      }\n    }\n\n    if (legacyOptionNames.indexOf(name) !== -1) {\n      console.warn(`the server/replset/mongos/db options are deprecated, ` + `all their options are supported at the top level of the options object [${validOptionNames}]`);\n    }\n  }\n}\n\nconst LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {\n  obj[name.toLowerCase()] = name;\n  return obj;\n}, {});\n\nclass ConnectOperation extends OperationBase {\n  constructor(mongoClient) {\n    super();\n    this.mongoClient = mongoClient;\n  }\n\n  execute(callback) {\n    const mongoClient = this.mongoClient;\n    const err = validOptions(mongoClient.s.options); // Did we have a validation error\n\n    if (err) return callback(err); // Fallback to callback based connect\n\n    connect(mongoClient, mongoClient.s.url, mongoClient.s.options, err => {\n      if (err) return callback(err);\n      callback(null, mongoClient);\n    });\n  }\n\n}\n\ndefineAspects(ConnectOperation, [Aspect.SKIP_SESSION]);\n\nfunction addListeners(mongoClient, topology) {\n  topology.on('authenticated', createListener(mongoClient, 'authenticated'));\n  topology.on('error', createListener(mongoClient, 'error'));\n  topology.on('timeout', createListener(mongoClient, 'timeout'));\n  topology.on('close', createListener(mongoClient, 'close'));\n  topology.on('parseError', createListener(mongoClient, 'parseError'));\n  topology.once('open', createListener(mongoClient, 'open'));\n  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));\n  topology.once('all', createListener(mongoClient, 'all'));\n  topology.on('reconnect', createListener(mongoClient, 'reconnect'));\n}\n\nfunction assignTopology(client, topology) {\n  client.topology = topology;\n  topology.s.sessionPool = topology instanceof NativeTopology ? new ServerSessionPool(topology) : new ServerSessionPool(topology.s.coreTopology);\n} // Clear out all events\n\n\nfunction clearAllEvents(topology) {\n  monitoringEvents.forEach(event => topology.removeAllListeners(event));\n} // Collect all events in order from SDAM\n\n\nfunction collectEvents(mongoClient, topology) {\n  let MongoClient = loadClient();\n  const collectedEvents = [];\n\n  if (mongoClient instanceof MongoClient) {\n    monitoringEvents.forEach(event => {\n      topology.on(event, (object1, object2) => {\n        if (event === 'open') {\n          collectedEvents.push({\n            event: event,\n            object1: mongoClient\n          });\n        } else {\n          collectedEvents.push({\n            event: event,\n            object1: object1,\n            object2: object2\n          });\n        }\n      });\n    });\n  }\n\n  return collectedEvents;\n}\n\nconst emitDeprecationForNonUnifiedTopology = deprecate(() => {}, 'current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. ' + 'To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.');\n\nfunction connect(mongoClient, url, options, callback) {\n  options = Object.assign({}, options); // If callback is null throw an exception\n\n  if (callback == null) {\n    throw new Error('no callback function provided');\n  }\n\n  let didRequestAuthentication = false;\n  const logger = Logger('MongoClient', options); // Did we pass in a Server/ReplSet/Mongos\n\n  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {\n    return connectWithUrl(mongoClient, url, options, connectCallback);\n  }\n\n  const parseFn = options.useNewUrlParser ? parse : legacyParse;\n  const transform = options.useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;\n  parseFn(url, options, (err, _object) => {\n    // Do not attempt to connect if parsing error\n    if (err) return callback(err); // Flatten\n\n    const object = transform(_object); // Parse the string\n\n    const _finalOptions = createUnifiedOptions(object, options); // Check if we have connection and socket timeout set\n\n\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 360000;\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;\n    if (_finalOptions.retryWrites == null) _finalOptions.retryWrites = true;\n    if (_finalOptions.useRecoveryToken == null) _finalOptions.useRecoveryToken = true;\n\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\n      delete _finalOptions.db_options.auth;\n    } // Store the merged options object\n\n\n    mongoClient.s.options = _finalOptions; // Failure modes\n\n    if (object.servers.length === 0) {\n      return callback(new Error('connection string must contain at least one seed host'));\n    }\n\n    if (_finalOptions.auth && !_finalOptions.credentials) {\n      try {\n        didRequestAuthentication = true;\n        _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    if (_finalOptions.useUnifiedTopology) {\n      return createTopology(mongoClient, 'unified', _finalOptions, connectCallback);\n    }\n\n    emitDeprecationForNonUnifiedTopology(); // Do we have a replicaset then skip discovery and go straight to connectivity\n\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\n      return createTopology(mongoClient, 'replicaset', _finalOptions, connectCallback);\n    } else if (object.servers.length > 1) {\n      return createTopology(mongoClient, 'mongos', _finalOptions, connectCallback);\n    } else {\n      return createServer(mongoClient, _finalOptions, connectCallback);\n    }\n  });\n\n  function connectCallback(err, topology) {\n    const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;\n\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      } // Return a more specific error message for MongoClient.connect\n\n\n      return callback(new MongoError(warningMessage));\n    }\n\n    if (didRequestAuthentication) {\n      mongoClient.emit('authenticated', null, true);\n    } // Return the error and db instance\n\n\n    callback(err, topology);\n  }\n}\n\nfunction connectWithUrl(mongoClient, url, options, connectCallback) {\n  // Set the topology\n  assignTopology(mongoClient, url); // Add listeners\n\n  addListeners(mongoClient, url); // Propagate the events to the client\n\n  relayEvents(mongoClient, url);\n  let finalOptions = Object.assign({}, options); // If we have a readPreference passed in by the db options, convert it from a string\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  }\n\n  const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;\n\n  if (isDoingAuth && !finalOptions.credentials) {\n    try {\n      finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);\n    } catch (err) {\n      return connectCallback(err, url);\n    }\n  }\n\n  return url.connect(finalOptions, connectCallback);\n}\n\nfunction createListener(mongoClient, event) {\n  const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);\n  return (v1, v2) => {\n    if (eventSet.has(event)) {\n      return mongoClient.emit(event, mongoClient);\n    }\n\n    mongoClient.emit(event, v1, v2);\n  };\n}\n\nfunction createServer(mongoClient, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary; // Set default options\n\n  const servers = translateOptions(options);\n  const server = servers[0]; // Propagate the events to the client\n\n  const collectedEvents = collectEvents(mongoClient, server); // Connect to topology\n\n  server.connect(options, (err, topology) => {\n    if (err) {\n      server.close(true);\n      return callback(err);\n    } // Clear out all the collected event listeners\n\n\n    clearAllEvents(server); // Relay all the events\n\n    relayEvents(mongoClient, server); // Add listeners\n\n    addListeners(mongoClient, server); // Check if we are really speaking to a mongos\n\n    const ismaster = topology.lastIsMaster(); // Set the topology\n\n    assignTopology(mongoClient, topology); // Do we actually have a mongos\n\n    if (ismaster && ismaster.msg === 'isdbgrid') {\n      // Destroy the current connection\n      topology.close(); // Create mongos connection instead\n\n      return createTopology(mongoClient, 'mongos', options, callback);\n    } // Fire all the events\n\n\n    replayEvents(mongoClient, collectedEvents); // Otherwise callback\n\n    callback(err, topology);\n  });\n}\n\nfunction createTopology(mongoClient, topologyType, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\n  const translationOptions = {};\n  if (topologyType === 'unified') translationOptions.createServers = false; // Set default options\n\n  const servers = translateOptions(options, translationOptions); // Create the topology\n\n  let topology;\n\n  if (topologyType === 'mongos') {\n    topology = new Mongos(servers, options);\n  } else if (topologyType === 'replicaset') {\n    topology = new ReplSet(servers, options);\n  } else if (topologyType === 'unified') {\n    topology = new NativeTopology(options.servers, options);\n  } // Add listeners\n\n\n  addListeners(mongoClient, topology); // Propagate the events to the client\n\n  relayEvents(mongoClient, topology); // Open the connection\n\n  topology.connect(options, (err, newTopology) => {\n    if (err) {\n      topology.close(true);\n      return callback(err);\n    }\n\n    assignTopology(mongoClient, newTopology);\n\n    if (options.autoEncryption == null) {\n      callback(null, newTopology);\n      return;\n    } // setup for client side encryption\n\n\n    let AutoEncrypter;\n\n    try {\n      require.resolve('mongodb-client-encryption');\n    } catch (err) {\n      callback(new MongoError('Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project'));\n      return;\n    }\n\n    try {\n      AutoEncrypter = require('mongodb-client-encryption')(require('../../index')).AutoEncrypter;\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    const mongoCryptOptions = Object.assign({}, options.autoEncryption);\n    topology.s.options.autoEncrypter = new AutoEncrypter(mongoClient, mongoCryptOptions);\n    topology.s.options.autoEncrypter.init(err => {\n      if (err) return callback(err, null);\n      callback(null, newTopology);\n    });\n  });\n}\n\nfunction createUnifiedOptions(finalOptions, options) {\n  const childOptions = ['mongos', 'server', 'db', 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];\n  const noMerge = ['readconcern', 'compression'];\n\n  for (const name in options) {\n    if (noMerge.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions[name] = options[name];\n    } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions = mergeOptions(finalOptions, options[name], false);\n    } else {\n      if (options[name] && typeof options[name] === 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {\n        finalOptions = mergeOptions(finalOptions, options[name], true);\n      } else {\n        finalOptions[name] = options[name];\n      }\n    }\n  }\n\n  return finalOptions;\n}\n\nfunction generateCredentials(client, username, password, options) {\n  options = Object.assign({}, options); // the default db to authenticate against is 'self'\n  // if authententicate is called from a retry context, it may be another one, like admin\n\n  const source = options.authSource || options.authdb || options.dbName; // authMechanism\n\n  const authMechanismRaw = options.authMechanism || 'DEFAULT';\n  const authMechanism = authMechanismRaw.toUpperCase();\n\n  if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {\n    throw MongoError.create({\n      message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,\n      driver: true\n    });\n  }\n\n  if (authMechanism === 'GSSAPI') {\n    return new MongoCredentials({\n      mechanism: process.platform === 'win32' ? 'sspi' : 'gssapi',\n      mechanismProperties: options,\n      source,\n      username,\n      password\n    });\n  }\n\n  return new MongoCredentials({\n    mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],\n    source,\n    username,\n    password\n  });\n}\n\nfunction legacyTransformUrlOptions(object) {\n  return mergeOptions(createUnifiedOptions({}, object), object, false);\n}\n\nfunction mergeOptions(target, source, flatten) {\n  for (const name in source) {\n    if (source[name] && typeof source[name] === 'object' && flatten) {\n      target = mergeOptions(target, source[name], flatten);\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n}\n\nfunction relayEvents(mongoClient, topology) {\n  const serverOrCommandEvents = ['serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha'];\n  serverOrCommandEvents.forEach(event => {\n    topology.on(event, (object1, object2) => {\n      mongoClient.emit(event, object1, object2);\n    });\n  });\n} //\n// Replay any events due to single server connection switching to Mongos\n//\n\n\nfunction replayEvents(mongoClient, events) {\n  for (let i = 0; i < events.length; i++) {\n    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);\n  }\n}\n\nfunction transformUrlOptions(_object) {\n  let object = Object.assign({\n    servers: _object.hosts\n  }, _object.options);\n\n  for (let name in object) {\n    const camelCaseName = LEGACY_OPTIONS_MAP[name];\n\n    if (camelCaseName) {\n      object[camelCaseName] = object[name];\n    }\n  }\n\n  const hasUsername = _object.auth && _object.auth.username;\n  const hasAuthMechanism = _object.options && _object.options.authMechanism;\n\n  if (hasUsername || hasAuthMechanism) {\n    object.auth = Object.assign({}, _object.auth);\n\n    if (object.auth.db) {\n      object.authSource = object.authSource || object.auth.db;\n    }\n\n    if (object.auth.username) {\n      object.auth.user = object.auth.username;\n    }\n  }\n\n  if (_object.defaultDatabase) {\n    object.dbName = _object.defaultDatabase;\n  }\n\n  if (object.maxpoolsize) {\n    object.poolSize = object.maxpoolsize;\n  }\n\n  if (object.readconcernlevel) {\n    object.readConcern = new ReadConcern(object.readconcernlevel);\n  }\n\n  if (object.wtimeoutms) {\n    object.wtimeout = object.wtimeoutms;\n  }\n\n  if (_object.srvHost) {\n    object.srvHost = _object.srvHost;\n  }\n\n  return object;\n}\n\nfunction translateOptions(options, translationOptions) {\n  translationOptions = Object.assign({}, {\n    createServers: true\n  }, translationOptions); // If we have a readPreference passed in by the db options\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  } // Do we have readPreference tags, add them\n\n\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\n  } // Do we have maxStalenessSeconds\n\n\n  if (options.maxStalenessSeconds) {\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\n  } // Set the socket and connection timeouts\n\n\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 360000;\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;\n\n  if (!translationOptions.createServers) {\n    return;\n  } // Create server instances\n\n\n  return options.servers.map(serverObj => {\n    return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);\n  });\n}\n\nmodule.exports = ConnectOperation;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/connect.js"],"names":["OperationBase","require","defineAspects","Aspect","deprecate","Logger","MongoCredentials","MongoError","Mongos","NativeTopology","parse","parseConnectionString","ReadConcern","ReadPreference","ReplSet","Server","ServerSessionPool","Sessions","client","loadClient","legacyParse","AUTH_MECHANISM_INTERNAL_MAP","DEFAULT","PLAIN","monitoringEvents","VALID_AUTH_MECHANISMS","Set","validOptionNames","ignoreOptionNames","legacyOptionNames","validOptions","options","_validOptions","concat","name","indexOf","validateOptions","console","warn","LEGACY_OPTIONS_MAP","reduce","obj","toLowerCase","ConnectOperation","constructor","mongoClient","execute","callback","err","s","connect","url","SKIP_SESSION","addListeners","topology","on","createListener","once","assignTopology","sessionPool","coreTopology","clearAllEvents","forEach","event","removeAllListeners","collectEvents","MongoClient","collectedEvents","object1","object2","push","emitDeprecationForNonUnifiedTopology","Object","assign","Error","didRequestAuthentication","logger","connectWithUrl","connectCallback","parseFn","useNewUrlParser","transform","transformUrlOptions","legacyTransformUrlOptions","_object","object","_finalOptions","createUnifiedOptions","socketTimeoutMS","connectTimeoutMS","retryWrites","useRecoveryToken","db_options","auth","servers","length","credentials","generateCredentials","user","password","useUnifiedTopology","createTopology","replicaSet","rs_name","createServer","warningMessage","message","isWarn","emit","relayEvents","finalOptions","readPreference","read_preference","isDoingAuth","authMechanism","eventSet","v1","v2","has","promiseLibrary","translateOptions","server","close","ismaster","lastIsMaster","msg","replayEvents","topologyType","translationOptions","createServers","newTopology","autoEncryption","AutoEncrypter","resolve","mongoCryptOptions","autoEncrypter","init","childOptions","noMerge","mergeOptions","Buffer","isBuffer","Array","isArray","username","source","authSource","authdb","dbName","authMechanismRaw","toUpperCase","create","driver","mechanism","process","platform","mechanismProperties","target","flatten","serverOrCommandEvents","events","i","hosts","camelCaseName","hasUsername","hasAuthMechanism","db","defaultDatabase","maxpoolsize","poolSize","readconcernlevel","readConcern","wtimeoutms","wtimeout","srvHost","readPreferenceTags","read_preference_tags","tags","maxStalenessSeconds","map","serverObj","domain_socket","host","port","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst OperationBase = require('./operation').OperationBase;\r\nconst defineAspects = require('./operation').defineAspects;\r\nconst Aspect = require('./operation').Aspect;\r\nconst deprecate = require('util').deprecate;\r\nconst Logger = require('../core').Logger;\r\nconst MongoCredentials = require('../core').MongoCredentials;\r\nconst MongoError = require('../core').MongoError;\r\nconst Mongos = require('../topologies/mongos');\r\nconst NativeTopology = require('../topologies/native_topology');\r\nconst parse = require('../core').parseConnectionString;\r\nconst ReadConcern = require('../read_concern');\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst ReplSet = require('../topologies/replset');\r\nconst Server = require('../topologies/server');\r\nconst ServerSessionPool = require('../core').Sessions.ServerSessionPool;\r\n\r\nlet client;\r\nfunction loadClient() {\r\n  if (!client) {\r\n    client = require('../mongo_client');\r\n  }\r\n  return client;\r\n}\r\n\r\nconst legacyParse = deprecate(\r\n  require('../url_parser'),\r\n  'current URL string parser is deprecated, and will be removed in a future version. ' +\r\n    'To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.'\r\n);\r\n\r\nconst AUTH_MECHANISM_INTERNAL_MAP = {\r\n  DEFAULT: 'default',\r\n  'MONGODB-CR': 'mongocr',\r\n  PLAIN: 'plain',\r\n  'MONGODB-X509': 'x509',\r\n  'SCRAM-SHA-1': 'scram-sha-1',\r\n  'SCRAM-SHA-256': 'scram-sha-256'\r\n};\r\n\r\nconst monitoringEvents = [\r\n  'timeout',\r\n  'close',\r\n  'serverOpening',\r\n  'serverDescriptionChanged',\r\n  'serverHeartbeatStarted',\r\n  'serverHeartbeatSucceeded',\r\n  'serverHeartbeatFailed',\r\n  'serverClosed',\r\n  'topologyOpening',\r\n  'topologyClosed',\r\n  'topologyDescriptionChanged',\r\n  'commandStarted',\r\n  'commandSucceeded',\r\n  'commandFailed',\r\n  'joined',\r\n  'left',\r\n  'ping',\r\n  'ha',\r\n  'all',\r\n  'fullsetup',\r\n  'open'\r\n];\r\n\r\nconst VALID_AUTH_MECHANISMS = new Set([\r\n  'DEFAULT',\r\n  'MONGODB-CR',\r\n  'PLAIN',\r\n  'MONGODB-X509',\r\n  'SCRAM-SHA-1',\r\n  'SCRAM-SHA-256',\r\n  'GSSAPI'\r\n]);\r\n\r\nconst validOptionNames = [\r\n  'poolSize',\r\n  'ssl',\r\n  'sslValidate',\r\n  'sslCA',\r\n  'sslCert',\r\n  'sslKey',\r\n  'sslPass',\r\n  'sslCRL',\r\n  'autoReconnect',\r\n  'noDelay',\r\n  'keepAlive',\r\n  'keepAliveInitialDelay',\r\n  'connectTimeoutMS',\r\n  'family',\r\n  'socketTimeoutMS',\r\n  'reconnectTries',\r\n  'reconnectInterval',\r\n  'ha',\r\n  'haInterval',\r\n  'replicaSet',\r\n  'secondaryAcceptableLatencyMS',\r\n  'acceptableLatencyMS',\r\n  'connectWithNoPrimary',\r\n  'authSource',\r\n  'w',\r\n  'wtimeout',\r\n  'j',\r\n  'forceServerObjectId',\r\n  'serializeFunctions',\r\n  'ignoreUndefined',\r\n  'raw',\r\n  'bufferMaxEntries',\r\n  'readPreference',\r\n  'pkFactory',\r\n  'promiseLibrary',\r\n  'readConcern',\r\n  'maxStalenessSeconds',\r\n  'loggerLevel',\r\n  'logger',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'promoteLongs',\r\n  'domainsEnabled',\r\n  'checkServerIdentity',\r\n  'validateOptions',\r\n  'appname',\r\n  'auth',\r\n  'user',\r\n  'password',\r\n  'authMechanism',\r\n  'compression',\r\n  'fsync',\r\n  'readPreferenceTags',\r\n  'numberOfRetries',\r\n  'auto_reconnect',\r\n  'minSize',\r\n  'monitorCommands',\r\n  'retryWrites',\r\n  'retryReads',\r\n  'useNewUrlParser',\r\n  'useUnifiedTopology',\r\n  'serverSelectionTimeoutMS',\r\n  'useRecoveryToken',\r\n  'autoEncryption'\r\n];\r\n\r\nconst ignoreOptionNames = ['native_parser'];\r\nconst legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db'];\r\n\r\n// Validate options object\r\nfunction validOptions(options) {\r\n  const _validOptions = validOptionNames.concat(legacyOptionNames);\r\n\r\n  for (const name in options) {\r\n    if (ignoreOptionNames.indexOf(name) !== -1) {\r\n      continue;\r\n    }\r\n\r\n    if (_validOptions.indexOf(name) === -1) {\r\n      if (options.validateOptions) {\r\n        return new MongoError(`option ${name} is not supported`);\r\n      } else {\r\n        console.warn(`the options [${name}] is not supported`);\r\n      }\r\n    }\r\n\r\n    if (legacyOptionNames.indexOf(name) !== -1) {\r\n      console.warn(\r\n        `the server/replset/mongos/db options are deprecated, ` +\r\n          `all their options are supported at the top level of the options object [${validOptionNames}]`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {\r\n  obj[name.toLowerCase()] = name;\r\n  return obj;\r\n}, {});\r\n\r\nclass ConnectOperation extends OperationBase {\r\n  constructor(mongoClient) {\r\n    super();\r\n\r\n    this.mongoClient = mongoClient;\r\n  }\r\n\r\n  execute(callback) {\r\n    const mongoClient = this.mongoClient;\r\n    const err = validOptions(mongoClient.s.options);\r\n\r\n    // Did we have a validation error\r\n    if (err) return callback(err);\r\n    // Fallback to callback based connect\r\n    connect(mongoClient, mongoClient.s.url, mongoClient.s.options, err => {\r\n      if (err) return callback(err);\r\n      callback(null, mongoClient);\r\n    });\r\n  }\r\n}\r\ndefineAspects(ConnectOperation, [Aspect.SKIP_SESSION]);\r\n\r\nfunction addListeners(mongoClient, topology) {\r\n  topology.on('authenticated', createListener(mongoClient, 'authenticated'));\r\n  topology.on('error', createListener(mongoClient, 'error'));\r\n  topology.on('timeout', createListener(mongoClient, 'timeout'));\r\n  topology.on('close', createListener(mongoClient, 'close'));\r\n  topology.on('parseError', createListener(mongoClient, 'parseError'));\r\n  topology.once('open', createListener(mongoClient, 'open'));\r\n  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));\r\n  topology.once('all', createListener(mongoClient, 'all'));\r\n  topology.on('reconnect', createListener(mongoClient, 'reconnect'));\r\n}\r\n\r\nfunction assignTopology(client, topology) {\r\n  client.topology = topology;\r\n  topology.s.sessionPool =\r\n    topology instanceof NativeTopology\r\n      ? new ServerSessionPool(topology)\r\n      : new ServerSessionPool(topology.s.coreTopology);\r\n}\r\n\r\n// Clear out all events\r\nfunction clearAllEvents(topology) {\r\n  monitoringEvents.forEach(event => topology.removeAllListeners(event));\r\n}\r\n\r\n// Collect all events in order from SDAM\r\nfunction collectEvents(mongoClient, topology) {\r\n  let MongoClient = loadClient();\r\n  const collectedEvents = [];\r\n\r\n  if (mongoClient instanceof MongoClient) {\r\n    monitoringEvents.forEach(event => {\r\n      topology.on(event, (object1, object2) => {\r\n        if (event === 'open') {\r\n          collectedEvents.push({ event: event, object1: mongoClient });\r\n        } else {\r\n          collectedEvents.push({ event: event, object1: object1, object2: object2 });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  return collectedEvents;\r\n}\r\n\r\nconst emitDeprecationForNonUnifiedTopology = deprecate(() => {},\r\n'current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. ' + 'To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.');\r\n\r\nfunction connect(mongoClient, url, options, callback) {\r\n  options = Object.assign({}, options);\r\n\r\n  // If callback is null throw an exception\r\n  if (callback == null) {\r\n    throw new Error('no callback function provided');\r\n  }\r\n\r\n  let didRequestAuthentication = false;\r\n  const logger = Logger('MongoClient', options);\r\n\r\n  // Did we pass in a Server/ReplSet/Mongos\r\n  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {\r\n    return connectWithUrl(mongoClient, url, options, connectCallback);\r\n  }\r\n\r\n  const parseFn = options.useNewUrlParser ? parse : legacyParse;\r\n  const transform = options.useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;\r\n\r\n  parseFn(url, options, (err, _object) => {\r\n    // Do not attempt to connect if parsing error\r\n    if (err) return callback(err);\r\n\r\n    // Flatten\r\n    const object = transform(_object);\r\n\r\n    // Parse the string\r\n    const _finalOptions = createUnifiedOptions(object, options);\r\n\r\n    // Check if we have connection and socket timeout set\r\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 360000;\r\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;\r\n    if (_finalOptions.retryWrites == null) _finalOptions.retryWrites = true;\r\n    if (_finalOptions.useRecoveryToken == null) _finalOptions.useRecoveryToken = true;\r\n\r\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\r\n      delete _finalOptions.db_options.auth;\r\n    }\r\n\r\n    // Store the merged options object\r\n    mongoClient.s.options = _finalOptions;\r\n\r\n    // Failure modes\r\n    if (object.servers.length === 0) {\r\n      return callback(new Error('connection string must contain at least one seed host'));\r\n    }\r\n\r\n    if (_finalOptions.auth && !_finalOptions.credentials) {\r\n      try {\r\n        didRequestAuthentication = true;\r\n        _finalOptions.credentials = generateCredentials(\r\n          mongoClient,\r\n          _finalOptions.auth.user,\r\n          _finalOptions.auth.password,\r\n          _finalOptions\r\n        );\r\n      } catch (err) {\r\n        return callback(err);\r\n      }\r\n    }\r\n\r\n    if (_finalOptions.useUnifiedTopology) {\r\n      return createTopology(mongoClient, 'unified', _finalOptions, connectCallback);\r\n    }\r\n\r\n    emitDeprecationForNonUnifiedTopology();\r\n\r\n    // Do we have a replicaset then skip discovery and go straight to connectivity\r\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\r\n      return createTopology(mongoClient, 'replicaset', _finalOptions, connectCallback);\r\n    } else if (object.servers.length > 1) {\r\n      return createTopology(mongoClient, 'mongos', _finalOptions, connectCallback);\r\n    } else {\r\n      return createServer(mongoClient, _finalOptions, connectCallback);\r\n    }\r\n  });\r\n\r\n  function connectCallback(err, topology) {\r\n    const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;\r\n    if (err && err.message === 'no mongos proxies found in seed list') {\r\n      if (logger.isWarn()) {\r\n        logger.warn(warningMessage);\r\n      }\r\n\r\n      // Return a more specific error message for MongoClient.connect\r\n      return callback(new MongoError(warningMessage));\r\n    }\r\n\r\n    if (didRequestAuthentication) {\r\n      mongoClient.emit('authenticated', null, true);\r\n    }\r\n\r\n    // Return the error and db instance\r\n    callback(err, topology);\r\n  }\r\n}\r\n\r\nfunction connectWithUrl(mongoClient, url, options, connectCallback) {\r\n  // Set the topology\r\n  assignTopology(mongoClient, url);\r\n\r\n  // Add listeners\r\n  addListeners(mongoClient, url);\r\n\r\n  // Propagate the events to the client\r\n  relayEvents(mongoClient, url);\r\n\r\n  let finalOptions = Object.assign({}, options);\r\n\r\n  // If we have a readPreference passed in by the db options, convert it from a string\r\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\r\n    finalOptions.readPreference = new ReadPreference(\r\n      options.readPreference || options.read_preference\r\n    );\r\n  }\r\n\r\n  const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;\r\n  if (isDoingAuth && !finalOptions.credentials) {\r\n    try {\r\n      finalOptions.credentials = generateCredentials(\r\n        mongoClient,\r\n        finalOptions.user,\r\n        finalOptions.password,\r\n        finalOptions\r\n      );\r\n    } catch (err) {\r\n      return connectCallback(err, url);\r\n    }\r\n  }\r\n\r\n  return url.connect(finalOptions, connectCallback);\r\n}\r\n\r\nfunction createListener(mongoClient, event) {\r\n  const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);\r\n  return (v1, v2) => {\r\n    if (eventSet.has(event)) {\r\n      return mongoClient.emit(event, mongoClient);\r\n    }\r\n\r\n    mongoClient.emit(event, v1, v2);\r\n  };\r\n}\r\n\r\nfunction createServer(mongoClient, options, callback) {\r\n  // Pass in the promise library\r\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\r\n\r\n  // Set default options\r\n  const servers = translateOptions(options);\r\n\r\n  const server = servers[0];\r\n\r\n  // Propagate the events to the client\r\n  const collectedEvents = collectEvents(mongoClient, server);\r\n\r\n  // Connect to topology\r\n  server.connect(options, (err, topology) => {\r\n    if (err) {\r\n      server.close(true);\r\n      return callback(err);\r\n    }\r\n    // Clear out all the collected event listeners\r\n    clearAllEvents(server);\r\n\r\n    // Relay all the events\r\n    relayEvents(mongoClient, server);\r\n    // Add listeners\r\n    addListeners(mongoClient, server);\r\n    // Check if we are really speaking to a mongos\r\n    const ismaster = topology.lastIsMaster();\r\n\r\n    // Set the topology\r\n    assignTopology(mongoClient, topology);\r\n\r\n    // Do we actually have a mongos\r\n    if (ismaster && ismaster.msg === 'isdbgrid') {\r\n      // Destroy the current connection\r\n      topology.close();\r\n      // Create mongos connection instead\r\n      return createTopology(mongoClient, 'mongos', options, callback);\r\n    }\r\n\r\n    // Fire all the events\r\n    replayEvents(mongoClient, collectedEvents);\r\n    // Otherwise callback\r\n    callback(err, topology);\r\n  });\r\n}\r\n\r\nfunction createTopology(mongoClient, topologyType, options, callback) {\r\n  // Pass in the promise library\r\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\r\n\r\n  const translationOptions = {};\r\n  if (topologyType === 'unified') translationOptions.createServers = false;\r\n\r\n  // Set default options\r\n  const servers = translateOptions(options, translationOptions);\r\n\r\n  // Create the topology\r\n  let topology;\r\n  if (topologyType === 'mongos') {\r\n    topology = new Mongos(servers, options);\r\n  } else if (topologyType === 'replicaset') {\r\n    topology = new ReplSet(servers, options);\r\n  } else if (topologyType === 'unified') {\r\n    topology = new NativeTopology(options.servers, options);\r\n  }\r\n\r\n  // Add listeners\r\n  addListeners(mongoClient, topology);\r\n\r\n  // Propagate the events to the client\r\n  relayEvents(mongoClient, topology);\r\n\r\n  // Open the connection\r\n  topology.connect(options, (err, newTopology) => {\r\n    if (err) {\r\n      topology.close(true);\r\n      return callback(err);\r\n    }\r\n\r\n    assignTopology(mongoClient, newTopology);\r\n    if (options.autoEncryption == null) {\r\n      callback(null, newTopology);\r\n      return;\r\n    }\r\n\r\n    // setup for client side encryption\r\n    let AutoEncrypter;\r\n    try {\r\n      require.resolve('mongodb-client-encryption');\r\n    } catch (err) {\r\n      callback(\r\n        new MongoError(\r\n          'Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project'\r\n        )\r\n      );\r\n      return;\r\n    }\r\n    try {\r\n      AutoEncrypter = require('mongodb-client-encryption')(require('../../index')).AutoEncrypter;\r\n    } catch (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    const mongoCryptOptions = Object.assign({}, options.autoEncryption);\r\n    topology.s.options.autoEncrypter = new AutoEncrypter(mongoClient, mongoCryptOptions);\r\n    topology.s.options.autoEncrypter.init(err => {\r\n      if (err) return callback(err, null);\r\n      callback(null, newTopology);\r\n    });\r\n  });\r\n}\r\n\r\nfunction createUnifiedOptions(finalOptions, options) {\r\n  const childOptions = [\r\n    'mongos',\r\n    'server',\r\n    'db',\r\n    'replset',\r\n    'db_options',\r\n    'server_options',\r\n    'rs_options',\r\n    'mongos_options'\r\n  ];\r\n  const noMerge = ['readconcern', 'compression'];\r\n\r\n  for (const name in options) {\r\n    if (noMerge.indexOf(name.toLowerCase()) !== -1) {\r\n      finalOptions[name] = options[name];\r\n    } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {\r\n      finalOptions = mergeOptions(finalOptions, options[name], false);\r\n    } else {\r\n      if (\r\n        options[name] &&\r\n        typeof options[name] === 'object' &&\r\n        !Buffer.isBuffer(options[name]) &&\r\n        !Array.isArray(options[name])\r\n      ) {\r\n        finalOptions = mergeOptions(finalOptions, options[name], true);\r\n      } else {\r\n        finalOptions[name] = options[name];\r\n      }\r\n    }\r\n  }\r\n\r\n  return finalOptions;\r\n}\r\n\r\nfunction generateCredentials(client, username, password, options) {\r\n  options = Object.assign({}, options);\r\n\r\n  // the default db to authenticate against is 'self'\r\n  // if authententicate is called from a retry context, it may be another one, like admin\r\n  const source = options.authSource || options.authdb || options.dbName;\r\n\r\n  // authMechanism\r\n  const authMechanismRaw = options.authMechanism || 'DEFAULT';\r\n  const authMechanism = authMechanismRaw.toUpperCase();\r\n\r\n  if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {\r\n    throw MongoError.create({\r\n      message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,\r\n      driver: true\r\n    });\r\n  }\r\n\r\n  if (authMechanism === 'GSSAPI') {\r\n    return new MongoCredentials({\r\n      mechanism: process.platform === 'win32' ? 'sspi' : 'gssapi',\r\n      mechanismProperties: options,\r\n      source,\r\n      username,\r\n      password\r\n    });\r\n  }\r\n\r\n  return new MongoCredentials({\r\n    mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],\r\n    source,\r\n    username,\r\n    password\r\n  });\r\n}\r\n\r\nfunction legacyTransformUrlOptions(object) {\r\n  return mergeOptions(createUnifiedOptions({}, object), object, false);\r\n}\r\n\r\nfunction mergeOptions(target, source, flatten) {\r\n  for (const name in source) {\r\n    if (source[name] && typeof source[name] === 'object' && flatten) {\r\n      target = mergeOptions(target, source[name], flatten);\r\n    } else {\r\n      target[name] = source[name];\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction relayEvents(mongoClient, topology) {\r\n  const serverOrCommandEvents = [\r\n    'serverOpening',\r\n    'serverDescriptionChanged',\r\n    'serverHeartbeatStarted',\r\n    'serverHeartbeatSucceeded',\r\n    'serverHeartbeatFailed',\r\n    'serverClosed',\r\n    'topologyOpening',\r\n    'topologyClosed',\r\n    'topologyDescriptionChanged',\r\n    'commandStarted',\r\n    'commandSucceeded',\r\n    'commandFailed',\r\n    'joined',\r\n    'left',\r\n    'ping',\r\n    'ha'\r\n  ];\r\n\r\n  serverOrCommandEvents.forEach(event => {\r\n    topology.on(event, (object1, object2) => {\r\n      mongoClient.emit(event, object1, object2);\r\n    });\r\n  });\r\n}\r\n\r\n//\r\n// Replay any events due to single server connection switching to Mongos\r\n//\r\nfunction replayEvents(mongoClient, events) {\r\n  for (let i = 0; i < events.length; i++) {\r\n    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);\r\n  }\r\n}\r\n\r\nfunction transformUrlOptions(_object) {\r\n  let object = Object.assign({ servers: _object.hosts }, _object.options);\r\n  for (let name in object) {\r\n    const camelCaseName = LEGACY_OPTIONS_MAP[name];\r\n    if (camelCaseName) {\r\n      object[camelCaseName] = object[name];\r\n    }\r\n  }\r\n\r\n  const hasUsername = _object.auth && _object.auth.username;\r\n  const hasAuthMechanism = _object.options && _object.options.authMechanism;\r\n  if (hasUsername || hasAuthMechanism) {\r\n    object.auth = Object.assign({}, _object.auth);\r\n    if (object.auth.db) {\r\n      object.authSource = object.authSource || object.auth.db;\r\n    }\r\n\r\n    if (object.auth.username) {\r\n      object.auth.user = object.auth.username;\r\n    }\r\n  }\r\n\r\n  if (_object.defaultDatabase) {\r\n    object.dbName = _object.defaultDatabase;\r\n  }\r\n\r\n  if (object.maxpoolsize) {\r\n    object.poolSize = object.maxpoolsize;\r\n  }\r\n\r\n  if (object.readconcernlevel) {\r\n    object.readConcern = new ReadConcern(object.readconcernlevel);\r\n  }\r\n\r\n  if (object.wtimeoutms) {\r\n    object.wtimeout = object.wtimeoutms;\r\n  }\r\n\r\n  if (_object.srvHost) {\r\n    object.srvHost = _object.srvHost;\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\nfunction translateOptions(options, translationOptions) {\r\n  translationOptions = Object.assign({}, { createServers: true }, translationOptions);\r\n\r\n  // If we have a readPreference passed in by the db options\r\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\r\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\r\n  }\r\n\r\n  // Do we have readPreference tags, add them\r\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\r\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\r\n  }\r\n\r\n  // Do we have maxStalenessSeconds\r\n  if (options.maxStalenessSeconds) {\r\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\r\n  }\r\n\r\n  // Set the socket and connection timeouts\r\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 360000;\r\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;\r\n\r\n  if (!translationOptions.createServers) {\r\n    return;\r\n  }\r\n\r\n  // Create server instances\r\n  return options.servers.map(serverObj => {\r\n    return serverObj.domain_socket\r\n      ? new Server(serverObj.domain_socket, 27017, options)\r\n      : new Server(serverObj.host, serverObj.port, options);\r\n  });\r\n}\r\n\r\nmodule.exports = ConnectOperation;\r\n"]},"metadata":{},"sourceType":"script"}