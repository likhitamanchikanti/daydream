{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./server_description').ServerType;\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants'); // contstants related to compatability checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION; // An enumeration of topology types we know about\n\nconst TopologyType = {\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown'\n}; // Representation of a deployment of servers\n\nclass TopologyDescription {\n  /**\r\n   * Create a TopologyDescription\r\n   *\r\n   * @param {string} topologyType\r\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\r\n   * @param {string} setName\r\n   * @param {number} maxSetVersion\r\n   * @param {ObjectId} maxElectionId\r\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options, error) {\n    options = options || {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.options = options;\n    this.error = error;\n    this.commonWireVersion = commonWireVersion || null; // determine server compatibility\n\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    const readableServers = Array.from(this.servers.values()).filter(s => s.isReadable);\n    this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {\n      if (server.logicalSessionTimeoutMinutes == null) return null;\n      if (result == null) return server.logicalSessionTimeoutMinutes;\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\n    }, null);\n  }\n  /**\r\n   * Returns a new TopologyDescription based on the SrvPollingEvent\r\n   * @param {SrvPollingEvent} ev The event\r\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);\n  }\n  /**\r\n   * Returns a copy of this description updated with a given ServerDescription\r\n   *\r\n   * @param {ServerDescription} serverDescription\r\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n    // potentially mutated values\n\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n    let error = serverDescription.error || null;\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options, error);\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        topologyType = result[0], setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options, error);\n  }\n  /**\r\n   * Determines if the topology description has any known servers\r\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerDescription.Unknown);\n  }\n  /**\r\n   * Determines if this topology description has a data-bearing server available.\r\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\r\n   * Determines if the topology has a definition for the provided address\r\n   *\r\n   * @param {String} address\r\n   * @return {Boolean} Whether the topology knows about this server\r\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Mongos) return TopologyType.Sharded;\n  if (serverType === ServerType.RSPrimary) return TopologyType.ReplicaSetWithPrimary;\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionIdOID = serverDescription.electionId ? serverDescription.electionId.$oid : null;\n  const maxElectionIdOID = maxElectionId ? maxElectionId.$oid : null;\n\n  if (serverDescription.setVersion != null && electionIdOID != null) {\n    if (maxSetVersion != null && maxElectionIdOID != null) {\n      if (maxSetVersion > serverDescription.setVersion || maxElectionIdOID > electionIdOID) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyType,\n  TopologyDescription\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/sdam/topology_description.js"],"names":["ServerType","require","ServerDescription","WIRE_CONSTANTS","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","TopologyType","Single","ReplicaSetNoPrimary","ReplicaSetWithPrimary","Sharded","Unknown","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","error","type","servers","Map","stale","compatible","compatibilityError","logicalSessionTimeoutMinutes","heartbeatFrequencyMS","localThresholdMS","serverDescription","values","minWireVersion","address","maxWireVersion","readableServers","Array","from","filter","s","isReadable","reduce","result","server","Math","min","updateFromSrvPollingEvent","ev","newAddresses","addresses","has","delete","size","set","update","serverType","Standalone","topologyTypeForServerType","Mongos","indexOf","RSPrimary","updateRsFromPrimary","RSSecondary","RSArbiter","RSOther","updateRsNoPrimaryFromMember","checkHasPrimary","updateRsWithPrimaryFromMember","hasKnownServers","some","sd","hasDataBearingServers","isDataBearing","hasServer","electionIdOID","electionId","$oid","maxElectionIdOID","setVersion","keys","get","allHosts","forEach","currentAddresses","responseAddresses","addr","TypeError","me","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\nconst ServerType = require('./server_description').ServerType;\r\nconst ServerDescription = require('./server_description').ServerDescription;\r\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\r\n\r\n// contstants related to compatability checks\r\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\r\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\r\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\r\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\r\n\r\n// An enumeration of topology types we know about\r\nconst TopologyType = {\r\n  Single: 'Single',\r\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\r\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\r\n  Sharded: 'Sharded',\r\n  Unknown: 'Unknown'\r\n};\r\n\r\n// Representation of a deployment of servers\r\nclass TopologyDescription {\r\n  /**\r\n   * Create a TopologyDescription\r\n   *\r\n   * @param {string} topologyType\r\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\r\n   * @param {string} setName\r\n   * @param {number} maxSetVersion\r\n   * @param {ObjectId} maxElectionId\r\n   */\r\n  constructor(\r\n    topologyType,\r\n    serverDescriptions,\r\n    setName,\r\n    maxSetVersion,\r\n    maxElectionId,\r\n    commonWireVersion,\r\n    options,\r\n    error\r\n  ) {\r\n    options = options || {};\r\n\r\n    // TODO: consider assigning all these values to a temporary value `s` which\r\n    //       we use `Object.freeze` on, ensuring the internal state of this type\r\n    //       is immutable.\r\n    this.type = topologyType || TopologyType.Unknown;\r\n    this.setName = setName || null;\r\n    this.maxSetVersion = maxSetVersion || null;\r\n    this.maxElectionId = maxElectionId || null;\r\n    this.servers = serverDescriptions || new Map();\r\n    this.stale = false;\r\n    this.compatible = true;\r\n    this.compatibilityError = null;\r\n    this.logicalSessionTimeoutMinutes = null;\r\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\r\n    this.localThresholdMS = options.localThresholdMS || 0;\r\n    this.options = options;\r\n    this.error = error;\r\n    this.commonWireVersion = commonWireVersion || null;\r\n\r\n    // determine server compatibility\r\n    for (const serverDescription of this.servers.values()) {\r\n      if (serverDescription.type === ServerType.Unknown) continue;\r\n\r\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\r\n        this.compatible = false;\r\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${\r\n          serverDescription.minWireVersion\r\n        }, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\r\n      }\r\n\r\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\r\n        this.compatible = false;\r\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${\r\n          serverDescription.maxWireVersion\r\n        }, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\r\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\r\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\r\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\r\n    // set to null.\r\n    const readableServers = Array.from(this.servers.values()).filter(s => s.isReadable);\r\n    this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {\r\n      if (server.logicalSessionTimeoutMinutes == null) return null;\r\n      if (result == null) return server.logicalSessionTimeoutMinutes;\r\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\r\n    }, null);\r\n  }\r\n\r\n  /**\r\n   * Returns a new TopologyDescription based on the SrvPollingEvent\r\n   * @param {SrvPollingEvent} ev The event\r\n   */\r\n  updateFromSrvPollingEvent(ev) {\r\n    const newAddresses = ev.addresses();\r\n    const serverDescriptions = new Map(this.servers);\r\n    for (const server of this.servers) {\r\n      if (newAddresses.has(server[0])) {\r\n        newAddresses.delete(server[0]);\r\n      } else {\r\n        serverDescriptions.delete(server[0]);\r\n      }\r\n    }\r\n\r\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\r\n      return this;\r\n    }\r\n\r\n    for (const address of newAddresses) {\r\n      serverDescriptions.set(address, new ServerDescription(address));\r\n    }\r\n\r\n    return new TopologyDescription(\r\n      this.type,\r\n      serverDescriptions,\r\n      this.setName,\r\n      this.maxSetVersion,\r\n      this.maxElectionId,\r\n      this.commonWireVersion,\r\n      this.options,\r\n      null\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns a copy of this description updated with a given ServerDescription\r\n   *\r\n   * @param {ServerDescription} serverDescription\r\n   */\r\n  update(serverDescription) {\r\n    const address = serverDescription.address;\r\n    // NOTE: there are a number of prime targets for refactoring here\r\n    //       once we support destructuring assignments\r\n\r\n    // potentially mutated values\r\n    let topologyType = this.type;\r\n    let setName = this.setName;\r\n    let maxSetVersion = this.maxSetVersion;\r\n    let maxElectionId = this.maxElectionId;\r\n    let commonWireVersion = this.commonWireVersion;\r\n    let error = serverDescription.error || null;\r\n\r\n    const serverType = serverDescription.type;\r\n    let serverDescriptions = new Map(this.servers);\r\n\r\n    // update common wire version\r\n    if (serverDescription.maxWireVersion !== 0) {\r\n      if (commonWireVersion == null) {\r\n        commonWireVersion = serverDescription.maxWireVersion;\r\n      } else {\r\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\r\n      }\r\n    }\r\n\r\n    // update the actual server description\r\n    serverDescriptions.set(address, serverDescription);\r\n\r\n    if (topologyType === TopologyType.Single) {\r\n      // once we are defined as single, that never changes\r\n      return new TopologyDescription(\r\n        TopologyType.Single,\r\n        serverDescriptions,\r\n        setName,\r\n        maxSetVersion,\r\n        maxElectionId,\r\n        commonWireVersion,\r\n        this.options,\r\n        error\r\n      );\r\n    }\r\n\r\n    if (topologyType === TopologyType.Unknown) {\r\n      if (serverType === ServerType.Standalone) {\r\n        serverDescriptions.delete(address);\r\n      } else {\r\n        topologyType = topologyTypeForServerType(serverType);\r\n      }\r\n    }\r\n\r\n    if (topologyType === TopologyType.Sharded) {\r\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\r\n        serverDescriptions.delete(address);\r\n      }\r\n    }\r\n\r\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\r\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) >= 0) {\r\n        serverDescriptions.delete(address);\r\n      }\r\n\r\n      if (serverType === ServerType.RSPrimary) {\r\n        const result = updateRsFromPrimary(\r\n          serverDescriptions,\r\n          setName,\r\n          serverDescription,\r\n          maxSetVersion,\r\n          maxElectionId\r\n        );\r\n\r\n        (topologyType = result[0]),\r\n          (setName = result[1]),\r\n          (maxSetVersion = result[2]),\r\n          (maxElectionId = result[3]);\r\n      } else if (\r\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\r\n      ) {\r\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\r\n        (topologyType = result[0]), (setName = result[1]);\r\n      }\r\n    }\r\n\r\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\r\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\r\n        serverDescriptions.delete(address);\r\n        topologyType = checkHasPrimary(serverDescriptions);\r\n      } else if (serverType === ServerType.RSPrimary) {\r\n        const result = updateRsFromPrimary(\r\n          serverDescriptions,\r\n          setName,\r\n          serverDescription,\r\n          maxSetVersion,\r\n          maxElectionId\r\n        );\r\n\r\n        (topologyType = result[0]),\r\n          (setName = result[1]),\r\n          (maxSetVersion = result[2]),\r\n          (maxElectionId = result[3]);\r\n      } else if (\r\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\r\n      ) {\r\n        topologyType = updateRsWithPrimaryFromMember(\r\n          serverDescriptions,\r\n          setName,\r\n          serverDescription\r\n        );\r\n      } else {\r\n        topologyType = checkHasPrimary(serverDescriptions);\r\n      }\r\n    }\r\n\r\n    return new TopologyDescription(\r\n      topologyType,\r\n      serverDescriptions,\r\n      setName,\r\n      maxSetVersion,\r\n      maxElectionId,\r\n      commonWireVersion,\r\n      this.options,\r\n      error\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines if the topology description has any known servers\r\n   */\r\n  get hasKnownServers() {\r\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerDescription.Unknown);\r\n  }\r\n\r\n  /**\r\n   * Determines if this topology description has a data-bearing server available.\r\n   */\r\n  get hasDataBearingServers() {\r\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\r\n  }\r\n\r\n  /**\r\n   * Determines if the topology has a definition for the provided address\r\n   *\r\n   * @param {String} address\r\n   * @return {Boolean} Whether the topology knows about this server\r\n   */\r\n  hasServer(address) {\r\n    return this.servers.has(address);\r\n  }\r\n}\r\n\r\nfunction topologyTypeForServerType(serverType) {\r\n  if (serverType === ServerType.Mongos) return TopologyType.Sharded;\r\n  if (serverType === ServerType.RSPrimary) return TopologyType.ReplicaSetWithPrimary;\r\n  return TopologyType.ReplicaSetNoPrimary;\r\n}\r\n\r\nfunction updateRsFromPrimary(\r\n  serverDescriptions,\r\n  setName,\r\n  serverDescription,\r\n  maxSetVersion,\r\n  maxElectionId\r\n) {\r\n  setName = setName || serverDescription.setName;\r\n  if (setName !== serverDescription.setName) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\r\n  }\r\n\r\n  const electionIdOID = serverDescription.electionId ? serverDescription.electionId.$oid : null;\r\n  const maxElectionIdOID = maxElectionId ? maxElectionId.$oid : null;\r\n  if (serverDescription.setVersion != null && electionIdOID != null) {\r\n    if (maxSetVersion != null && maxElectionIdOID != null) {\r\n      if (maxSetVersion > serverDescription.setVersion || maxElectionIdOID > electionIdOID) {\r\n        // this primary is stale, we must remove it\r\n        serverDescriptions.set(\r\n          serverDescription.address,\r\n          new ServerDescription(serverDescription.address)\r\n        );\r\n\r\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\r\n      }\r\n    }\r\n\r\n    maxElectionId = serverDescription.electionId;\r\n  }\r\n\r\n  if (\r\n    serverDescription.setVersion != null &&\r\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\r\n  ) {\r\n    maxSetVersion = serverDescription.setVersion;\r\n  }\r\n\r\n  // We've heard from the primary. Is it the same primary as before?\r\n  for (const address of serverDescriptions.keys()) {\r\n    const server = serverDescriptions.get(address);\r\n\r\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\r\n      // Reset old primary's type to Unknown.\r\n      serverDescriptions.set(address, new ServerDescription(server.address));\r\n\r\n      // There can only be one primary\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Discover new hosts from this primary's response.\r\n  serverDescription.allHosts.forEach(address => {\r\n    if (!serverDescriptions.has(address)) {\r\n      serverDescriptions.set(address, new ServerDescription(address));\r\n    }\r\n  });\r\n\r\n  // Remove hosts not in the response.\r\n  const currentAddresses = Array.from(serverDescriptions.keys());\r\n  const responseAddresses = serverDescription.allHosts;\r\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\r\n    serverDescriptions.delete(address);\r\n  });\r\n\r\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\r\n}\r\n\r\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\r\n  if (setName == null) {\r\n    throw new TypeError('setName is required');\r\n  }\r\n\r\n  if (\r\n    setName !== serverDescription.setName ||\r\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\r\n  ) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n  }\r\n\r\n  return checkHasPrimary(serverDescriptions);\r\n}\r\n\r\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\r\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\r\n\r\n  setName = setName || serverDescription.setName;\r\n  if (setName !== serverDescription.setName) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n    return [topologyType, setName];\r\n  }\r\n\r\n  serverDescription.allHosts.forEach(address => {\r\n    if (!serverDescriptions.has(address)) {\r\n      serverDescriptions.set(address, new ServerDescription(address));\r\n    }\r\n  });\r\n\r\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n  }\r\n\r\n  return [topologyType, setName];\r\n}\r\n\r\nfunction checkHasPrimary(serverDescriptions) {\r\n  for (const addr of serverDescriptions.keys()) {\r\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\r\n      return TopologyType.ReplicaSetWithPrimary;\r\n    }\r\n  }\r\n\r\n  return TopologyType.ReplicaSetNoPrimary;\r\n}\r\n\r\nmodule.exports = {\r\n  TopologyType,\r\n  TopologyDescription\r\n};\r\n"]},"metadata":{},"sourceType":"script"}