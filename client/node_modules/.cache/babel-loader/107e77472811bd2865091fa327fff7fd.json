{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst resolveReadPreference = require('../utils').resolveReadPreference;\n\nconst crypto = require('crypto');\n\nconst debugOptions = require('../utils').debugOptions;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst parseIndexOptions = require('../utils').parseIndexOptions;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CONSTANTS = require('../constants');\n\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nconst count = require('./collection_ops').count;\n\nconst findOne = require('./collection_ops').findOne;\n\nconst remove = require('./collection_ops').remove;\n\nconst updateOne = require('./collection_ops').updateOne;\n\nlet collection;\n\nfunction loadCollection() {\n  if (!collection) {\n    collection = require('../collection');\n  }\n\n  return collection;\n}\n\nlet db;\n\nfunction loadDb() {\n  if (!db) {\n    db = require('../db');\n  }\n\n  return db;\n}\n\nconst debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId', 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds', 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];\n/**\r\n * Add a user to the database.\r\n * @method\r\n * @param {Db} db The Db instance on which to add a user.\r\n * @param {string} username The username.\r\n * @param {string} password The password.\r\n * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\nfunction addUser(db, username, password, options, callback) {\n  let Db = loadDb(); // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Attempt to execute auth command\n\n  executeAuthCreateUserCommand(db, username, password, options, (err, r) => {\n    // We need to perform the backward compatible insert operation\n    if (err && err.code === -5000) {\n      const finalOptions = applyWriteConcern(Object.assign({}, options), {\n        db\n      }, options); // Use node md5 generator\n\n      const md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n      md5.update(username + ':mongo:' + password);\n      const userPassword = md5.digest('hex'); // If we have another db set\n\n      const dbToUse = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db; // Fetch a user collection\n\n      const collection = dbToUse.collection(CONSTANTS.SYSTEM_USER_COLLECTION); // Check if we are inserting the first user\n\n      count(collection, {}, finalOptions, (err, count) => {\n        // We got an error (f.ex not authorized)\n        if (err != null) return handleCallback(callback, err, null); // Check if the user exists and update i\n\n        const findOptions = Object.assign({\n          projection: {\n            dbName: 1\n          }\n        }, finalOptions);\n        collection.find({\n          user: username\n        }, findOptions).toArray(err => {\n          // We got an error (f.ex not authorized)\n          if (err != null) return handleCallback(callback, err, null); // Add command keys\n\n          finalOptions.upsert = true; // We have a user, let's update the password or upsert if not\n\n          updateOne(collection, {\n            user: username\n          }, {\n            $set: {\n              user: username,\n              pwd: userPassword\n            }\n          }, finalOptions, err => {\n            if (count === 0 && err) return handleCallback(callback, null, [{\n              user: username,\n              pwd: userPassword\n            }]);\n            if (err) return handleCallback(callback, err, null);\n            handleCallback(callback, null, [{\n              user: username,\n              pwd: userPassword\n            }]);\n          });\n        });\n      });\n      return;\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, err, r);\n  });\n}\n/**\r\n * Fetch all collections for the current db.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to fetch collections.\r\n * @param {object} [options] Optional settings. See Db.prototype.collections for a list of options.\r\n * @param {Db~collectionsResultCallback} [callback] The results callback\r\n */\n\n\nfunction collections(db, options, callback) {\n  let Collection = loadCollection();\n  options = Object.assign({}, options, {\n    nameOnly: true\n  }); // Let's get the collection names\n\n  db.listCollections({}, options).toArray((err, documents) => {\n    if (err != null) return handleCallback(callback, err, null); // Filter collections removing any illegal ones\n\n    documents = documents.filter(doc => {\n      return doc.name.indexOf('$') === -1;\n    }); // Return the collection objects\n\n    handleCallback(callback, null, documents.map(d => {\n      return new Collection(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);\n    }));\n  });\n}\n/**\r\n * Creates an index on the db and collection.\r\n * @method\r\n * @param {Db} db The Db instance on which to create an index.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  let finalOptions = Object.assign({}, {\n    readPreference: ReadPreference.PRIMARY\n  }, options);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db\n  }, options); // Ensure we have a callback\n\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\n    throw MongoError.create({\n      message: 'Cannot use a writeConcern without a provided callback',\n      driver: true\n    });\n  } // Did the user destroy the topology\n\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Attempt to run using createIndexes command\n\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {\n    if (err == null) return handleCallback(callback, err, result);\n    /**\r\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\r\n     * 67 = 'CannotCreateIndex' (malformed index options)\r\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\r\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\r\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\r\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\r\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\r\n     */\n\n    if (err.code === 67 || err.code === 11000 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {\n      return handleCallback(callback, err, result);\n    } // Create command\n\n\n    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options); // Set no key checking\n\n    finalOptions.checkKeys = false; // Insert document\n\n    db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err, result) => {\n      if (callback == null) return;\n      if (err) return handleCallback(callback, err);\n      if (result == null) return handleCallback(callback, null, null);\n      if (result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\n      handleCallback(callback, null, doc.name);\n    });\n  });\n} // Add listeners to topology\n\n\nfunction createListener(db, e, object) {\n  function listener(err) {\n    if (object.listeners(e).length > 0) {\n      object.emit(e, err, db); // Emit on all associated db's if available\n\n      for (let i = 0; i < db.s.children.length; i++) {\n        db.s.children[i].emit(e, err, db.s.children[i]);\n      }\n    }\n  }\n\n  return listener;\n}\n/**\r\n * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to drop the collection.\r\n * @param {string} name Name of collection to drop\r\n * @param {Object} [options] Optional settings. See Db.prototype.dropCollection for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n */\n\n\nfunction dropCollection(db, name, options, callback) {\n  executeCommand(db, name, options, (err, result) => {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    if (result.ok) return handleCallback(callback, null, true);\n    handleCallback(callback, null, false);\n  });\n}\n/**\r\n * Drop a database, removing it permanently from the server.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance to drop.\r\n * @param {Object} cmd The command document.\r\n * @param {Object} [options] Optional settings. See Db.prototype.dropDatabase for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n */\n\n\nfunction dropDatabase(db, cmd, options, callback) {\n  executeCommand(db, cmd, options, (err, result) => {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result.ok ? true : false);\n  });\n}\n/**\r\n * Ensures that an index exists. If it does not, creates it.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to ensure the index.\r\n * @param {string} name The index name\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern({}, {\n    db\n  }, options); // Create command\n\n  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\n  const index_name = selector.name; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Merge primary readPreference\n\n  finalOptions.readPreference = ReadPreference.PRIMARY; // Check if the index already exists\n\n  indexInformation(db, name, finalOptions, (err, indexInformation) => {\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null); // If the index does not exist, create it\n\n    if (indexInformation == null || !indexInformation[index_name]) {\n      createIndex(db, name, fieldOrSpec, options, callback);\n    } else {\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\n    }\n  });\n}\n/**\r\n * Evaluate JavaScript on the server\r\n *\r\n * @method\r\n * @param {Db} db The Db instance.\r\n * @param {Code} code JavaScript to execute on server.\r\n * @param {(object|array)} parameters The parameters for the call.\r\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\r\n */\n\n\nfunction evaluate(db, code, parameters, options, callback) {\n  let finalCode = code;\n  let finalParameters = []; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // If not a code object translate to one\n\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode); // Ensure the parameters are correct\n\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  } // Create execution selector\n\n\n  let cmd = {\n    $eval: finalCode,\n    args: finalParameters\n  }; // Check if the nolock parameter is passed in\n\n  if (options['nolock']) {\n    cmd['nolock'] = options['nolock'];\n  } // Set primary read preference\n\n\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY); // Execute the command\n\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\n    if (result) return handleCallback(callback, MongoError.create({\n      message: `eval failed: ${result.errmsg}`,\n      driver: true\n    }), null);\n    handleCallback(callback, err, result);\n  });\n}\n/**\r\n * Execute a command\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction executeCommand(db, command, options, callback) {\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Get the db name we are executing against\n\n  const dbName = options.dbName || options.authdb || db.databaseName; // Convert the readPreference if its not a write\n\n  options.readPreference = resolveReadPreference(db, options); // Debug information\n\n  if (db.s.logger.isDebug()) db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`); // Execute command\n\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, (err, result) => {\n    if (err) return handleCallback(callback, err);\n    if (options.full) return handleCallback(callback, null, result);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\r\n * Runs a command on the database as admin.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction executeDbAdminCommand(db, command, options, callback) {\n  const namespace = new MongoDBNamespace('admin', '$cmd');\n  db.s.topology.command(namespace, command, options, (err, result) => {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\r\n * Retrieves this collections index info.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the index info.\r\n * @param {string} name The name of the collection.\r\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n/**\r\n * Retrieve the current profiling information for MongoDB\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the profiling info.\r\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n * @deprecated Query the system.profile collection directly.\r\n */\n\n\nfunction profilingInfo(db, options, callback) {\n  try {\n    db.collection('system.profile').find({}, options).toArray(callback);\n  } catch (err) {\n    return callback(err, null);\n  }\n}\n/**\r\n * Remove a user from a database\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to remove the user.\r\n * @param {string} username The username.\r\n * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction removeUser(db, username, options, callback) {\n  let Db = loadDb(); // Attempt to execute command\n\n  executeAuthRemoveUserCommand(db, username, options, (err, result) => {\n    if (err && err.code === -5000) {\n      const finalOptions = applyWriteConcern(Object.assign({}, options), {\n        db\n      }, options); // If we have another db set\n\n      const db = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db; // Fetch a user collection\n\n      const collection = db.collection(CONSTANTS.SYSTEM_USER_COLLECTION); // Locate the user\n\n      findOne(collection, {\n        user: username\n      }, finalOptions, (err, user) => {\n        if (user == null) return handleCallback(callback, err, false);\n        remove(collection, {\n          user: username\n        }, finalOptions, err => {\n          handleCallback(callback, err, true);\n        });\n      });\n      return;\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, err, result);\n  });\n} // Validate the database name\n\n\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string') throw MongoError.create({\n    message: 'database name must be a string',\n    driver: true\n  });\n  if (databaseName.length === 0) throw MongoError.create({\n    message: 'database name cannot be the empty string',\n    driver: true\n  });\n  if (databaseName === '$external') return;\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\n\n  for (let i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1) throw MongoError.create({\n      message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\n      driver: true\n    });\n  }\n}\n/**\r\n * Create the command object for Db.prototype.createIndex.\r\n *\r\n * @param {Db} db The Db instance on which to create the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @return {Object} The insert command object.\r\n */\n\n\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\n  const indexParameters = parseIndexOptions(fieldOrSpec);\n  const fieldHash = indexParameters.fieldHash; // Generate the index name\n\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\n  const selector = {\n    ns: db.s.namespace.withCollection(name).toString(),\n    key: fieldHash,\n    name: indexName\n  }; // Ensure we have a correct finalUnique\n\n  const finalUnique = options == null || 'object' === typeof options ? false : options; // Set up options\n\n  options = options == null || typeof options === 'boolean' ? {} : options; // Add all the options\n\n  const keysToOmit = Object.keys(selector);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      selector[optionName] = options[optionName];\n    }\n  }\n\n  if (selector['unique'] == null) selector['unique'] = finalUnique; // Remove any write concern operations\n\n  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\n\n  for (let i = 0; i < removeKeys.length; i++) {\n    delete selector[removeKeys[i]];\n  } // Return the command creation selector\n\n\n  return selector;\n}\n/**\r\n * Create index using the createIndexes command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n */\n\n\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\n  // Build the index\n  const indexParameters = parseIndexOptions(fieldOrSpec); // Generate the index name\n\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const indexes = [{\n    name: indexName,\n    key: indexParameters.fieldHash\n  }]; // merge all the options\n\n  const keysToOmit = Object.keys(indexes[0]).concat(['writeConcern', 'w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session']);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      indexes[0][optionName] = options[optionName];\n    }\n  } // Get capabilities\n\n\n  const capabilities = db.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\n    // Create a new error\n    const error = new MongoError('server/primary/mongos does not support collation');\n    error.code = 67; // Return the error\n\n    return callback(error);\n  } // Create command, apply write concern to command\n\n\n  const cmd = applyWriteConcern({\n    createIndexes: name,\n    indexes\n  }, {\n    db\n  }, options); // ReadPreference primary\n\n  options.readPreference = ReadPreference.PRIMARY; // Build the command\n\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result.ok === 0) return handleCallback(callback, toError(result), null); // Return the indexName for backward compatibility\n\n    handleCallback(callback, null, indexName);\n  });\n}\n/**\r\n * Run the createUser command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} username The username of the user to add.\r\n * @param {string} password The password of the user to add.\r\n * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction executeAuthCreateUserCommand(db, username, password, options, callback) {\n  // Special case where there is no password ($external users)\n  if (typeof username === 'string' && password != null && typeof password === 'object') {\n    options = password;\n    password = null;\n  } // Unpack all options\n\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } // Error out if we digestPassword set\n\n\n  if (options.digestPassword != null) {\n    return callback(toError(\"The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.\"));\n  } // Get additional values\n\n\n  const customData = options.customData != null ? options.customData : {};\n  let roles = Array.isArray(options.roles) ? options.roles : [];\n  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null; // If not roles defined print deprecated message\n\n  if (roles.length === 0) {\n    console.log('Creating a user without roles is deprecated in MongoDB >= 2.6');\n  } // Get the error options\n\n\n  const commandOptions = {\n    writeCommand: true\n  };\n  if (options['dbName']) commandOptions.dbName = options['dbName']; // Add maxTimeMS to options if set\n\n  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS; // Check the db name and add roles if needed\n\n  if ((db.databaseName.toLowerCase() === 'admin' || options.dbName === 'admin') && !Array.isArray(options.roles)) {\n    roles = ['root'];\n  } else if (!Array.isArray(options.roles)) {\n    roles = ['dbOwner'];\n  }\n\n  const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7; // Build the command to execute\n\n  let command = {\n    createUser: username,\n    customData: customData,\n    roles: roles,\n    digestPassword\n  }; // Apply write concern to command\n\n  command = applyWriteConcern(command, {\n    db\n  }, options);\n  let userPassword = password;\n\n  if (!digestPassword) {\n    // Use node md5 generator\n    const md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n    md5.update(username + ':mongo:' + password);\n    userPassword = md5.digest('hex');\n  } // No password\n\n\n  if (typeof password === 'string') {\n    command.pwd = userPassword;\n  } // Force write using primary\n\n\n  commandOptions.readPreference = ReadPreference.primary; // Execute the command\n\n  executeCommand(db, command, commandOptions, (err, result) => {\n    if (err && err.ok === 0 && err.code === undefined) return handleCallback(callback, {\n      code: -5000\n    }, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, !result.ok ? toError(result) : null, result.ok ? [{\n      user: username,\n      pwd: ''\n    }] : null);\n  });\n}\n/**\r\n * Run the dropUser command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} username The username of the user to remove.\r\n * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction executeAuthRemoveUserCommand(db, username, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Get the error options\n\n  const commandOptions = {\n    writeCommand: true\n  };\n  if (options['dbName']) commandOptions.dbName = options['dbName']; // Get additional values\n\n  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null; // Add maxTimeMS to options if set\n\n  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS; // Build the command to execute\n\n  let command = {\n    dropUser: username\n  }; // Apply write concern to command\n\n  command = applyWriteConcern(command, {\n    db\n  }, options); // Force write using primary\n\n  commandOptions.readPreference = ReadPreference.primary; // Execute the command\n\n  executeCommand(db, command, commandOptions, (err, result) => {\n    if (err && !err.ok && err.code === undefined) return handleCallback(callback, {\n      code: -5000\n    });\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result.ok ? true : false);\n  });\n}\n\nmodule.exports = {\n  addUser,\n  collections,\n  createListener,\n  createIndex,\n  dropCollection,\n  dropDatabase,\n  ensureIndex,\n  evaluate,\n  executeCommand,\n  executeDbAdminCommand,\n  indexInformation,\n  profilingInfo,\n  removeUser,\n  validateDatabaseName\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/db_ops.js"],"names":["applyWriteConcern","require","Code","BSON","resolveReadPreference","crypto","debugOptions","handleCallback","MongoError","parseIndexOptions","ReadPreference","toError","CONSTANTS","MongoDBNamespace","count","findOne","remove","updateOne","collection","loadCollection","db","loadDb","debugFields","addUser","username","password","options","callback","Db","serverConfig","isDestroyed","executeAuthCreateUserCommand","err","r","code","finalOptions","Object","assign","md5","createHash","update","userPassword","digest","dbToUse","dbName","s","topology","SYSTEM_USER_COLLECTION","findOptions","projection","find","user","toArray","upsert","$set","pwd","collections","Collection","nameOnly","listCollections","documents","filter","doc","name","indexOf","map","d","databaseName","pkFactory","createIndex","fieldOrSpec","readPreference","PRIMARY","writeConcern","create","message","driver","createIndexUsingCreateIndexes","result","createCreateIndexCommand","checkKeys","insert","namespace","withCollection","SYSTEM_INDEX_COLLECTION","writeErrors","createListener","e","object","listener","listeners","length","emit","i","children","dropCollection","executeCommand","ok","dropDatabase","cmd","ensureIndex","selector","index_name","indexInformation","evaluate","parameters","finalCode","finalParameters","_bsontype","Array","isArray","$eval","args","retval","errmsg","command","authdb","logger","isDebug","debug","JSON","stringify","full","executeDbAdminCommand","processResults","indexes","info","index","key","push","listIndexes","profilingInfo","removeUser","executeAuthRemoveUserCommand","validateDatabaseName","invalidChars","indexParameters","fieldHash","indexName","ns","toString","finalUnique","keysToOmit","keys","optionName","removeKeys","concat","capabilities","collation","commandsTakeCollation","error","createIndexes","digestPassword","customData","roles","maxTimeMS","console","log","commandOptions","writeCommand","toLowerCase","lastIsMaster","maxWireVersion","createUser","primary","undefined","dropUser","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst applyWriteConcern = require('../utils').applyWriteConcern;\r\nconst Code = require('../core').BSON.Code;\r\nconst resolveReadPreference = require('../utils').resolveReadPreference;\r\nconst crypto = require('crypto');\r\nconst debugOptions = require('../utils').debugOptions;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst MongoError = require('../core').MongoError;\r\nconst parseIndexOptions = require('../utils').parseIndexOptions;\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst toError = require('../utils').toError;\r\nconst CONSTANTS = require('../constants');\r\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\r\n\r\nconst count = require('./collection_ops').count;\r\nconst findOne = require('./collection_ops').findOne;\r\nconst remove = require('./collection_ops').remove;\r\nconst updateOne = require('./collection_ops').updateOne;\r\n\r\nlet collection;\r\nfunction loadCollection() {\r\n  if (!collection) {\r\n    collection = require('../collection');\r\n  }\r\n  return collection;\r\n}\r\nlet db;\r\nfunction loadDb() {\r\n  if (!db) {\r\n    db = require('../db');\r\n  }\r\n  return db;\r\n}\r\n\r\nconst debugFields = [\r\n  'authSource',\r\n  'w',\r\n  'wtimeout',\r\n  'j',\r\n  'native_parser',\r\n  'forceServerObjectId',\r\n  'serializeFunctions',\r\n  'raw',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'bufferMaxEntries',\r\n  'numberOfRetries',\r\n  'retryMiliSeconds',\r\n  'readPreference',\r\n  'pkFactory',\r\n  'parentDb',\r\n  'promiseLibrary',\r\n  'noListener'\r\n];\r\n\r\n/**\r\n * Add a user to the database.\r\n * @method\r\n * @param {Db} db The Db instance on which to add a user.\r\n * @param {string} username The username.\r\n * @param {string} password The password.\r\n * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction addUser(db, username, password, options, callback) {\r\n  let Db = loadDb();\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Attempt to execute auth command\r\n  executeAuthCreateUserCommand(db, username, password, options, (err, r) => {\r\n    // We need to perform the backward compatible insert operation\r\n    if (err && err.code === -5000) {\r\n      const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);\r\n\r\n      // Use node md5 generator\r\n      const md5 = crypto.createHash('md5');\r\n      // Generate keys used for authentication\r\n      md5.update(username + ':mongo:' + password);\r\n      const userPassword = md5.digest('hex');\r\n\r\n      // If we have another db set\r\n      const dbToUse = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;\r\n\r\n      // Fetch a user collection\r\n      const collection = dbToUse.collection(CONSTANTS.SYSTEM_USER_COLLECTION);\r\n\r\n      // Check if we are inserting the first user\r\n      count(collection, {}, finalOptions, (err, count) => {\r\n        // We got an error (f.ex not authorized)\r\n        if (err != null) return handleCallback(callback, err, null);\r\n        // Check if the user exists and update i\r\n        const findOptions = Object.assign({ projection: { dbName: 1 } }, finalOptions);\r\n        collection.find({ user: username }, findOptions).toArray(err => {\r\n          // We got an error (f.ex not authorized)\r\n          if (err != null) return handleCallback(callback, err, null);\r\n          // Add command keys\r\n          finalOptions.upsert = true;\r\n\r\n          // We have a user, let's update the password or upsert if not\r\n          updateOne(\r\n            collection,\r\n            { user: username },\r\n            { $set: { user: username, pwd: userPassword } },\r\n            finalOptions,\r\n            err => {\r\n              if (count === 0 && err)\r\n                return handleCallback(callback, null, [{ user: username, pwd: userPassword }]);\r\n              if (err) return handleCallback(callback, err, null);\r\n              handleCallback(callback, null, [{ user: username, pwd: userPassword }]);\r\n            }\r\n          );\r\n        });\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (err) return handleCallback(callback, err);\r\n    handleCallback(callback, err, r);\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch all collections for the current db.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to fetch collections.\r\n * @param {object} [options] Optional settings. See Db.prototype.collections for a list of options.\r\n * @param {Db~collectionsResultCallback} [callback] The results callback\r\n */\r\nfunction collections(db, options, callback) {\r\n  let Collection = loadCollection();\r\n\r\n  options = Object.assign({}, options, { nameOnly: true });\r\n  // Let's get the collection names\r\n  db.listCollections({}, options).toArray((err, documents) => {\r\n    if (err != null) return handleCallback(callback, err, null);\r\n    // Filter collections removing any illegal ones\r\n    documents = documents.filter(doc => {\r\n      return doc.name.indexOf('$') === -1;\r\n    });\r\n\r\n    // Return the collection objects\r\n    handleCallback(\r\n      callback,\r\n      null,\r\n      documents.map(d => {\r\n        return new Collection(\r\n          db,\r\n          db.s.topology,\r\n          db.databaseName,\r\n          d.name,\r\n          db.s.pkFactory,\r\n          db.s.options\r\n        );\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Creates an index on the db and collection.\r\n * @method\r\n * @param {Db} db The Db instance on which to create an index.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\r\n  // Get the write concern options\r\n  let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);\r\n  finalOptions = applyWriteConcern(finalOptions, { db }, options);\r\n\r\n  // Ensure we have a callback\r\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\r\n    throw MongoError.create({\r\n      message: 'Cannot use a writeConcern without a provided callback',\r\n      driver: true\r\n    });\r\n  }\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n\r\n  // Attempt to run using createIndexes command\r\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {\r\n    if (err == null) return handleCallback(callback, err, result);\r\n\r\n    /**\r\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\r\n     * 67 = 'CannotCreateIndex' (malformed index options)\r\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\r\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\r\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\r\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\r\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\r\n     */\r\n    if (\r\n      err.code === 67 ||\r\n      err.code === 11000 ||\r\n      err.code === 85 ||\r\n      err.code === 86 ||\r\n      err.code === 11600 ||\r\n      err.code === 197\r\n    ) {\r\n      return handleCallback(callback, err, result);\r\n    }\r\n\r\n    // Create command\r\n    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);\r\n    // Set no key checking\r\n    finalOptions.checkKeys = false;\r\n    // Insert document\r\n    db.s.topology.insert(\r\n      db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION),\r\n      doc,\r\n      finalOptions,\r\n      (err, result) => {\r\n        if (callback == null) return;\r\n        if (err) return handleCallback(callback, err);\r\n        if (result == null) return handleCallback(callback, null, null);\r\n        if (result.result.writeErrors)\r\n          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\r\n        handleCallback(callback, null, doc.name);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n// Add listeners to topology\r\nfunction createListener(db, e, object) {\r\n  function listener(err) {\r\n    if (object.listeners(e).length > 0) {\r\n      object.emit(e, err, db);\r\n\r\n      // Emit on all associated db's if available\r\n      for (let i = 0; i < db.s.children.length; i++) {\r\n        db.s.children[i].emit(e, err, db.s.children[i]);\r\n      }\r\n    }\r\n  }\r\n  return listener;\r\n}\r\n\r\n/**\r\n * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to drop the collection.\r\n * @param {string} name Name of collection to drop\r\n * @param {Object} [options] Optional settings. See Db.prototype.dropCollection for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n */\r\nfunction dropCollection(db, name, options, callback) {\r\n  executeCommand(db, name, options, (err, result) => {\r\n    // Did the user destroy the topology\r\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\r\n      return callback(new MongoError('topology was destroyed'));\r\n    }\r\n\r\n    if (err) return handleCallback(callback, err);\r\n    if (result.ok) return handleCallback(callback, null, true);\r\n    handleCallback(callback, null, false);\r\n  });\r\n}\r\n\r\n/**\r\n * Drop a database, removing it permanently from the server.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance to drop.\r\n * @param {Object} cmd The command document.\r\n * @param {Object} [options] Optional settings. See Db.prototype.dropDatabase for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n */\r\nfunction dropDatabase(db, cmd, options, callback) {\r\n  executeCommand(db, cmd, options, (err, result) => {\r\n    // Did the user destroy the topology\r\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\r\n      return callback(new MongoError('topology was destroyed'));\r\n    }\r\n\r\n    if (callback == null) return;\r\n    if (err) return handleCallback(callback, err, null);\r\n    handleCallback(callback, null, result.ok ? true : false);\r\n  });\r\n}\r\n\r\n/**\r\n * Ensures that an index exists. If it does not, creates it.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to ensure the index.\r\n * @param {string} name The index name\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\r\n  // Get the write concern options\r\n  const finalOptions = applyWriteConcern({}, { db }, options);\r\n  // Create command\r\n  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\r\n  const index_name = selector.name;\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n\r\n  // Merge primary readPreference\r\n  finalOptions.readPreference = ReadPreference.PRIMARY;\r\n\r\n  // Check if the index already exists\r\n  indexInformation(db, name, finalOptions, (err, indexInformation) => {\r\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null);\r\n    // If the index does not exist, create it\r\n    if (indexInformation == null || !indexInformation[index_name]) {\r\n      createIndex(db, name, fieldOrSpec, options, callback);\r\n    } else {\r\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Evaluate JavaScript on the server\r\n *\r\n * @method\r\n * @param {Db} db The Db instance.\r\n * @param {Code} code JavaScript to execute on server.\r\n * @param {(object|array)} parameters The parameters for the call.\r\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\r\n */\r\nfunction evaluate(db, code, parameters, options, callback) {\r\n  let finalCode = code;\r\n  let finalParameters = [];\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n\r\n  // If not a code object translate to one\r\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);\r\n  // Ensure the parameters are correct\r\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\r\n    finalParameters = [parameters];\r\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\r\n    finalParameters = parameters;\r\n  }\r\n\r\n  // Create execution selector\r\n  let cmd = { $eval: finalCode, args: finalParameters };\r\n  // Check if the nolock parameter is passed in\r\n  if (options['nolock']) {\r\n    cmd['nolock'] = options['nolock'];\r\n  }\r\n\r\n  // Set primary read preference\r\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);\r\n\r\n  // Execute the command\r\n  executeCommand(db, cmd, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\r\n    if (result)\r\n      return handleCallback(\r\n        callback,\r\n        MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }),\r\n        null\r\n      );\r\n    handleCallback(callback, err, result);\r\n  });\r\n}\r\n\r\n/**\r\n * Execute a command\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction executeCommand(db, command, options, callback) {\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Get the db name we are executing against\r\n  const dbName = options.dbName || options.authdb || db.databaseName;\r\n\r\n  // Convert the readPreference if its not a write\r\n  options.readPreference = resolveReadPreference(db, options);\r\n\r\n  // Debug information\r\n  if (db.s.logger.isDebug())\r\n    db.s.logger.debug(\r\n      `executing command ${JSON.stringify(\r\n        command\r\n      )} against ${dbName}.$cmd with options [${JSON.stringify(\r\n        debugOptions(debugFields, options)\r\n      )}]`\r\n    );\r\n\r\n  // Execute command\r\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err);\r\n    if (options.full) return handleCallback(callback, null, result);\r\n    handleCallback(callback, null, result.result);\r\n  });\r\n}\r\n\r\n/**\r\n * Runs a command on the database as admin.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction executeDbAdminCommand(db, command, options, callback) {\r\n  const namespace = new MongoDBNamespace('admin', '$cmd');\r\n\r\n  db.s.topology.command(namespace, command, options, (err, result) => {\r\n    // Did the user destroy the topology\r\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\r\n      return callback(new MongoError('topology was destroyed'));\r\n    }\r\n\r\n    if (err) return handleCallback(callback, err);\r\n    handleCallback(callback, null, result.result);\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves this collections index info.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the index info.\r\n * @param {string} name The name of the collection.\r\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction indexInformation(db, name, options, callback) {\r\n  // If we specified full information\r\n  const full = options['full'] == null ? false : options['full'];\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Process all the results from the index command and collection\r\n  function processResults(indexes) {\r\n    // Contains all the information\r\n    let info = {};\r\n    // Process all the indexes\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      const index = indexes[i];\r\n      // Let's unpack the object\r\n      info[index.name] = [];\r\n      for (let name in index.key) {\r\n        info[index.name].push([name, index.key[name]]);\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n\r\n  // Get the list of indexes of the specified collection\r\n  db\r\n    .collection(name)\r\n    .listIndexes(options)\r\n    .toArray((err, indexes) => {\r\n      if (err) return callback(toError(err));\r\n      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\r\n      if (full) return handleCallback(callback, null, indexes);\r\n      handleCallback(callback, null, processResults(indexes));\r\n    });\r\n}\r\n\r\n/**\r\n * Retrieve the current profiling information for MongoDB\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the profiling info.\r\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n * @deprecated Query the system.profile collection directly.\r\n */\r\nfunction profilingInfo(db, options, callback) {\r\n  try {\r\n    db\r\n      .collection('system.profile')\r\n      .find({}, options)\r\n      .toArray(callback);\r\n  } catch (err) {\r\n    return callback(err, null);\r\n  }\r\n}\r\n\r\n/**\r\n * Remove a user from a database\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to remove the user.\r\n * @param {string} username The username.\r\n * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction removeUser(db, username, options, callback) {\r\n  let Db = loadDb();\r\n\r\n  // Attempt to execute command\r\n  executeAuthRemoveUserCommand(db, username, options, (err, result) => {\r\n    if (err && err.code === -5000) {\r\n      const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);\r\n      // If we have another db set\r\n      const db = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;\r\n\r\n      // Fetch a user collection\r\n      const collection = db.collection(CONSTANTS.SYSTEM_USER_COLLECTION);\r\n\r\n      // Locate the user\r\n      findOne(collection, { user: username }, finalOptions, (err, user) => {\r\n        if (user == null) return handleCallback(callback, err, false);\r\n        remove(collection, { user: username }, finalOptions, err => {\r\n          handleCallback(callback, err, true);\r\n        });\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (err) return handleCallback(callback, err);\r\n    handleCallback(callback, err, result);\r\n  });\r\n}\r\n\r\n// Validate the database name\r\nfunction validateDatabaseName(databaseName) {\r\n  if (typeof databaseName !== 'string')\r\n    throw MongoError.create({ message: 'database name must be a string', driver: true });\r\n  if (databaseName.length === 0)\r\n    throw MongoError.create({ message: 'database name cannot be the empty string', driver: true });\r\n  if (databaseName === '$external') return;\r\n\r\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\r\n  for (let i = 0; i < invalidChars.length; i++) {\r\n    if (databaseName.indexOf(invalidChars[i]) !== -1)\r\n      throw MongoError.create({\r\n        message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\r\n        driver: true\r\n      });\r\n  }\r\n}\r\n\r\n/**\r\n * Create the command object for Db.prototype.createIndex.\r\n *\r\n * @param {Db} db The Db instance on which to create the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @return {Object} The insert command object.\r\n */\r\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\r\n  const indexParameters = parseIndexOptions(fieldOrSpec);\r\n  const fieldHash = indexParameters.fieldHash;\r\n\r\n  // Generate the index name\r\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\r\n  const selector = {\r\n    ns: db.s.namespace.withCollection(name).toString(),\r\n    key: fieldHash,\r\n    name: indexName\r\n  };\r\n\r\n  // Ensure we have a correct finalUnique\r\n  const finalUnique = options == null || 'object' === typeof options ? false : options;\r\n  // Set up options\r\n  options = options == null || typeof options === 'boolean' ? {} : options;\r\n\r\n  // Add all the options\r\n  const keysToOmit = Object.keys(selector);\r\n  for (let optionName in options) {\r\n    if (keysToOmit.indexOf(optionName) === -1) {\r\n      selector[optionName] = options[optionName];\r\n    }\r\n  }\r\n\r\n  if (selector['unique'] == null) selector['unique'] = finalUnique;\r\n\r\n  // Remove any write concern operations\r\n  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\r\n  for (let i = 0; i < removeKeys.length; i++) {\r\n    delete selector[removeKeys[i]];\r\n  }\r\n\r\n  // Return the command creation selector\r\n  return selector;\r\n}\r\n\r\n/**\r\n * Create index using the createIndexes command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n */\r\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\r\n  // Build the index\r\n  const indexParameters = parseIndexOptions(fieldOrSpec);\r\n  // Generate the index name\r\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\r\n  // Set up the index\r\n  const indexes = [{ name: indexName, key: indexParameters.fieldHash }];\r\n  // merge all the options\r\n  const keysToOmit = Object.keys(indexes[0]).concat([\r\n    'writeConcern',\r\n    'w',\r\n    'wtimeout',\r\n    'j',\r\n    'fsync',\r\n    'readPreference',\r\n    'session'\r\n  ]);\r\n\r\n  for (let optionName in options) {\r\n    if (keysToOmit.indexOf(optionName) === -1) {\r\n      indexes[0][optionName] = options[optionName];\r\n    }\r\n  }\r\n\r\n  // Get capabilities\r\n  const capabilities = db.s.topology.capabilities();\r\n\r\n  // Did the user pass in a collation, check if our write server supports it\r\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\r\n    // Create a new error\r\n    const error = new MongoError('server/primary/mongos does not support collation');\r\n    error.code = 67;\r\n    // Return the error\r\n    return callback(error);\r\n  }\r\n\r\n  // Create command, apply write concern to command\r\n  const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options);\r\n\r\n  // ReadPreference primary\r\n  options.readPreference = ReadPreference.PRIMARY;\r\n\r\n  // Build the command\r\n  executeCommand(db, cmd, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result.ok === 0) return handleCallback(callback, toError(result), null);\r\n    // Return the indexName for backward compatibility\r\n    handleCallback(callback, null, indexName);\r\n  });\r\n}\r\n\r\n/**\r\n * Run the createUser command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} username The username of the user to add.\r\n * @param {string} password The password of the user to add.\r\n * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction executeAuthCreateUserCommand(db, username, password, options, callback) {\r\n  // Special case where there is no password ($external users)\r\n  if (typeof username === 'string' && password != null && typeof password === 'object') {\r\n    options = password;\r\n    password = null;\r\n  }\r\n\r\n  // Unpack all options\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  // Error out if we digestPassword set\r\n  if (options.digestPassword != null) {\r\n    return callback(\r\n      toError(\r\n        \"The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.\"\r\n      )\r\n    );\r\n  }\r\n\r\n  // Get additional values\r\n  const customData = options.customData != null ? options.customData : {};\r\n  let roles = Array.isArray(options.roles) ? options.roles : [];\r\n  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;\r\n\r\n  // If not roles defined print deprecated message\r\n  if (roles.length === 0) {\r\n    console.log('Creating a user without roles is deprecated in MongoDB >= 2.6');\r\n  }\r\n\r\n  // Get the error options\r\n  const commandOptions = { writeCommand: true };\r\n  if (options['dbName']) commandOptions.dbName = options['dbName'];\r\n\r\n  // Add maxTimeMS to options if set\r\n  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;\r\n\r\n  // Check the db name and add roles if needed\r\n  if (\r\n    (db.databaseName.toLowerCase() === 'admin' || options.dbName === 'admin') &&\r\n    !Array.isArray(options.roles)\r\n  ) {\r\n    roles = ['root'];\r\n  } else if (!Array.isArray(options.roles)) {\r\n    roles = ['dbOwner'];\r\n  }\r\n\r\n  const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;\r\n\r\n  // Build the command to execute\r\n  let command = {\r\n    createUser: username,\r\n    customData: customData,\r\n    roles: roles,\r\n    digestPassword\r\n  };\r\n\r\n  // Apply write concern to command\r\n  command = applyWriteConcern(command, { db }, options);\r\n\r\n  let userPassword = password;\r\n\r\n  if (!digestPassword) {\r\n    // Use node md5 generator\r\n    const md5 = crypto.createHash('md5');\r\n    // Generate keys used for authentication\r\n    md5.update(username + ':mongo:' + password);\r\n    userPassword = md5.digest('hex');\r\n  }\r\n\r\n  // No password\r\n  if (typeof password === 'string') {\r\n    command.pwd = userPassword;\r\n  }\r\n\r\n  // Force write using primary\r\n  commandOptions.readPreference = ReadPreference.primary;\r\n\r\n  // Execute the command\r\n  executeCommand(db, command, commandOptions, (err, result) => {\r\n    if (err && err.ok === 0 && err.code === undefined)\r\n      return handleCallback(callback, { code: -5000 }, null);\r\n    if (err) return handleCallback(callback, err, null);\r\n    handleCallback(\r\n      callback,\r\n      !result.ok ? toError(result) : null,\r\n      result.ok ? [{ user: username, pwd: '' }] : null\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Run the dropUser command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} username The username of the user to remove.\r\n * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction executeAuthRemoveUserCommand(db, username, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Get the error options\r\n  const commandOptions = { writeCommand: true };\r\n  if (options['dbName']) commandOptions.dbName = options['dbName'];\r\n\r\n  // Get additional values\r\n  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;\r\n\r\n  // Add maxTimeMS to options if set\r\n  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;\r\n\r\n  // Build the command to execute\r\n  let command = {\r\n    dropUser: username\r\n  };\r\n\r\n  // Apply write concern to command\r\n  command = applyWriteConcern(command, { db }, options);\r\n\r\n  // Force write using primary\r\n  commandOptions.readPreference = ReadPreference.primary;\r\n\r\n  // Execute the command\r\n  executeCommand(db, command, commandOptions, (err, result) => {\r\n    if (err && !err.ok && err.code === undefined) return handleCallback(callback, { code: -5000 });\r\n    if (err) return handleCallback(callback, err, null);\r\n    handleCallback(callback, null, result.ok ? true : false);\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  addUser,\r\n  collections,\r\n  createListener,\r\n  createIndex,\r\n  dropCollection,\r\n  dropDatabase,\r\n  ensureIndex,\r\n  evaluate,\r\n  executeCommand,\r\n  executeDbAdminCommand,\r\n  indexInformation,\r\n  profilingInfo,\r\n  removeUser,\r\n  validateDatabaseName\r\n};\r\n"]},"metadata":{},"sourceType":"script"}