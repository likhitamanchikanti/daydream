{"ast":null,"code":"'use strict';\n\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\n\nconst EventEmitter = require('events');\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nconst uuidV4 = require('./utils').uuidV4;\n\nconst MongoError = require('./error').MongoError;\n\nconst isRetryableError = require('././error').isRetryableError;\n\nconst MongoNetworkError = require('./error').MongoNetworkError;\n\nconst MongoWriteConcernError = require('./error').MongoWriteConcernError;\n\nconst Transaction = require('./transactions').Transaction;\n\nconst TxnState = require('./transactions').TxnState;\n\nconst isPromiseLike = require('./utils').isPromiseLike;\n\nconst ReadPreference = require('./topologies/read_preference');\n\nconst isTransactionCommand = require('./transactions').isTransactionCommand;\n\nconst resolveClusterTime = require('./topologies/shared').resolveClusterTime;\n\nconst isSharded = require('./wireprotocol/shared').isSharded;\n\nconst maxWireVersion = require('./utils').maxWireVersion;\n\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new MongoError('Cannot use a session that has ended');\n\n    if (typeof callback === 'function') {\n      callback(error, null);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n/**\r\n * Options to pass when creating a Client Session\r\n * @typedef {Object} SessionOptions\r\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\r\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\r\n */\n\n/**\r\n * A BSON document reflecting the lsid of a {@link ClientSession}\r\n * @typedef {Object} SessionId\r\n */\n\n/**\r\n * A class representing a client session on the server\r\n * WARNING: not meant to be instantiated directly.\r\n * @class\r\n * @hideconstructor\r\n */\n\n\nclass ClientSession extends EventEmitter {\n  /**\r\n   * Create a client session.\r\n   * WARNING: not meant to be instantiated directly\r\n   *\r\n   * @param {Topology} topology The current client's topology (Internal Class)\r\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\r\n   * @param {SessionOptions} [options] Optional settings\r\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\r\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n\n    if (topology == null) {\n      throw new Error('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new Error('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options || {};\n    clientOptions = clientOptions || {};\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.serverSession = sessionPool.acquire();\n    this.clientOptions = clientOptions;\n    this.supports = {\n      causalConsistency: typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = null;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n  /**\r\n   * The server id associated with this session\r\n   * @type {SessionId}\r\n   */\n\n\n  get id() {\n    return this.serverSession.id;\n  }\n  /**\r\n   * Ends this session on the server\r\n   *\r\n   * @param {Object} [options] Optional settings. Currently reserved for future use\r\n   * @param {Function} [callback] Optional callback for completion of this operation\r\n   */\n\n\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {};\n\n    if (this.hasEnded) {\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    if (this.serverSession && this.inTransaction()) {\n      this.abortTransaction(); // pass in callback?\n    } // mark the session as ended, and emit a signal\n\n\n    this.hasEnded = true;\n    this.emit('ended', this); // release the server session back to the pool\n\n    this.sessionPool.release(this.serverSession);\n    this.serverSession = null; // spec indicates that we should ignore all errors for `endSessions`\n\n    if (typeof callback === 'function') callback(null, null);\n  }\n  /**\r\n   * Advances the operationTime for a ClientSession.\r\n   *\r\n   * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\r\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\r\n   * Used to determine if this session equals another\r\n   * @param {ClientSession} session\r\n   * @return {boolean} true if the sessions are equal\r\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /**\r\n   * Increment the transaction number on the internal ServerSession\r\n   */\n\n\n  incrementTransactionNumber() {\n    this.serverSession.txnNumber++;\n  }\n  /**\r\n   * @returns {boolean} whether this session is currently in a transaction or not\r\n   */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\r\n   * Starts a new transaction with the given options.\r\n   *\r\n   * @param {TransactionOptions} options Options for the transaction\r\n   */\n\n\n  startTransaction(options) {\n    assertAlive(this);\n\n    if (this.inTransaction()) {\n      throw new MongoError('Transaction already in progress');\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n\n    if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n  /**\r\n   * Commits the currently active transaction in this session.\r\n   *\r\n   * @param {Function} [callback] optional callback for completion of this operation\r\n   * @return {Promise} A promise is returned if no callback is provided\r\n   */\n\n\n  commitTransaction(callback) {\n    if (typeof callback === 'function') {\n      endTransaction(this, 'commitTransaction', callback);\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      endTransaction(this, 'commitTransaction', (err, reply) => err ? reject(err) : resolve(reply));\n    });\n  }\n  /**\r\n   * Aborts the currently active transaction in this session.\r\n   *\r\n   * @param {Function} [callback] optional callback for completion of this operation\r\n   * @return {Promise} A promise is returned if no callback is provided\r\n   */\n\n\n  abortTransaction(callback) {\n    if (typeof callback === 'function') {\n      endTransaction(this, 'abortTransaction', callback);\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      endTransaction(this, 'abortTransaction', (err, reply) => err ? reject(err) : resolve(reply));\n    });\n  }\n  /**\r\n   * This is here to ensure that ClientSession is never serialized to BSON.\r\n   * @ignore\r\n   */\n\n\n  toBSON() {\n    throw new Error('ClientSession cannot be serialized to BSON.');\n  }\n  /**\r\n   * A user provided function to be run within a transaction\r\n   *\r\n   * @callback WithTransactionCallback\r\n   * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\r\n   * @returns {Promise} The resulting Promise of operations run within this transaction\r\n   */\n\n  /**\r\n   * Runs a provided lambda within a transaction, retrying either the commit operation\r\n   * or entire transaction as needed (and when the error permits) to better ensure that\r\n   * the transaction can complete successfully.\r\n   *\r\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\r\n   * return a Promise will result in undefined behavior.\r\n   *\r\n   * @param {WithTransactionCallback} fn\r\n   * @param {TransactionOptions} [options] Optional settings for the transaction\r\n   */\n\n\n  withTransaction(fn, options) {\n    const startTime = Date.now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\nconst UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\nconst MAX_TIME_MS_EXPIRED_CODE = 50;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return Date.now() - startTime < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;\n}\n\nfunction isMaxTimeMSExpiredError(err) {\n  return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([TxnState.NO_TRANSACTION, TxnState.TRANSACTION_COMMITTED, TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }).catch(err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        if (err.errorLabels == null) {\n          err.errorLabels = [];\n        }\n\n        err.errorLabels.push('UnknownTransactionCommitResult');\n      }\n\n      throw err;\n    }\n\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  } // handle any initial problematic cases\n\n\n  let txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.w) {\n    writeConcern = {\n      w: session.clientOptions.w\n    };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName === 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n\n      if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {\n        if (e.errorLabels) {\n          const idx = e.errorLabels.indexOf('TransientTransactionError');\n\n          if (idx !== -1) {\n            e.errorLabels.splice(idx, 1);\n          }\n        } else {\n          e.errorLabels = [];\n        }\n\n        if (isUnknownTransactionCommitResult(e)) {\n          e.errorLabels.push('UnknownTransactionCommitResult'); // per txns spec, must unpin session in this case\n\n          session.transaction.unpinServer();\n        }\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    }\n\n    callback(e, r);\n  } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n  function transactionError(err) {\n    return commandName === 'commitTransaction' ? err : null;\n  }\n\n  if ( // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  session.transaction.recoveryToken && supportsRecoveryToken(session)) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  session.topology.command('admin.$cmd', command, {\n    session\n  }, (err, reply) => {\n    if (err && isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return session.topology.command('admin.$cmd', command, {\n        session\n      }, (_err, _reply) => commandHandler(transactionError(_err), _reply));\n    }\n\n    commandHandler(transactionError(err), reply);\n  });\n}\n\nfunction supportsRecoveryToken(session) {\n  const topology = session.topology;\n  return !!topology.s.options.useRecoveryToken;\n}\n/**\r\n * Reflects the existence of a session on the server. Can be reused by the session pool.\r\n * WARNING: not meant to be instantiated directly. For internal use only.\r\n * @ignore\r\n */\n\n\nclass ServerSession {\n  constructor() {\n    this.id = {\n      id: new Binary(uuidV4(), Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = Date.now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\r\n   * Determines if the server session has timed out.\r\n   * @ignore\r\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\r\n   * @return {boolean} true if the session has timed out.\r\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((Date.now() - this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n}\n/**\r\n * Maintains a pool of Server Sessions.\r\n * For internal use only\r\n * @ignore\r\n */\n\n\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new Error('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /**\r\n   * Ends all sessions in the session pool.\r\n   * @ignore\r\n   */\n\n\n  endAllPooledSessions() {\n    if (this.sessions.length) {\n      this.topology.endSessions(this.sessions.map(session => session.id));\n      this.sessions = [];\n    }\n  }\n  /**\r\n   * Acquire a Server Session from the pool.\r\n   * Iterates through each session in the pool, removing any stale sessions\r\n   * along the way. The first non-stale session found is removed from the\r\n   * pool and returned. If no non-stale session is found, a new ServerSession\r\n   * is created.\r\n   * @ignore\r\n   * @returns {ServerSession}\r\n   */\n\n\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n  /**\r\n   * Release a session to the session pool\r\n   * Adds the session back to the session pool if the session has not timed out yet.\r\n   * This method also removes any stale sessions from the pool.\r\n   * @ignore\r\n   * @param {ServerSession} session The session to release to the pool\r\n   */\n\n\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n} // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {\n    return true;\n  }\n\n  if (command.mapReduce && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Optionally decorate a command with sessions specific keys\r\n *\r\n * @param {ClientSession} session the session tracking transaction state\r\n * @param {Object} command the command to decorate\r\n * @param {Object} topology the topology for tracking the cluster time\r\n * @param {Object} [options] Optional settings passed to calling operation\r\n * @return {MongoError|null} An error, if some error condition was met\r\n */\n\n\nfunction applySession(session, command, options) {\n  const serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    return new MongoError('Cannot use a session that has ended');\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = Date.now();\n  command.lsid = serverSession.id; // first apply non-transaction-specific sessions data\n\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options.willRetryWrite;\n  const shouldApplyReadConcern = commandSupportsReadConcern(command);\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  } // now attempt to apply transaction-specific sessions data\n\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    } // TODO: the following should only be applied to read operation per spec.\n    // for causal consistency\n\n\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(`Read preference in a transaction must be primary, not: ${options.readPreference.mode}`);\n  } // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n}\n\nmodule.exports = {\n  ClientSession,\n  ServerSession,\n  ServerSessionPool,\n  TxnState,\n  applySession,\n  updateSessionFromResponse,\n  commandSupportsReadConcern\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/sessions.js"],"names":["retrieveBSON","require","EventEmitter","BSON","Binary","uuidV4","MongoError","isRetryableError","MongoNetworkError","MongoWriteConcernError","Transaction","TxnState","isPromiseLike","ReadPreference","isTransactionCommand","resolveClusterTime","isSharded","maxWireVersion","minWireVersionForShardedTransactions","assertAlive","session","callback","serverSession","error","ClientSession","constructor","topology","sessionPool","options","clientOptions","Error","ServerSessionPool","hasEnded","acquire","supports","causalConsistency","clusterTime","initialClusterTime","operationTime","explicit","owner","defaultTransactionOptions","Object","assign","transaction","id","endSession","inTransaction","abortTransaction","emit","release","advanceOperationTime","greaterThan","equals","buffer","incrementTransactionNumber","txnNumber","isActive","startTransaction","topologyMaxWireVersion","transition","STARTING_TRANSACTION","commitTransaction","endTransaction","Promise","resolve","reject","err","reply","toBSON","withTransaction","fn","startTime","Date","now","attemptTransaction","MAX_WITH_TRANSACTION_TIMEOUT","UNSATISFIABLE_WRITE_CONCERN_CODE","UNKNOWN_REPL_WRITE_CONCERN_CODE","MAX_TIME_MS_EXPIRED_CODE","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","isUnknownTransactionCommitResult","isMaxTimeMSExpiredError","has","codeName","code","writeConcernError","attemptTransactionCommit","catch","hasErrorLabel","USER_EXPLICIT_TXN_END_STATES","NO_TRANSACTION","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","state","promise","TypeError","then","maybeRetryOrThrow","errorLabels","push","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","writeConcern","w","wtimeout","maxTimeMS","commandHandler","e","r","idx","indexOf","splice","unpinServer","transactionError","recoveryToken","supportsRecoveryToken","_err","_reply","s","useRecoveryToken","ServerSession","SUBTYPE_UUID","lastUse","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","sessions","endAllPooledSessions","length","endSessions","map","logicalSessionTimeoutMinutes","shift","pooledSession","pop","unshift","commandSupportsReadConcern","aggregate","count","distinct","find","parallelCollectionScan","geoNear","geoSearch","mapReduce","out","inline","applySession","lsid","isRetryableWrite","willRetryWrite","shouldApplyReadConcern","Long","fromNumber","readConcern","afterClusterTime","readPreference","primary","mode","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\r\nconst EventEmitter = require('events');\r\nconst BSON = retrieveBSON();\r\nconst Binary = BSON.Binary;\r\nconst uuidV4 = require('./utils').uuidV4;\r\nconst MongoError = require('./error').MongoError;\r\nconst isRetryableError = require('././error').isRetryableError;\r\nconst MongoNetworkError = require('./error').MongoNetworkError;\r\nconst MongoWriteConcernError = require('./error').MongoWriteConcernError;\r\nconst Transaction = require('./transactions').Transaction;\r\nconst TxnState = require('./transactions').TxnState;\r\nconst isPromiseLike = require('./utils').isPromiseLike;\r\nconst ReadPreference = require('./topologies/read_preference');\r\nconst isTransactionCommand = require('./transactions').isTransactionCommand;\r\nconst resolveClusterTime = require('./topologies/shared').resolveClusterTime;\r\nconst isSharded = require('./wireprotocol/shared').isSharded;\r\nconst maxWireVersion = require('./utils').maxWireVersion;\r\n\r\nconst minWireVersionForShardedTransactions = 8;\r\n\r\nfunction assertAlive(session, callback) {\r\n  if (session.serverSession == null) {\r\n    const error = new MongoError('Cannot use a session that has ended');\r\n    if (typeof callback === 'function') {\r\n      callback(error, null);\r\n      return false;\r\n    }\r\n\r\n    throw error;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Options to pass when creating a Client Session\r\n * @typedef {Object} SessionOptions\r\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\r\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\r\n */\r\n\r\n/**\r\n * A BSON document reflecting the lsid of a {@link ClientSession}\r\n * @typedef {Object} SessionId\r\n */\r\n\r\n/**\r\n * A class representing a client session on the server\r\n * WARNING: not meant to be instantiated directly.\r\n * @class\r\n * @hideconstructor\r\n */\r\nclass ClientSession extends EventEmitter {\r\n  /**\r\n   * Create a client session.\r\n   * WARNING: not meant to be instantiated directly\r\n   *\r\n   * @param {Topology} topology The current client's topology (Internal Class)\r\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\r\n   * @param {SessionOptions} [options] Optional settings\r\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\r\n   */\r\n  constructor(topology, sessionPool, options, clientOptions) {\r\n    super();\r\n\r\n    if (topology == null) {\r\n      throw new Error('ClientSession requires a topology');\r\n    }\r\n\r\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\r\n      throw new Error('ClientSession requires a ServerSessionPool');\r\n    }\r\n\r\n    options = options || {};\r\n    clientOptions = clientOptions || {};\r\n\r\n    this.topology = topology;\r\n    this.sessionPool = sessionPool;\r\n    this.hasEnded = false;\r\n    this.serverSession = sessionPool.acquire();\r\n    this.clientOptions = clientOptions;\r\n\r\n    this.supports = {\r\n      causalConsistency:\r\n        typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\r\n    };\r\n\r\n    this.clusterTime = options.initialClusterTime;\r\n\r\n    this.operationTime = null;\r\n    this.explicit = !!options.explicit;\r\n    this.owner = options.owner;\r\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\r\n    this.transaction = new Transaction();\r\n  }\r\n\r\n  /**\r\n   * The server id associated with this session\r\n   * @type {SessionId}\r\n   */\r\n  get id() {\r\n    return this.serverSession.id;\r\n  }\r\n\r\n  /**\r\n   * Ends this session on the server\r\n   *\r\n   * @param {Object} [options] Optional settings. Currently reserved for future use\r\n   * @param {Function} [callback] Optional callback for completion of this operation\r\n   */\r\n  endSession(options, callback) {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = options || {};\r\n\r\n    if (this.hasEnded) {\r\n      if (typeof callback === 'function') callback(null, null);\r\n      return;\r\n    }\r\n\r\n    if (this.serverSession && this.inTransaction()) {\r\n      this.abortTransaction(); // pass in callback?\r\n    }\r\n\r\n    // mark the session as ended, and emit a signal\r\n    this.hasEnded = true;\r\n    this.emit('ended', this);\r\n\r\n    // release the server session back to the pool\r\n    this.sessionPool.release(this.serverSession);\r\n    this.serverSession = null;\r\n\r\n    // spec indicates that we should ignore all errors for `endSessions`\r\n    if (typeof callback === 'function') callback(null, null);\r\n  }\r\n\r\n  /**\r\n   * Advances the operationTime for a ClientSession.\r\n   *\r\n   * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\r\n   */\r\n  advanceOperationTime(operationTime) {\r\n    if (this.operationTime == null) {\r\n      this.operationTime = operationTime;\r\n      return;\r\n    }\r\n\r\n    if (operationTime.greaterThan(this.operationTime)) {\r\n      this.operationTime = operationTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used to determine if this session equals another\r\n   * @param {ClientSession} session\r\n   * @return {boolean} true if the sessions are equal\r\n   */\r\n  equals(session) {\r\n    if (!(session instanceof ClientSession)) {\r\n      return false;\r\n    }\r\n\r\n    return this.id.id.buffer.equals(session.id.id.buffer);\r\n  }\r\n\r\n  /**\r\n   * Increment the transaction number on the internal ServerSession\r\n   */\r\n  incrementTransactionNumber() {\r\n    this.serverSession.txnNumber++;\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} whether this session is currently in a transaction or not\r\n   */\r\n  inTransaction() {\r\n    return this.transaction.isActive;\r\n  }\r\n\r\n  /**\r\n   * Starts a new transaction with the given options.\r\n   *\r\n   * @param {TransactionOptions} options Options for the transaction\r\n   */\r\n  startTransaction(options) {\r\n    assertAlive(this);\r\n    if (this.inTransaction()) {\r\n      throw new MongoError('Transaction already in progress');\r\n    }\r\n\r\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\r\n    if (\r\n      isSharded(this.topology) &&\r\n      topologyMaxWireVersion != null &&\r\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\r\n    ) {\r\n      throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\r\n    }\r\n\r\n    // increment txnNumber\r\n    this.incrementTransactionNumber();\r\n\r\n    // create transaction state\r\n    this.transaction = new Transaction(\r\n      Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions)\r\n    );\r\n\r\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\r\n  }\r\n\r\n  /**\r\n   * Commits the currently active transaction in this session.\r\n   *\r\n   * @param {Function} [callback] optional callback for completion of this operation\r\n   * @return {Promise} A promise is returned if no callback is provided\r\n   */\r\n  commitTransaction(callback) {\r\n    if (typeof callback === 'function') {\r\n      endTransaction(this, 'commitTransaction', callback);\r\n      return;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      endTransaction(\r\n        this,\r\n        'commitTransaction',\r\n        (err, reply) => (err ? reject(err) : resolve(reply))\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Aborts the currently active transaction in this session.\r\n   *\r\n   * @param {Function} [callback] optional callback for completion of this operation\r\n   * @return {Promise} A promise is returned if no callback is provided\r\n   */\r\n  abortTransaction(callback) {\r\n    if (typeof callback === 'function') {\r\n      endTransaction(this, 'abortTransaction', callback);\r\n      return;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      endTransaction(\r\n        this,\r\n        'abortTransaction',\r\n        (err, reply) => (err ? reject(err) : resolve(reply))\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is here to ensure that ClientSession is never serialized to BSON.\r\n   * @ignore\r\n   */\r\n  toBSON() {\r\n    throw new Error('ClientSession cannot be serialized to BSON.');\r\n  }\r\n\r\n  /**\r\n   * A user provided function to be run within a transaction\r\n   *\r\n   * @callback WithTransactionCallback\r\n   * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\r\n   * @returns {Promise} The resulting Promise of operations run within this transaction\r\n   */\r\n\r\n  /**\r\n   * Runs a provided lambda within a transaction, retrying either the commit operation\r\n   * or entire transaction as needed (and when the error permits) to better ensure that\r\n   * the transaction can complete successfully.\r\n   *\r\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\r\n   * return a Promise will result in undefined behavior.\r\n   *\r\n   * @param {WithTransactionCallback} fn\r\n   * @param {TransactionOptions} [options] Optional settings for the transaction\r\n   */\r\n  withTransaction(fn, options) {\r\n    const startTime = Date.now();\r\n    return attemptTransaction(this, startTime, fn, options);\r\n  }\r\n}\r\n\r\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\r\nconst UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\r\nconst UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\r\nconst MAX_TIME_MS_EXPIRED_CODE = 50;\r\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\r\n  'CannotSatisfyWriteConcern',\r\n  'UnknownReplWriteConcern',\r\n  'UnsatisfiableWriteConcern'\r\n]);\r\n\r\nfunction hasNotTimedOut(startTime, max) {\r\n  return Date.now() - startTime < max;\r\n}\r\n\r\nfunction isUnknownTransactionCommitResult(err) {\r\n  return (\r\n    isMaxTimeMSExpiredError(err) ||\r\n    (!NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) &&\r\n      err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE &&\r\n      err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE)\r\n  );\r\n}\r\n\r\nfunction isMaxTimeMSExpiredError(err) {\r\n  return (\r\n    err.code === MAX_TIME_MS_EXPIRED_CODE ||\r\n    (err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE)\r\n  );\r\n}\r\n\r\nfunction attemptTransactionCommit(session, startTime, fn, options) {\r\n  return session.commitTransaction().catch(err => {\r\n    if (\r\n      err instanceof MongoError &&\r\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\r\n      !isMaxTimeMSExpiredError(err)\r\n    ) {\r\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\r\n        return attemptTransactionCommit(session, startTime, fn, options);\r\n      }\r\n\r\n      if (err.hasErrorLabel('TransientTransactionError')) {\r\n        return attemptTransaction(session, startTime, fn, options);\r\n      }\r\n    }\r\n\r\n    throw err;\r\n  });\r\n}\r\n\r\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\r\n  TxnState.NO_TRANSACTION,\r\n  TxnState.TRANSACTION_COMMITTED,\r\n  TxnState.TRANSACTION_ABORTED\r\n]);\r\n\r\nfunction userExplicitlyEndedTransaction(session) {\r\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\r\n}\r\n\r\nfunction attemptTransaction(session, startTime, fn, options) {\r\n  session.startTransaction(options);\r\n\r\n  let promise;\r\n  try {\r\n    promise = fn(session);\r\n  } catch (err) {\r\n    promise = Promise.reject(err);\r\n  }\r\n\r\n  if (!isPromiseLike(promise)) {\r\n    session.abortTransaction();\r\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\r\n  }\r\n\r\n  return promise\r\n    .then(() => {\r\n      if (userExplicitlyEndedTransaction(session)) {\r\n        return;\r\n      }\r\n\r\n      return attemptTransactionCommit(session, startTime, fn, options);\r\n    })\r\n    .catch(err => {\r\n      function maybeRetryOrThrow(err) {\r\n        if (\r\n          err instanceof MongoError &&\r\n          err.hasErrorLabel('TransientTransactionError') &&\r\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\r\n        ) {\r\n          return attemptTransaction(session, startTime, fn, options);\r\n        }\r\n\r\n        if (isMaxTimeMSExpiredError(err)) {\r\n          if (err.errorLabels == null) {\r\n            err.errorLabels = [];\r\n          }\r\n          err.errorLabels.push('UnknownTransactionCommitResult');\r\n        }\r\n\r\n        throw err;\r\n      }\r\n\r\n      if (session.transaction.isActive) {\r\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\r\n      }\r\n\r\n      return maybeRetryOrThrow(err);\r\n    });\r\n}\r\n\r\nfunction endTransaction(session, commandName, callback) {\r\n  if (!assertAlive(session, callback)) {\r\n    // checking result in case callback was called\r\n    return;\r\n  }\r\n\r\n  // handle any initial problematic cases\r\n  let txnState = session.transaction.state;\r\n\r\n  if (txnState === TxnState.NO_TRANSACTION) {\r\n    callback(new MongoError('No transaction started'));\r\n    return;\r\n  }\r\n\r\n  if (commandName === 'commitTransaction') {\r\n    if (\r\n      txnState === TxnState.STARTING_TRANSACTION ||\r\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\r\n    ) {\r\n      // the transaction was never started, we can safely exit here\r\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\r\n      callback(null, null);\r\n      return;\r\n    }\r\n\r\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\r\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\r\n      return;\r\n    }\r\n  } else {\r\n    if (txnState === TxnState.STARTING_TRANSACTION) {\r\n      // the transaction was never started, we can safely exit here\r\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\r\n      callback(null, null);\r\n      return;\r\n    }\r\n\r\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\r\n      callback(new MongoError('Cannot call abortTransaction twice'));\r\n      return;\r\n    }\r\n\r\n    if (\r\n      txnState === TxnState.TRANSACTION_COMMITTED ||\r\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\r\n    ) {\r\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\r\n      return;\r\n    }\r\n  }\r\n\r\n  // construct and send the command\r\n  const command = { [commandName]: 1 };\r\n\r\n  // apply a writeConcern if specified\r\n  let writeConcern;\r\n  if (session.transaction.options.writeConcern) {\r\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\r\n  } else if (session.clientOptions && session.clientOptions.w) {\r\n    writeConcern = { w: session.clientOptions.w };\r\n  }\r\n\r\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\r\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\r\n  }\r\n\r\n  if (writeConcern) {\r\n    Object.assign(command, { writeConcern });\r\n  }\r\n\r\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\r\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\r\n  }\r\n\r\n  function commandHandler(e, r) {\r\n    if (commandName === 'commitTransaction') {\r\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\r\n\r\n      if (\r\n        e &&\r\n        (e instanceof MongoNetworkError ||\r\n          e instanceof MongoWriteConcernError ||\r\n          isRetryableError(e) ||\r\n          isMaxTimeMSExpiredError(e))\r\n      ) {\r\n        if (e.errorLabels) {\r\n          const idx = e.errorLabels.indexOf('TransientTransactionError');\r\n          if (idx !== -1) {\r\n            e.errorLabels.splice(idx, 1);\r\n          }\r\n        } else {\r\n          e.errorLabels = [];\r\n        }\r\n\r\n        if (isUnknownTransactionCommitResult(e)) {\r\n          e.errorLabels.push('UnknownTransactionCommitResult');\r\n\r\n          // per txns spec, must unpin session in this case\r\n          session.transaction.unpinServer();\r\n        }\r\n      }\r\n    } else {\r\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\r\n    }\r\n\r\n    callback(e, r);\r\n  }\r\n\r\n  // The spec indicates that we should ignore all errors on `abortTransaction`\r\n  function transactionError(err) {\r\n    return commandName === 'commitTransaction' ? err : null;\r\n  }\r\n\r\n  if (\r\n    // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\r\n    session.transaction.recoveryToken &&\r\n    supportsRecoveryToken(session)\r\n  ) {\r\n    command.recoveryToken = session.transaction.recoveryToken;\r\n  }\r\n\r\n  // send the command\r\n  session.topology.command('admin.$cmd', command, { session }, (err, reply) => {\r\n    if (err && isRetryableError(err)) {\r\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\r\n      if (command.commitTransaction) {\r\n        // per txns spec, must unpin session in this case\r\n        session.transaction.unpinServer();\r\n\r\n        command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\r\n          w: 'majority'\r\n        });\r\n      }\r\n\r\n      return session.topology.command('admin.$cmd', command, { session }, (_err, _reply) =>\r\n        commandHandler(transactionError(_err), _reply)\r\n      );\r\n    }\r\n\r\n    commandHandler(transactionError(err), reply);\r\n  });\r\n}\r\n\r\nfunction supportsRecoveryToken(session) {\r\n  const topology = session.topology;\r\n  return !!topology.s.options.useRecoveryToken;\r\n}\r\n\r\n/**\r\n * Reflects the existence of a session on the server. Can be reused by the session pool.\r\n * WARNING: not meant to be instantiated directly. For internal use only.\r\n * @ignore\r\n */\r\nclass ServerSession {\r\n  constructor() {\r\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\r\n    this.lastUse = Date.now();\r\n    this.txnNumber = 0;\r\n    this.isDirty = false;\r\n  }\r\n\r\n  /**\r\n   * Determines if the server session has timed out.\r\n   * @ignore\r\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\r\n   * @return {boolean} true if the session has timed out.\r\n   */\r\n  hasTimedOut(sessionTimeoutMinutes) {\r\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\r\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\r\n    const idleTimeMinutes = Math.round(\r\n      (((Date.now() - this.lastUse) % 86400000) % 3600000) / 60000\r\n    );\r\n\r\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Maintains a pool of Server Sessions.\r\n * For internal use only\r\n * @ignore\r\n */\r\nclass ServerSessionPool {\r\n  constructor(topology) {\r\n    if (topology == null) {\r\n      throw new Error('ServerSessionPool requires a topology');\r\n    }\r\n\r\n    this.topology = topology;\r\n    this.sessions = [];\r\n  }\r\n\r\n  /**\r\n   * Ends all sessions in the session pool.\r\n   * @ignore\r\n   */\r\n  endAllPooledSessions() {\r\n    if (this.sessions.length) {\r\n      this.topology.endSessions(this.sessions.map(session => session.id));\r\n      this.sessions = [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Acquire a Server Session from the pool.\r\n   * Iterates through each session in the pool, removing any stale sessions\r\n   * along the way. The first non-stale session found is removed from the\r\n   * pool and returned. If no non-stale session is found, a new ServerSession\r\n   * is created.\r\n   * @ignore\r\n   * @returns {ServerSession}\r\n   */\r\n  acquire() {\r\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\r\n    while (this.sessions.length) {\r\n      const session = this.sessions.shift();\r\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\r\n        return session;\r\n      }\r\n    }\r\n\r\n    return new ServerSession();\r\n  }\r\n\r\n  /**\r\n   * Release a session to the session pool\r\n   * Adds the session back to the session pool if the session has not timed out yet.\r\n   * This method also removes any stale sessions from the pool.\r\n   * @ignore\r\n   * @param {ServerSession} session The session to release to the pool\r\n   */\r\n  release(session) {\r\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\r\n    while (this.sessions.length) {\r\n      const pooledSession = this.sessions[this.sessions.length - 1];\r\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\r\n        this.sessions.pop();\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\r\n      if (session.isDirty) {\r\n        return;\r\n      }\r\n\r\n      // otherwise, readd this session to the session pool\r\n      this.sessions.unshift(session);\r\n    }\r\n  }\r\n}\r\n\r\n// TODO: this should be codified in command construction\r\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\r\nfunction commandSupportsReadConcern(command, options) {\r\n  if (\r\n    command.aggregate ||\r\n    command.count ||\r\n    command.distinct ||\r\n    command.find ||\r\n    command.parallelCollectionScan ||\r\n    command.geoNear ||\r\n    command.geoSearch\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  if (command.mapReduce && options.out && (options.out.inline === 1 || options.out === 'inline')) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Optionally decorate a command with sessions specific keys\r\n *\r\n * @param {ClientSession} session the session tracking transaction state\r\n * @param {Object} command the command to decorate\r\n * @param {Object} topology the topology for tracking the cluster time\r\n * @param {Object} [options] Optional settings passed to calling operation\r\n * @return {MongoError|null} An error, if some error condition was met\r\n */\r\nfunction applySession(session, command, options) {\r\n  const serverSession = session.serverSession;\r\n  if (serverSession == null) {\r\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\r\n    return new MongoError('Cannot use a session that has ended');\r\n  }\r\n\r\n  // mark the last use of this session, and apply the `lsid`\r\n  serverSession.lastUse = Date.now();\r\n  command.lsid = serverSession.id;\r\n\r\n  // first apply non-transaction-specific sessions data\r\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\r\n  const isRetryableWrite = options.willRetryWrite;\r\n  const shouldApplyReadConcern = commandSupportsReadConcern(command);\r\n\r\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\r\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\r\n  }\r\n\r\n  // now attempt to apply transaction-specific sessions data\r\n  if (!inTransaction) {\r\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\r\n      session.transaction.transition(TxnState.NO_TRANSACTION);\r\n    }\r\n\r\n    // TODO: the following should only be applied to read operation per spec.\r\n    // for causal consistency\r\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\r\n      command.readConcern = command.readConcern || {};\r\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\r\n    return new MongoError(\r\n      `Read preference in a transaction must be primary, not: ${options.readPreference.mode}`\r\n    );\r\n  }\r\n\r\n  // `autocommit` must always be false to differentiate from retryable writes\r\n  command.autocommit = false;\r\n\r\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\r\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\r\n    command.startTransaction = true;\r\n\r\n    const readConcern =\r\n      session.transaction.options.readConcern || session.clientOptions.readConcern;\r\n    if (readConcern) {\r\n      command.readConcern = readConcern;\r\n    }\r\n\r\n    if (session.supports.causalConsistency && session.operationTime) {\r\n      command.readConcern = command.readConcern || {};\r\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateSessionFromResponse(session, document) {\r\n  if (document.$clusterTime) {\r\n    resolveClusterTime(session, document.$clusterTime);\r\n  }\r\n\r\n  if (document.operationTime && session && session.supports.causalConsistency) {\r\n    session.advanceOperationTime(document.operationTime);\r\n  }\r\n\r\n  if (document.recoveryToken && session && session.inTransaction()) {\r\n    session.transaction._recoveryToken = document.recoveryToken;\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  ClientSession,\r\n  ServerSession,\r\n  ServerSessionPool,\r\n  TxnState,\r\n  applySession,\r\n  updateSessionFromResponse,\r\n  commandSupportsReadConcern\r\n};\r\n"]},"metadata":{},"sourceType":"script"}