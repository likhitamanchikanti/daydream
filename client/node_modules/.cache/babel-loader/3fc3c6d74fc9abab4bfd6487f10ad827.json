{"ast":null,"code":"'use strict'; // An enumeration of server types we know about\n\nconst ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\nconst WRITABLE_SERVER_TYPES = new Set([ServerType.RSPrimary, ServerType.Standalone, ServerType.Mongos]);\nconst DATA_BEARING_SERVER_TYPES = new Set([ServerType.RSPrimary, ServerType.RSSecondary, ServerType.Mongos, ServerType.Standalone]);\nconst ISMASTER_FIELDS = ['minWireVersion', 'maxWireVersion', 'maxBsonObjectSize', 'maxMessageSizeBytes', 'maxWriteBatchSize', 'compression', 'me', 'hosts', 'passives', 'arbiters', 'tags', 'setName', 'setVersion', 'electionId', 'primary', 'logicalSessionTimeoutMinutes', 'saslSupportedMechs', '__nodejs_mock_server__', '$clusterTime'];\n/**\r\n * The client's view of a single server, based on the most recent ismaster outcome.\r\n *\r\n * Internal type, not meant to be directly instantiated\r\n */\n\nclass ServerDescription {\n  /**\r\n   * Create a ServerDescription\r\n   * @param {String} address The address of the server\r\n   * @param {Object} [ismaster] An optional ismaster response for this server\r\n   * @param {Object} [options] Optional settings\r\n   * @param {Number} [options.roundTripTime] The round trip time to ping this server (in ms)\r\n   */\n  constructor(address, ismaster, options) {\n    options = options || {};\n    ismaster = Object.assign({\n      minWireVersion: 0,\n      maxWireVersion: 0,\n      hosts: [],\n      passives: [],\n      arbiters: [],\n      tags: []\n    }, ismaster);\n    this.address = address;\n    this.error = options.error || null;\n    this.roundTripTime = options.roundTripTime || 0;\n    this.lastUpdateTime = Date.now();\n    this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;\n    this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;\n    this.type = parseServerType(ismaster); // direct mappings\n\n    ISMASTER_FIELDS.forEach(field => {\n      if (typeof ismaster[field] !== 'undefined') this[field] = ismaster[field];\n    }); // normalize case for hosts\n\n    if (this.me) this.me = this.me.toLowerCase();\n    this.hosts = this.hosts.map(host => host.toLowerCase());\n    this.passives = this.passives.map(host => host.toLowerCase());\n    this.arbiters = this.arbiters.map(host => host.toLowerCase());\n  }\n\n  get allHosts() {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n  /**\r\n   * @return {Boolean} Is this server available for reads\r\n   */\n\n\n  get isReadable() {\n    return this.type === ServerType.RSSecondary || this.isWritable;\n  }\n  /**\r\n   * @return {Boolean} Is this server data bearing\r\n   */\n\n\n  get isDataBearing() {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n  /**\r\n   * @return {Boolean} Is this server available for writes\r\n   */\n\n\n  get isWritable() {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n}\n/**\r\n * Parses an `ismaster` message and determines the server type\r\n *\r\n * @param {Object} ismaster The `ismaster` message to parse\r\n * @return {ServerType}\r\n */\n\n\nfunction parseServerType(ismaster) {\n  if (!ismaster || !ismaster.ok) {\n    return ServerType.Unknown;\n  }\n\n  if (ismaster.isreplicaset) {\n    return ServerType.RSGhost;\n  }\n\n  if (ismaster.msg && ismaster.msg === 'isdbgrid') {\n    return ServerType.Mongos;\n  }\n\n  if (ismaster.setName) {\n    if (ismaster.hidden) {\n      return ServerType.RSOther;\n    } else if (ismaster.ismaster) {\n      return ServerType.RSPrimary;\n    } else if (ismaster.secondary) {\n      return ServerType.RSSecondary;\n    } else if (ismaster.arbiterOnly) {\n      return ServerType.RSArbiter;\n    } else {\n      return ServerType.RSOther;\n    }\n  }\n\n  return ServerType.Standalone;\n}\n\nmodule.exports = {\n  ServerDescription,\n  ServerType\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/sdam/server_description.js"],"names":["ServerType","Standalone","Mongos","PossiblePrimary","RSPrimary","RSSecondary","RSArbiter","RSOther","RSGhost","Unknown","WRITABLE_SERVER_TYPES","Set","DATA_BEARING_SERVER_TYPES","ISMASTER_FIELDS","ServerDescription","constructor","address","ismaster","options","Object","assign","minWireVersion","maxWireVersion","hosts","passives","arbiters","tags","error","roundTripTime","lastUpdateTime","Date","now","lastWriteDate","lastWrite","opTime","type","parseServerType","forEach","field","me","toLowerCase","map","host","allHosts","concat","isReadable","isWritable","isDataBearing","has","ok","isreplicaset","msg","setName","hidden","secondary","arbiterOnly","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n// An enumeration of server types we know about\r\nconst ServerType = {\r\n  Standalone: 'Standalone',\r\n  Mongos: 'Mongos',\r\n  PossiblePrimary: 'PossiblePrimary',\r\n  RSPrimary: 'RSPrimary',\r\n  RSSecondary: 'RSSecondary',\r\n  RSArbiter: 'RSArbiter',\r\n  RSOther: 'RSOther',\r\n  RSGhost: 'RSGhost',\r\n  Unknown: 'Unknown'\r\n};\r\n\r\nconst WRITABLE_SERVER_TYPES = new Set([\r\n  ServerType.RSPrimary,\r\n  ServerType.Standalone,\r\n  ServerType.Mongos\r\n]);\r\n\r\nconst DATA_BEARING_SERVER_TYPES = new Set([\r\n  ServerType.RSPrimary,\r\n  ServerType.RSSecondary,\r\n  ServerType.Mongos,\r\n  ServerType.Standalone\r\n]);\r\n\r\nconst ISMASTER_FIELDS = [\r\n  'minWireVersion',\r\n  'maxWireVersion',\r\n  'maxBsonObjectSize',\r\n  'maxMessageSizeBytes',\r\n  'maxWriteBatchSize',\r\n  'compression',\r\n  'me',\r\n  'hosts',\r\n  'passives',\r\n  'arbiters',\r\n  'tags',\r\n  'setName',\r\n  'setVersion',\r\n  'electionId',\r\n  'primary',\r\n  'logicalSessionTimeoutMinutes',\r\n  'saslSupportedMechs',\r\n  '__nodejs_mock_server__',\r\n  '$clusterTime'\r\n];\r\n\r\n/**\r\n * The client's view of a single server, based on the most recent ismaster outcome.\r\n *\r\n * Internal type, not meant to be directly instantiated\r\n */\r\nclass ServerDescription {\r\n  /**\r\n   * Create a ServerDescription\r\n   * @param {String} address The address of the server\r\n   * @param {Object} [ismaster] An optional ismaster response for this server\r\n   * @param {Object} [options] Optional settings\r\n   * @param {Number} [options.roundTripTime] The round trip time to ping this server (in ms)\r\n   */\r\n  constructor(address, ismaster, options) {\r\n    options = options || {};\r\n    ismaster = Object.assign(\r\n      {\r\n        minWireVersion: 0,\r\n        maxWireVersion: 0,\r\n        hosts: [],\r\n        passives: [],\r\n        arbiters: [],\r\n        tags: []\r\n      },\r\n      ismaster\r\n    );\r\n\r\n    this.address = address;\r\n    this.error = options.error || null;\r\n    this.roundTripTime = options.roundTripTime || 0;\r\n    this.lastUpdateTime = Date.now();\r\n    this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;\r\n    this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;\r\n    this.type = parseServerType(ismaster);\r\n\r\n    // direct mappings\r\n    ISMASTER_FIELDS.forEach(field => {\r\n      if (typeof ismaster[field] !== 'undefined') this[field] = ismaster[field];\r\n    });\r\n\r\n    // normalize case for hosts\r\n    if (this.me) this.me = this.me.toLowerCase();\r\n    this.hosts = this.hosts.map(host => host.toLowerCase());\r\n    this.passives = this.passives.map(host => host.toLowerCase());\r\n    this.arbiters = this.arbiters.map(host => host.toLowerCase());\r\n  }\r\n\r\n  get allHosts() {\r\n    return this.hosts.concat(this.arbiters).concat(this.passives);\r\n  }\r\n\r\n  /**\r\n   * @return {Boolean} Is this server available for reads\r\n   */\r\n  get isReadable() {\r\n    return this.type === ServerType.RSSecondary || this.isWritable;\r\n  }\r\n\r\n  /**\r\n   * @return {Boolean} Is this server data bearing\r\n   */\r\n  get isDataBearing() {\r\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\r\n  }\r\n\r\n  /**\r\n   * @return {Boolean} Is this server available for writes\r\n   */\r\n  get isWritable() {\r\n    return WRITABLE_SERVER_TYPES.has(this.type);\r\n  }\r\n}\r\n\r\n/**\r\n * Parses an `ismaster` message and determines the server type\r\n *\r\n * @param {Object} ismaster The `ismaster` message to parse\r\n * @return {ServerType}\r\n */\r\nfunction parseServerType(ismaster) {\r\n  if (!ismaster || !ismaster.ok) {\r\n    return ServerType.Unknown;\r\n  }\r\n\r\n  if (ismaster.isreplicaset) {\r\n    return ServerType.RSGhost;\r\n  }\r\n\r\n  if (ismaster.msg && ismaster.msg === 'isdbgrid') {\r\n    return ServerType.Mongos;\r\n  }\r\n\r\n  if (ismaster.setName) {\r\n    if (ismaster.hidden) {\r\n      return ServerType.RSOther;\r\n    } else if (ismaster.ismaster) {\r\n      return ServerType.RSPrimary;\r\n    } else if (ismaster.secondary) {\r\n      return ServerType.RSSecondary;\r\n    } else if (ismaster.arbiterOnly) {\r\n      return ServerType.RSArbiter;\r\n    } else {\r\n      return ServerType.RSOther;\r\n    }\r\n  }\r\n\r\n  return ServerType.Standalone;\r\n}\r\n\r\nmodule.exports = {\r\n  ServerDescription,\r\n  ServerType\r\n};\r\n"]},"metadata":{},"sourceType":"script"}