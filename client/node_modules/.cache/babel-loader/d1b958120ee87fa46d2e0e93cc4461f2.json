{"ast":null,"code":"'use strict';\n\nconst buildCountCommand = require('./collection_ops').buildCountCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst push = Array.prototype.push;\n\nconst CursorState = require('../core/cursor').CursorState;\n/**\r\n * Get the count of documents for this cursor.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance on which to count.\r\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\r\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\r\n * @param {Cursor~countResultCallback} [callback] The result callback.\r\n */\n\n\nfunction count(cursor, applySkipLimit, opts, callback) {\n  if (applySkipLimit) {\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\n  } // Ensure we have the right read preference inheritance\n\n\n  if (opts.readPreference) {\n    cursor.setReadPreference(opts.readPreference);\n  }\n\n  if (typeof opts.maxTimeMS !== 'number' && cursor.cmd && typeof cursor.cmd.maxTimeMS === 'number') {\n    opts.maxTimeMS = cursor.cmd.maxTimeMS;\n  }\n\n  let options = {};\n  options.skip = opts.skip;\n  options.limit = opts.limit;\n  options.hint = opts.hint;\n  options.maxTimeMS = opts.maxTimeMS; // Command\n\n  options.collectionName = cursor.namespace.collection;\n  let command;\n\n  try {\n    command = buildCountCommand(cursor, cursor.cmd.query, options);\n  } catch (err) {\n    return callback(err);\n  } // Set cursor server to the same as the topology\n\n\n  cursor.server = cursor.topology.s.coreTopology; // Execute the command\n\n  cursor.topology.command(cursor.namespace.withCollection('$cmd'), command, cursor.options, (err, result) => {\n    callback(err, result ? result.result.n : null);\n  });\n}\n/**\r\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\r\n *\r\n * @method\r\n * @deprecated\r\n * @param {Cursor} cursor The Cursor instance on which to run.\r\n * @param {Cursor~resultCallback} callback The result callback.\r\n */\n\n\nfunction each(cursor, callback) {\n  if (!callback) throw MongoError.create({\n    message: 'callback is mandatory',\n    driver: true\n  });\n  if (cursor.isNotified()) return;\n\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT) {\n    cursor.s.state = CursorState.OPEN;\n  } // Define function to avoid global scope escape\n\n\n  let fn = null; // Trampoline all the entries\n\n  if (cursor.bufferedCount() > 0) {\n    while (fn = loop(cursor, callback)) fn(cursor, callback);\n\n    each(cursor, callback);\n  } else {\n    cursor.next((err, item) => {\n      if (err) return handleCallback(callback, err);\n\n      if (item == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, () => handleCallback(callback, null, null));\n      }\n\n      if (handleCallback(callback, null, item) === false) return;\n      each(cursor, callback);\n    });\n  }\n}\n/**\r\n * Check if there is any document still available in the cursor.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance on which to run.\r\n * @param {Cursor~resultCallback} [callback] The result callback.\r\n */\n\n\nfunction hasNext(cursor, callback) {\n  if (cursor.s.currentDoc) {\n    return callback(null, true);\n  }\n\n  if (cursor.isNotified()) {\n    return callback(null, false);\n  }\n\n  nextObject(cursor, (err, doc) => {\n    if (err) return callback(err, null);\n\n    if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\n      return callback(null, false);\n    }\n\n    if (!doc) return callback(null, false);\n    cursor.s.currentDoc = doc;\n    callback(null, true);\n  });\n} // Trampoline emptying the number of retrieved items\n// without incurring a nextTick operation\n\n\nfunction loop(cursor, callback) {\n  // No more items we are done\n  if (cursor.bufferedCount() === 0) return; // Get the next document\n\n  cursor._next(callback); // Loop\n\n\n  return loop;\n}\n/**\r\n * Get the next available document from the cursor. Returns null if no more documents are available.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\r\n * @param {Cursor~resultCallback} [callback] The result callback.\r\n */\n\n\nfunction next(cursor, callback) {\n  // Return the currentDoc if someone called hasNext first\n  if (cursor.s.currentDoc) {\n    const doc = cursor.s.currentDoc;\n    cursor.s.currentDoc = null;\n    return callback(null, doc);\n  } // Return the next object\n\n\n  nextObject(cursor, callback);\n} // Get the next available document from the cursor, returns null if no more documents are available.\n\n\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) return handleCallback(callback, MongoError.create({\n    message: 'Cursor is closed',\n    driver: true\n  }));\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n/**\r\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\r\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\r\n */\n\n\nfunction toArray(cursor, callback) {\n  const items = []; // Reset cursor\n\n  cursor.rewind();\n  cursor.s.state = CursorState.INIT; // Fetch all the documents\n\n  const fetchDocs = () => {\n    cursor._next((err, doc) => {\n      if (err) {\n        return cursor._endSession ? cursor._endSession(() => handleCallback(callback, err)) : handleCallback(callback, err);\n      }\n\n      if (doc == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, () => handleCallback(callback, null, items));\n      } // Add doc to items\n\n\n      items.push(doc); // Get all buffered objects\n\n      if (cursor.bufferedCount() > 0) {\n        let docs = cursor.readBufferedDocuments(cursor.bufferedCount()); // Transform the doc if transform method added\n\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\n          docs = docs.map(cursor.s.transforms.doc);\n        }\n\n        push.apply(items, docs);\n      } // Attempt a fetch\n\n\n      fetchDocs();\n    });\n  };\n\n  fetchDocs();\n}\n\nmodule.exports = {\n  count,\n  each,\n  hasNext,\n  next,\n  toArray\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/cursor_ops.js"],"names":["buildCountCommand","require","formattedOrderClause","handleCallback","MongoError","push","Array","prototype","CursorState","count","cursor","applySkipLimit","opts","callback","cursorSkip","skip","cursorLimit","limit","readPreference","setReadPreference","maxTimeMS","cmd","options","hint","collectionName","namespace","collection","command","query","err","server","topology","s","coreTopology","withCollection","result","n","each","create","message","driver","isNotified","state","CLOSED","isDead","INIT","OPEN","fn","bufferedCount","loop","next","item","close","skipKillCursors","hasNext","currentDoc","nextObject","doc","_next","sort","toArray","items","rewind","fetchDocs","_endSession","docs","readBufferedDocuments","transforms","map","apply","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst buildCountCommand = require('./collection_ops').buildCountCommand;\r\nconst formattedOrderClause = require('../utils').formattedOrderClause;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst MongoError = require('../core').MongoError;\r\nconst push = Array.prototype.push;\r\nconst CursorState = require('../core/cursor').CursorState;\r\n\r\n/**\r\n * Get the count of documents for this cursor.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance on which to count.\r\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\r\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\r\n * @param {Cursor~countResultCallback} [callback] The result callback.\r\n */\r\nfunction count(cursor, applySkipLimit, opts, callback) {\r\n  if (applySkipLimit) {\r\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\r\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\r\n  }\r\n\r\n  // Ensure we have the right read preference inheritance\r\n  if (opts.readPreference) {\r\n    cursor.setReadPreference(opts.readPreference);\r\n  }\r\n\r\n  if (\r\n    typeof opts.maxTimeMS !== 'number' &&\r\n    cursor.cmd &&\r\n    typeof cursor.cmd.maxTimeMS === 'number'\r\n  ) {\r\n    opts.maxTimeMS = cursor.cmd.maxTimeMS;\r\n  }\r\n\r\n  let options = {};\r\n  options.skip = opts.skip;\r\n  options.limit = opts.limit;\r\n  options.hint = opts.hint;\r\n  options.maxTimeMS = opts.maxTimeMS;\r\n\r\n  // Command\r\n  options.collectionName = cursor.namespace.collection;\r\n\r\n  let command;\r\n  try {\r\n    command = buildCountCommand(cursor, cursor.cmd.query, options);\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  // Set cursor server to the same as the topology\r\n  cursor.server = cursor.topology.s.coreTopology;\r\n\r\n  // Execute the command\r\n  cursor.topology.command(\r\n    cursor.namespace.withCollection('$cmd'),\r\n    command,\r\n    cursor.options,\r\n    (err, result) => {\r\n      callback(err, result ? result.result.n : null);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\r\n *\r\n * @method\r\n * @deprecated\r\n * @param {Cursor} cursor The Cursor instance on which to run.\r\n * @param {Cursor~resultCallback} callback The result callback.\r\n */\r\nfunction each(cursor, callback) {\r\n  if (!callback) throw MongoError.create({ message: 'callback is mandatory', driver: true });\r\n  if (cursor.isNotified()) return;\r\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\r\n    return handleCallback(\r\n      callback,\r\n      MongoError.create({ message: 'Cursor is closed', driver: true })\r\n    );\r\n  }\r\n\r\n  if (cursor.s.state === CursorState.INIT) {\r\n    cursor.s.state = CursorState.OPEN;\r\n  }\r\n\r\n  // Define function to avoid global scope escape\r\n  let fn = null;\r\n  // Trampoline all the entries\r\n  if (cursor.bufferedCount() > 0) {\r\n    while ((fn = loop(cursor, callback))) fn(cursor, callback);\r\n    each(cursor, callback);\r\n  } else {\r\n    cursor.next((err, item) => {\r\n      if (err) return handleCallback(callback, err);\r\n      if (item == null) {\r\n        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));\r\n      }\r\n\r\n      if (handleCallback(callback, null, item) === false) return;\r\n      each(cursor, callback);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Check if there is any document still available in the cursor.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance on which to run.\r\n * @param {Cursor~resultCallback} [callback] The result callback.\r\n */\r\nfunction hasNext(cursor, callback) {\r\n  if (cursor.s.currentDoc) {\r\n    return callback(null, true);\r\n  }\r\n\r\n  if (cursor.isNotified()) {\r\n    return callback(null, false);\r\n  }\r\n\r\n  nextObject(cursor, (err, doc) => {\r\n    if (err) return callback(err, null);\r\n    if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\r\n      return callback(null, false);\r\n    }\r\n\r\n    if (!doc) return callback(null, false);\r\n    cursor.s.currentDoc = doc;\r\n    callback(null, true);\r\n  });\r\n}\r\n\r\n// Trampoline emptying the number of retrieved items\r\n// without incurring a nextTick operation\r\nfunction loop(cursor, callback) {\r\n  // No more items we are done\r\n  if (cursor.bufferedCount() === 0) return;\r\n  // Get the next document\r\n  cursor._next(callback);\r\n  // Loop\r\n  return loop;\r\n}\r\n\r\n/**\r\n * Get the next available document from the cursor. Returns null if no more documents are available.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\r\n * @param {Cursor~resultCallback} [callback] The result callback.\r\n */\r\nfunction next(cursor, callback) {\r\n  // Return the currentDoc if someone called hasNext first\r\n  if (cursor.s.currentDoc) {\r\n    const doc = cursor.s.currentDoc;\r\n    cursor.s.currentDoc = null;\r\n    return callback(null, doc);\r\n  }\r\n\r\n  // Return the next object\r\n  nextObject(cursor, callback);\r\n}\r\n\r\n// Get the next available document from the cursor, returns null if no more documents are available.\r\nfunction nextObject(cursor, callback) {\r\n  if (cursor.s.state === CursorState.CLOSED || (cursor.isDead && cursor.isDead()))\r\n    return handleCallback(\r\n      callback,\r\n      MongoError.create({ message: 'Cursor is closed', driver: true })\r\n    );\r\n  if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {\r\n    try {\r\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\r\n    } catch (err) {\r\n      return handleCallback(callback, err);\r\n    }\r\n  }\r\n\r\n  // Get the next object\r\n  cursor._next((err, doc) => {\r\n    cursor.s.state = CursorState.OPEN;\r\n    if (err) return handleCallback(callback, err);\r\n    handleCallback(callback, null, doc);\r\n  });\r\n}\r\n\r\n/**\r\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\r\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\r\n */\r\nfunction toArray(cursor, callback) {\r\n  const items = [];\r\n\r\n  // Reset cursor\r\n  cursor.rewind();\r\n  cursor.s.state = CursorState.INIT;\r\n\r\n  // Fetch all the documents\r\n  const fetchDocs = () => {\r\n    cursor._next((err, doc) => {\r\n      if (err) {\r\n        return cursor._endSession\r\n          ? cursor._endSession(() => handleCallback(callback, err))\r\n          : handleCallback(callback, err);\r\n      }\r\n      if (doc == null) {\r\n        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));\r\n      }\r\n\r\n      // Add doc to items\r\n      items.push(doc);\r\n\r\n      // Get all buffered objects\r\n      if (cursor.bufferedCount() > 0) {\r\n        let docs = cursor.readBufferedDocuments(cursor.bufferedCount());\r\n\r\n        // Transform the doc if transform method added\r\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\r\n          docs = docs.map(cursor.s.transforms.doc);\r\n        }\r\n\r\n        push.apply(items, docs);\r\n      }\r\n\r\n      // Attempt a fetch\r\n      fetchDocs();\r\n    });\r\n  };\r\n\r\n  fetchDocs();\r\n}\r\n\r\nmodule.exports = { count, each, hasNext, next, toArray };\r\n"]},"metadata":{},"sourceType":"script"}