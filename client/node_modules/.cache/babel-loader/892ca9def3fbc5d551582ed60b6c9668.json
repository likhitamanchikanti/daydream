{"ast":null,"code":"'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CursorState = require('../core/cursor').CursorState;\n/**\r\n * Build the count command.\r\n *\r\n * @method\r\n * @param {collectionOrCursor} an instance of a collection or cursor\r\n * @param {object} query The query for the count.\r\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\r\n */\n\n\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  const skip = options.skip;\n  const limit = options.limit;\n  let hint = options.hint;\n  const maxTimeMS = options.maxTimeMS;\n  query = query || {}; // Final query\n\n  const cmd = {\n    count: options.collectionName,\n    query: query\n  };\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    // collectionOrCursor is a cursor\n    if (collectionOrCursor.options.hint) {\n      hint = collectionOrCursor.options.hint;\n    } else if (collectionOrCursor.cmd.hint) {\n      hint = collectionOrCursor.cmd.hint;\n    }\n\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  } // Add limit, skip and maxTimeMS if defined\n\n\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint; // Do we have a readConcern specified\n\n  decorateWithReadConcern(cmd, collectionOrCursor);\n  return cmd;\n}\n\nfunction deleteCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err && callback) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.deletedCount = r.result.n;\n  if (callback) callback(null, r);\n}\n/**\r\n * Find and update a document.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} query Query object to locate the object to modify.\r\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\r\n * @param {object} doc The fields/vals to be updated.\r\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\r\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\r\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\r\n */\n\n\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  const queryObject = {\n    findAndModify: coll.collectionName,\n    query: query\n  };\n  sort = formattedOrderClause(sort);\n\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n  const projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n  options.checkKeys = false; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Decorate the findAndModify command with the write Concern\n\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  } // Have we specified bypassDocumentValidation\n\n\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary; // Have we specified collation\n\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the command\n\n\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    return handleCallback(callback, null, result);\n  });\n}\n/**\r\n * Retrieves this collections index info.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the index info.\r\n * @param {string} name The name of the collection.\r\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n\nfunction prepareDocs(coll, docs, options) {\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n} // Get the next available document from the cursor, returns null if no more documents are available.\n\n\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Ensure we are operating on an array op docs\n\n  docs = Array.isArray(docs) ? docs : [docs]; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If keep going set unordered\n\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n  docs = prepareDocs(coll, docs, options); // File inserts\n\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Add docs to the list\n\n    result.ops = docs; // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {};\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  } // Create an empty options object if the provided one is null\n\n\n  options = options || {}; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If selector is null set empty\n\n  if (selector == null) selector = {}; // Build the op\n\n  const op = {\n    q: selector,\n    limit: 0\n  };\n\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the remove\n\n\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n\n    if (result.result.writeErrors) {\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    } // Return the results\n\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) callback = options, options = null;\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null; // If we are not providing a selector or document throw\n\n  if (selector == null || typeof selector !== 'object') return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object') return callback(toError('document must be a valid JavaScript object')); // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // Execute the operation\n\n  const op = {\n    q: selector,\n    u: document\n  };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Update options\n\n\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n  r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\n  : null;\n  r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n  r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n  callback(null, r);\n}\n\nmodule.exports = {\n  buildCountCommand,\n  deleteCallback,\n  findAndModify,\n  indexInformation,\n  nextObject,\n  prepareDocs,\n  insertDocuments,\n  removeDocuments,\n  updateDocuments,\n  updateCallback\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/common_functions.js"],"names":["applyRetryableWrites","require","applyWriteConcern","decorateWithCollation","decorateWithReadConcern","executeCommand","formattedOrderClause","handleCallback","MongoError","ReadPreference","toError","CursorState","buildCountCommand","collectionOrCursor","query","options","skip","limit","hint","maxTimeMS","cmd","count","collectionName","s","numberOfRetries","deleteCallback","err","r","callback","result","ok","deletedCount","n","findAndModify","coll","sort","doc","queryObject","new","remove","upsert","projection","fields","arrayFilters","update","serializeFunctions","checkKeys","finalOptions","Object","assign","db","collection","writeConcern","bypassDocumentValidation","readPreference","primary","indexInformation","name","full","serverConfig","isDestroyed","processResults","indexes","info","i","length","index","key","push","listIndexes","toArray","Array","isArray","prepareDocs","docs","forceServerObjectId","map","_id","pkFactory","createPk","nextObject","cursor","state","CLOSED","isDead","create","message","driver","INIT","_next","OPEN","insertDocuments","keepGoing","ordered","topology","insert","namespace","code","writeErrors","ops","removeDocuments","selector","op","q","single","retryWrites","updateDocuments","document","u","multi","updateCallback","modifiedCount","nModified","upsertedId","upserted","upsertedCount","matchedCount","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\r\nconst applyWriteConcern = require('../utils').applyWriteConcern;\r\nconst decorateWithCollation = require('../utils').decorateWithCollation;\r\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\r\nconst executeCommand = require('./db_ops').executeCommand;\r\nconst formattedOrderClause = require('../utils').formattedOrderClause;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst MongoError = require('../core').MongoError;\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst toError = require('../utils').toError;\r\nconst CursorState = require('../core/cursor').CursorState;\r\n\r\n/**\r\n * Build the count command.\r\n *\r\n * @method\r\n * @param {collectionOrCursor} an instance of a collection or cursor\r\n * @param {object} query The query for the count.\r\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\r\n */\r\nfunction buildCountCommand(collectionOrCursor, query, options) {\r\n  const skip = options.skip;\r\n  const limit = options.limit;\r\n  let hint = options.hint;\r\n  const maxTimeMS = options.maxTimeMS;\r\n  query = query || {};\r\n\r\n  // Final query\r\n  const cmd = {\r\n    count: options.collectionName,\r\n    query: query\r\n  };\r\n\r\n  if (collectionOrCursor.s.numberOfRetries) {\r\n    // collectionOrCursor is a cursor\r\n    if (collectionOrCursor.options.hint) {\r\n      hint = collectionOrCursor.options.hint;\r\n    } else if (collectionOrCursor.cmd.hint) {\r\n      hint = collectionOrCursor.cmd.hint;\r\n    }\r\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\r\n  } else {\r\n    decorateWithCollation(cmd, collectionOrCursor, options);\r\n  }\r\n\r\n  // Add limit, skip and maxTimeMS if defined\r\n  if (typeof skip === 'number') cmd.skip = skip;\r\n  if (typeof limit === 'number') cmd.limit = limit;\r\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\r\n  if (hint) cmd.hint = hint;\r\n\r\n  // Do we have a readConcern specified\r\n  decorateWithReadConcern(cmd, collectionOrCursor);\r\n\r\n  return cmd;\r\n}\r\n\r\nfunction deleteCallback(err, r, callback) {\r\n  if (callback == null) return;\r\n  if (err && callback) return callback(err);\r\n  if (r == null) return callback(null, { result: { ok: 1 } });\r\n  r.deletedCount = r.result.n;\r\n  if (callback) callback(null, r);\r\n}\r\n\r\n/**\r\n * Find and update a document.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} query Query object to locate the object to modify.\r\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\r\n * @param {object} doc The fields/vals to be updated.\r\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\r\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\r\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\r\n */\r\nfunction findAndModify(coll, query, sort, doc, options, callback) {\r\n  // Create findAndModify command object\r\n  const queryObject = {\r\n    findAndModify: coll.collectionName,\r\n    query: query\r\n  };\r\n\r\n  sort = formattedOrderClause(sort);\r\n  if (sort) {\r\n    queryObject.sort = sort;\r\n  }\r\n\r\n  queryObject.new = options.new ? true : false;\r\n  queryObject.remove = options.remove ? true : false;\r\n  queryObject.upsert = options.upsert ? true : false;\r\n\r\n  const projection = options.projection || options.fields;\r\n\r\n  if (projection) {\r\n    queryObject.fields = projection;\r\n  }\r\n\r\n  if (options.arrayFilters) {\r\n    queryObject.arrayFilters = options.arrayFilters;\r\n    delete options.arrayFilters;\r\n  }\r\n\r\n  if (doc && !options.remove) {\r\n    queryObject.update = doc;\r\n  }\r\n\r\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;\r\n\r\n  // Either use override on the function, or go back to default on either the collection\r\n  // level or db\r\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\r\n\r\n  // No check on the documents\r\n  options.checkKeys = false;\r\n\r\n  // Final options for retryable writes and write concern\r\n  let finalOptions = Object.assign({}, options);\r\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\r\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\r\n\r\n  // Decorate the findAndModify command with the write Concern\r\n  if (finalOptions.writeConcern) {\r\n    queryObject.writeConcern = finalOptions.writeConcern;\r\n  }\r\n\r\n  // Have we specified bypassDocumentValidation\r\n  if (finalOptions.bypassDocumentValidation === true) {\r\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\r\n  }\r\n\r\n  finalOptions.readPreference = ReadPreference.primary;\r\n\r\n  // Have we specified collation\r\n  try {\r\n    decorateWithCollation(queryObject, coll, finalOptions);\r\n  } catch (err) {\r\n    return callback(err, null);\r\n  }\r\n\r\n  // Execute the command\r\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\r\n    if (err) return handleCallback(callback, err, null);\r\n\r\n    return handleCallback(callback, null, result);\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves this collections index info.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the index info.\r\n * @param {string} name The name of the collection.\r\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction indexInformation(db, name, options, callback) {\r\n  // If we specified full information\r\n  const full = options['full'] == null ? false : options['full'];\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Process all the results from the index command and collection\r\n  function processResults(indexes) {\r\n    // Contains all the information\r\n    let info = {};\r\n    // Process all the indexes\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      const index = indexes[i];\r\n      // Let's unpack the object\r\n      info[index.name] = [];\r\n      for (let name in index.key) {\r\n        info[index.name].push([name, index.key[name]]);\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n\r\n  // Get the list of indexes of the specified collection\r\n  db\r\n    .collection(name)\r\n    .listIndexes(options)\r\n    .toArray((err, indexes) => {\r\n      if (err) return callback(toError(err));\r\n      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\r\n      if (full) return handleCallback(callback, null, indexes);\r\n      handleCallback(callback, null, processResults(indexes));\r\n    });\r\n}\r\n\r\nfunction prepareDocs(coll, docs, options) {\r\n  const forceServerObjectId =\r\n    typeof options.forceServerObjectId === 'boolean'\r\n      ? options.forceServerObjectId\r\n      : coll.s.db.options.forceServerObjectId;\r\n\r\n  // no need to modify the docs if server sets the ObjectId\r\n  if (forceServerObjectId === true) {\r\n    return docs;\r\n  }\r\n\r\n  return docs.map(doc => {\r\n    if (forceServerObjectId !== true && doc._id == null) {\r\n      doc._id = coll.s.pkFactory.createPk();\r\n    }\r\n\r\n    return doc;\r\n  });\r\n}\r\n\r\n// Get the next available document from the cursor, returns null if no more documents are available.\r\nfunction nextObject(cursor, callback) {\r\n  if (cursor.s.state === CursorState.CLOSED || (cursor.isDead && cursor.isDead())) {\r\n    return handleCallback(\r\n      callback,\r\n      MongoError.create({ message: 'Cursor is closed', driver: true })\r\n    );\r\n  }\r\n\r\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\r\n    try {\r\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\r\n    } catch (err) {\r\n      return handleCallback(callback, err);\r\n    }\r\n  }\r\n\r\n  // Get the next object\r\n  cursor._next((err, doc) => {\r\n    cursor.s.state = CursorState.OPEN;\r\n    if (err) return handleCallback(callback, err);\r\n    handleCallback(callback, null, doc);\r\n  });\r\n}\r\n\r\nfunction insertDocuments(coll, docs, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n  // Ensure we are operating on an array op docs\r\n  docs = Array.isArray(docs) ? docs : [docs];\r\n\r\n  // Final options for retryable writes and write concern\r\n  let finalOptions = Object.assign({}, options);\r\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\r\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\r\n\r\n  // If keep going set unordered\r\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\r\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\r\n\r\n  docs = prepareDocs(coll, docs, options);\r\n\r\n  // File inserts\r\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\r\n    if (callback == null) return;\r\n    if (err) return handleCallback(callback, err);\r\n    if (result == null) return handleCallback(callback, null, null);\r\n    if (result.result.code) return handleCallback(callback, toError(result.result));\r\n    if (result.result.writeErrors)\r\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\r\n    // Add docs to the list\r\n    result.ops = docs;\r\n    // Return the results\r\n    handleCallback(callback, null, result);\r\n  });\r\n}\r\n\r\nfunction removeDocuments(coll, selector, options, callback) {\r\n  if (typeof options === 'function') {\r\n    (callback = options), (options = {});\r\n  } else if (typeof selector === 'function') {\r\n    callback = selector;\r\n    options = {};\r\n    selector = {};\r\n  }\r\n\r\n  // Create an empty options object if the provided one is null\r\n  options = options || {};\r\n\r\n  // Final options for retryable writes and write concern\r\n  let finalOptions = Object.assign({}, options);\r\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\r\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\r\n\r\n  // If selector is null set empty\r\n  if (selector == null) selector = {};\r\n\r\n  // Build the op\r\n  const op = { q: selector, limit: 0 };\r\n  if (options.single) {\r\n    op.limit = 1;\r\n  } else if (finalOptions.retryWrites) {\r\n    finalOptions.retryWrites = false;\r\n  }\r\n\r\n  // Have we specified collation\r\n  try {\r\n    decorateWithCollation(finalOptions, coll, options);\r\n  } catch (err) {\r\n    return callback(err, null);\r\n  }\r\n\r\n  // Execute the remove\r\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\r\n    if (callback == null) return;\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result == null) return handleCallback(callback, null, null);\r\n    if (result.result.code) return handleCallback(callback, toError(result.result));\r\n    if (result.result.writeErrors) {\r\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\r\n    }\r\n\r\n    // Return the results\r\n    handleCallback(callback, null, result);\r\n  });\r\n}\r\n\r\nfunction updateDocuments(coll, selector, document, options, callback) {\r\n  if ('function' === typeof options) (callback = options), (options = null);\r\n  if (options == null) options = {};\r\n  if (!('function' === typeof callback)) callback = null;\r\n\r\n  // If we are not providing a selector or document throw\r\n  if (selector == null || typeof selector !== 'object')\r\n    return callback(toError('selector must be a valid JavaScript object'));\r\n  if (document == null || typeof document !== 'object')\r\n    return callback(toError('document must be a valid JavaScript object'));\r\n\r\n  // Final options for retryable writes and write concern\r\n  let finalOptions = Object.assign({}, options);\r\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\r\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\r\n\r\n  // Do we return the actual result document\r\n  // Either use override on the function, or go back to default on either the collection\r\n  // level or db\r\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\r\n\r\n  // Execute the operation\r\n  const op = { q: selector, u: document };\r\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\r\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\r\n\r\n  if (finalOptions.arrayFilters) {\r\n    op.arrayFilters = finalOptions.arrayFilters;\r\n    delete finalOptions.arrayFilters;\r\n  }\r\n\r\n  if (finalOptions.retryWrites && op.multi) {\r\n    finalOptions.retryWrites = false;\r\n  }\r\n\r\n  // Have we specified collation\r\n  try {\r\n    decorateWithCollation(finalOptions, coll, options);\r\n  } catch (err) {\r\n    return callback(err, null);\r\n  }\r\n\r\n  // Update options\r\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\r\n    if (callback == null) return;\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result == null) return handleCallback(callback, null, null);\r\n    if (result.result.code) return handleCallback(callback, toError(result.result));\r\n    if (result.result.writeErrors)\r\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\r\n    // Return the results\r\n    handleCallback(callback, null, result);\r\n  });\r\n}\r\n\r\nfunction updateCallback(err, r, callback) {\r\n  if (callback == null) return;\r\n  if (err) return callback(err);\r\n  if (r == null) return callback(null, { result: { ok: 1 } });\r\n  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\r\n  r.upsertedId =\r\n    Array.isArray(r.result.upserted) && r.result.upserted.length > 0\r\n      ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\r\n      : null;\r\n  r.upsertedCount =\r\n    Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\r\n  r.matchedCount =\r\n    Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\r\n  callback(null, r);\r\n}\r\n\r\nmodule.exports = {\r\n  buildCountCommand,\r\n  deleteCallback,\r\n  findAndModify,\r\n  indexInformation,\r\n  nextObject,\r\n  prepareDocs,\r\n  insertDocuments,\r\n  removeDocuments,\r\n  updateDocuments,\r\n  updateCallback\r\n};\r\n"]},"metadata":{},"sourceType":"script"}