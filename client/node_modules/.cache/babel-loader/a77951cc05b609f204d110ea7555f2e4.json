{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\n\nconst f = require('util').format;\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst ReadPreference = require('./read_preference');\n\nconst CoreCursor = require('../cursor').CoreCursor;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst Logger = require('../connection/logger');\n\nconst MongoError = require('../error').MongoError;\n\nconst Server = require('./server');\n\nconst ReplSetState = require('./replset_state');\n\nconst clone = require('./shared').clone;\n\nconst Timeout = require('./shared').Timeout;\n\nconst Interval = require('./shared').Interval;\n\nconst createClientInfo = require('./shared').createClientInfo;\n\nconst SessionMixins = require('./shared').SessionMixins;\n\nconst isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;\n\nconst relayEvents = require('../utils').relayEvents;\n\nconst isRetryableError = require('../error').isRetryableError;\n\nconst BSON = retrieveBSON();\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst getMMAPError = require('./shared').getMMAPError; //\n// States\n\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar UNREFERENCED = 'unreferenced';\nvar DESTROYED = 'destroyed';\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\n    unreferenced: [UNREFERENCED, DESTROYED],\n    destroyed: [DESTROYED]\n  }; // Get current state\n\n  var legalStates = legalTransitions[self.state];\n\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.state = newState;\n  } else {\n    self.s.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));\n  }\n} //\n// ReplSet instance id\n\n\nvar id = 1;\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\n/**\r\n * Creates a new Replset instance\r\n * @class\r\n * @param {array} seedlist A list of seeds for the replicaset\r\n * @param {boolean} options.setName The Replicaset set name\r\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\r\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\r\n * @param {boolean} [options.emitError=false] Server will emit errors events\r\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\r\n * @param {number} [options.size=5] Server connection pool size\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passphrase] SSL Certificate pass phrase\r\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\r\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\r\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\r\n * @return {ReplSet} A cursor instance\r\n * @fires ReplSet#connect\r\n * @fires ReplSet#ha\r\n * @fires ReplSet#joined\r\n * @fires ReplSet#left\r\n * @fires ReplSet#failed\r\n * @fires ReplSet#fullsetup\r\n * @fires ReplSet#all\r\n * @fires ReplSet#error\r\n * @fires ReplSet#serverHeartbeatStarted\r\n * @fires ReplSet#serverHeartbeatSucceeded\r\n * @fires ReplSet#serverHeartbeatFailed\r\n * @fires ReplSet#topologyOpening\r\n * @fires ReplSet#topologyClosed\r\n * @fires ReplSet#topologyDescriptionChanged\r\n * @property {string} type the topology type.\r\n * @property {string} parserType the parser type used (c++ or js).\r\n */\n\nvar ReplSet = function (seedlist, options) {\n  var self = this;\n  options = options || {}; // Validate seedlist\n\n  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array'); // Validate list\n\n  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry'); // Validate entries\n\n  seedlist.forEach(function (e) {\n    if (typeof e.host !== 'string' || typeof e.port !== 'number') throw new MongoError('seedlist entry must contain a host and port');\n  }); // Add event listener\n\n  EventEmitter.call(this); // Get replSet Id\n\n  this.id = id++; // Get the localThresholdMS\n\n  var localThresholdMS = options.localThresholdMS || 15; // Backward compatibility\n\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency; // Create a logger\n\n  var logger = Logger('ReplSet', options); // Internal state\n\n  this.s = {\n    options: Object.assign({}, options),\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // Logger instance\n    logger: logger,\n    // Seedlist\n    seedlist: seedlist,\n    // Replicaset state\n    replicaSetState: new ReplSetState({\n      id: this.id,\n      setName: options.setName,\n      acceptableLatency: localThresholdMS,\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\n      logger: logger\n    }),\n    // Current servers we are connecting to\n    connectingServers: [],\n    // Ha interval\n    haInterval: options.haInterval ? options.haInterval : 10000,\n    // Minimum heartbeat frequency used if we detect a server close\n    minHeartbeatFrequencyMS: 500,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Server selection index\n    index: 0,\n    // Connect function options passed in\n    connectOptions: {},\n    // Are we running in debug mode\n    debug: typeof options.debug === 'boolean' ? options.debug : false,\n    // Client info\n    clientInfo: createClientInfo(options)\n  }; // Add handler for topology change\n\n  this.s.replicaSetState.on('topologyDescriptionChanged', function (r) {\n    self.emit('topologyDescriptionChanged', r);\n  }); // Log info warning if the socketTimeout < haInterval as it will cause\n  // a lot of recycled connections to happen.\n\n  if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {\n    this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts', this.s.options.socketTimeout, this.s.haInterval));\n  } // Add forwarding of events from state handler\n\n\n  var types = ['joined', 'left'];\n  types.forEach(function (x) {\n    self.s.replicaSetState.on(x, function (t, s) {\n      self.emit(x, t, s);\n    });\n  }); // Connect stat\n\n  this.initialConnectState = {\n    connect: false,\n    fullsetup: false,\n    all: false\n  }; // Disconnected state\n\n  this.state = DISCONNECTED;\n  this.haTimeoutId = null; // Last ismaster\n\n  this.ismaster = null; // Contains the intervalId\n\n  this.intervalIds = []; // Highest clusterTime seen in responses from the current deployment\n\n  this.clusterTime = null;\n};\n\ninherits(ReplSet, EventEmitter);\nObject.assign(ReplSet.prototype, SessionMixins);\nObject.defineProperty(ReplSet.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return 'replset';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function () {\n    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;\n  }\n});\n\nfunction rexecuteOperations(self) {\n  // If we have a primary and a disconnect handler, execute\n  // buffered operations\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute();\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executePrimary: true\n    });\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executeSecondary: true\n    });\n  }\n}\n\nfunction connectNewServers(self, servers, callback) {\n  // Count lefts\n  var count = servers.length;\n  var error = null; // Handle events\n\n  var _handleEvent = function (self, event) {\n    return function (err) {\n      var _self = this;\n\n      count = count - 1; // Destroyed\n\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return this.destroy({\n          force: true\n        });\n      }\n\n      if (event === 'connect') {\n        // Destroyed\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\n          return _self.destroy({\n            force: true\n          });\n        } // Update the state\n\n\n        var result = self.s.replicaSetState.update(_self); // Update the state with the new server\n\n        if (result) {\n          // Primary lastIsMaster store it\n          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\n            self.ismaster = _self.lastIsMaster();\n          } // Remove the handlers\n\n\n          for (let i = 0; i < handlers.length; i++) {\n            _self.removeAllListeners(handlers[i]);\n          } // Add stable state handlers\n\n\n          _self.on('error', handleEvent(self, 'error'));\n\n          _self.on('close', handleEvent(self, 'close'));\n\n          _self.on('timeout', handleEvent(self, 'timeout'));\n\n          _self.on('parseError', handleEvent(self, 'parseError')); // Enalbe the monitoring of the new server\n\n\n          monitorServer(_self.lastIsMaster().me, self, {}); // Rexecute any stalled operation\n\n          rexecuteOperations(self);\n        } else {\n          _self.destroy({\n            force: true\n          });\n        }\n      } else if (event === 'error') {\n        error = err;\n      } // Rexecute any stalled operation\n\n\n      rexecuteOperations(self); // Are we done finish up callback\n\n      if (count === 0) {\n        callback(error);\n      }\n    };\n  }; // No new servers\n\n\n  if (count === 0) return callback(); // Execute method\n\n  function execute(_server, i) {\n    setTimeout(function () {\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      } // Create a new server instance\n\n\n      var server = new Server(Object.assign({}, self.s.options, {\n        host: _server.split(':')[0],\n        port: parseInt(_server.split(':')[1], 10),\n        reconnect: false,\n        monitoring: false,\n        parent: self,\n        clientInfo: clone(self.s.clientInfo)\n      })); // Add temp handlers\n\n      server.once('connect', _handleEvent(self, 'connect'));\n      server.once('close', _handleEvent(self, 'close'));\n      server.once('timeout', _handleEvent(self, 'timeout'));\n      server.once('error', _handleEvent(self, 'error'));\n      server.once('parseError', _handleEvent(self, 'parseError')); // SDAM Monitoring events\n\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e)); // Command Monitoring events\n\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n      server.connect(self.s.connectOptions);\n    }, i);\n  } // Create new instances\n\n\n  for (var i = 0; i < servers.length; i++) {\n    execute(servers[i], i);\n  }\n} // Ping the server\n\n\nvar pingServer = function (self, server, cb) {\n  // Measure running time\n  var start = new Date().getTime(); // Emit the server heartbeat start\n\n  emitSDAMEvent(self, 'serverHeartbeatStarted', {\n    connectionId: server.name\n  }); // Execute ismaster\n  // Set the socketTimeout for a monitoring message to a low number\n  // Ensuring ismaster calls are timed out quickly\n\n  server.command('admin.$cmd', {\n    ismaster: true\n  }, {\n    monitoring: true,\n    socketTimeout: self.s.options.connectionTimeout || 2000\n  }, function (err, r) {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      server.destroy({\n        force: true\n      });\n      return cb(err, r);\n    } // Calculate latency\n\n\n    var latencyMS = new Date().getTime() - start; // Set the last updatedTime\n\n    var hrtime = process.hrtime();\n    server.lastUpdateTime = (hrtime[0] * 1e9 + hrtime[1]) / 1e6; // We had an error, remove it from the state\n\n    if (err) {\n      // Emit the server heartbeat failure\n      emitSDAMEvent(self, 'serverHeartbeatFailed', {\n        durationMS: latencyMS,\n        failure: err,\n        connectionId: server.name\n      }); // Remove server from the state\n\n      self.s.replicaSetState.remove(server);\n    } else {\n      // Update the server ismaster\n      server.ismaster = r.result; // Check if we have a lastWriteDate convert it to MS\n      // and store on the server instance for later use\n\n      if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\n        server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\n      } // Do we have a brand new server\n\n\n      if (server.lastIsMasterMS === -1) {\n        server.lastIsMasterMS = latencyMS;\n      } else if (server.lastIsMasterMS) {\n        // After the first measurement, average RTT MUST be computed using an\n        // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\n        // If the prior average is denoted old_rtt, then the new average (new_rtt) is\n        // computed from a new RTT measurement (x) using the following formula:\n        // alpha = 0.2\n        // new_rtt = alpha * x + (1 - alpha) * old_rtt\n        server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\n      }\n\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      } // Server heart beat event\n\n\n      emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n        durationMS: latencyMS,\n        reply: r.result,\n        connectionId: server.name\n      });\n    } // Calculate the staleness for this server\n\n\n    self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval); // Callback\n\n    cb(err, r);\n  });\n}; // Each server is monitored in parallel in their own timeout loop\n\n\nvar monitorServer = function (host, self, options) {\n  // If this is not the initial scan\n  // Is this server already being monitoried, then skip monitoring\n  if (!options.haInterval) {\n    for (var i = 0; i < self.intervalIds.length; i++) {\n      if (self.intervalIds[i].__host === host) {\n        return;\n      }\n    }\n  } // Get the haInterval\n\n\n  var _process = options.haInterval ? Timeout : Interval;\n\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval; // Create the interval\n\n\n  var intervalId = new _process(function () {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      // clearInterval(intervalId);\n      intervalId.stop();\n      return;\n    } // Do we already have server connection available for this host\n\n\n    var _server = self.s.replicaSetState.get(host); // Check if we have a known server connection and reuse\n\n\n    if (_server) {\n      // Ping the server\n      return pingServer(self, _server, function (err) {\n        if (err) {\n          // NOTE: should something happen here?\n          return;\n        }\n\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\n          intervalId.stop();\n          return;\n        } // Filter out all called intervaliIds\n\n\n        self.intervalIds = self.intervalIds.filter(function (intervalId) {\n          return intervalId.isRunning();\n        }); // Initial sweep\n\n        if (_process === Timeout) {\n          if (self.state === CONNECTING && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            self.state = CONNECTED; // Emit connected sign\n\n            process.nextTick(function () {\n              self.emit('connect', self);\n            }); // Start topology interval check\n\n            topologyMonitor(self, {});\n          }\n        } else {\n          if (self.state === DISCONNECTED && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            self.state = CONNECTED; // Rexecute any stalled operation\n\n            rexecuteOperations(self); // Emit connected sign\n\n            process.nextTick(function () {\n              self.emit('reconnect', self);\n            });\n          }\n        }\n\n        if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n          // Set initial connect state\n          self.initialConnectState.fullsetup = true;\n          self.initialConnectState.all = true;\n          process.nextTick(function () {\n            self.emit('fullsetup', self);\n            self.emit('all', self);\n          });\n        }\n      });\n    }\n  }, _haInterval); // Start the interval\n\n  intervalId.start(); // Add the intervalId host name\n\n  intervalId.__host = host; // Add the intervalId to our list of intervalIds\n\n  self.intervalIds.push(intervalId);\n};\n\nfunction topologyMonitor(self, options) {\n  if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n  options = options || {}; // Get the servers\n\n  var servers = Object.keys(self.s.replicaSetState.set); // Get the haInterval\n\n  var _process = options.haInterval ? Timeout : Interval;\n\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  if (_process === Timeout) {\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function (err) {\n      // Don't emit errors if the connection was already\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit('error', new MongoError('no primary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      } else if (!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit('error', new MongoError('no secondary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      }\n\n      for (var i = 0; i < servers.length; i++) {\n        monitorServer(servers[i], self, options);\n      }\n    });\n  } else {\n    for (var i = 0; i < servers.length; i++) {\n      monitorServer(servers[i], self, options);\n    }\n  } // Run the reconnect process\n\n\n  function executeReconnect(self) {\n    return function () {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function () {\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary() ? _haInterval : self.s.minHeartbeatFrequencyMS; // Create a timeout\n\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\n      });\n    };\n  } // Decide what kind of interval to use\n\n\n  var intervalTime = !self.s.replicaSetState.hasPrimary() ? self.s.minHeartbeatFrequencyMS : _haInterval;\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\n}\n\nfunction addServerToList(list, server) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  list.push(server);\n}\n\nfunction handleEvent(self, event) {\n  return function () {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return; // Debug log\n\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    } // Remove from the replicaset state\n\n\n    self.s.replicaSetState.remove(this); // Are we in a destroyed state return\n\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return; // If no primary and secondary available\n\n    if (!self.s.replicaSetState.hasPrimary() && !self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n      stateTransition(self, DISCONNECTED);\n    } else if (!self.s.replicaSetState.hasPrimary()) {\n      stateTransition(self, DISCONNECTED);\n    }\n\n    addServerToList(self.s.connectingServers, this);\n  };\n}\n\nfunction shouldTriggerConnect(self) {\n  const isConnecting = self.state === CONNECTING;\n  const hasPrimary = self.s.replicaSetState.hasPrimary();\n  const hasSecondary = self.s.replicaSetState.hasSecondary();\n  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\n  const readPreferenceSecondary = self.s.connectOptions.readPreference && self.s.connectOptions.readPreference.equals(ReadPreference.secondary);\n  return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;\n}\n\nfunction handleInitialConnectEvent(self, event) {\n  return function () {\n    var _this = this; // Debug log\n\n\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    } // Destroy the instance\n\n\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      return this.destroy({\n        force: true\n      });\n    } // Check the type of server\n\n\n    if (event === 'connect') {\n      // Update the state\n      var result = self.s.replicaSetState.update(_this);\n\n      if (result === true) {\n        // Primary lastIsMaster store it\n        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\n          self.ismaster = _this.lastIsMaster();\n        } // Debug log\n\n\n        if (self.s.logger.isDebug()) {\n          self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]', event, _this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));\n        } // Remove the handlers\n\n\n        for (let i = 0; i < handlers.length; i++) {\n          _this.removeAllListeners(handlers[i]);\n        } // Add stable state handlers\n\n\n        _this.on('error', handleEvent(self, 'error'));\n\n        _this.on('close', handleEvent(self, 'close'));\n\n        _this.on('timeout', handleEvent(self, 'timeout'));\n\n        _this.on('parseError', handleEvent(self, 'parseError')); // Do we have a primary or primaryAndSecondary\n\n\n        if (shouldTriggerConnect(self)) {\n          // We are connected\n          self.state = CONNECTED; // Set initial connect state\n\n          self.initialConnectState.connect = true; // Emit connect event\n\n          process.nextTick(function () {\n            self.emit('connect', self);\n          });\n          topologyMonitor(self, {});\n        }\n      } else if (result instanceof MongoError) {\n        _this.destroy({\n          force: true\n        });\n\n        self.destroy({\n          force: true\n        });\n        return self.emit('error', result);\n      } else {\n        _this.destroy({\n          force: true\n        });\n      }\n    } else {\n      // Emit failure to connect\n      self.emit('failed', this);\n      addServerToList(self.s.connectingServers, this); // Remove from the state\n\n      self.s.replicaSetState.remove(this);\n    }\n\n    if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n      // Set initial connect state\n      self.initialConnectState.fullsetup = true;\n      self.initialConnectState.all = true;\n      process.nextTick(function () {\n        self.emit('fullsetup', self);\n        self.emit('all', self);\n      });\n    } // Remove from the list from connectingServers\n\n\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\n      if (self.s.connectingServers[i].equals(this)) {\n        self.s.connectingServers.splice(i, 1);\n      }\n    } // Trigger topologyMonitor\n\n\n    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {\n      topologyMonitor(self, {\n        haInterval: 1\n      });\n    }\n  };\n}\n\nfunction connectServers(self, servers) {\n  // Update connectingServers\n  self.s.connectingServers = self.s.connectingServers.concat(servers); // Index used to interleaf the server connects, avoiding\n  // runtime issues on io constrained vm's\n\n  var timeoutInterval = 0;\n\n  function connect(server, timeoutInterval) {\n    setTimeout(function () {\n      // Add the server to the state\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      } // Add event handlers\n\n\n      server.once('close', handleInitialConnectEvent(self, 'close'));\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\n      server.once('error', handleInitialConnectEvent(self, 'error'));\n      server.once('connect', handleInitialConnectEvent(self, 'connect')); // SDAM Monitoring events\n\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e)); // Command Monitoring events\n\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']); // Start connection\n\n      server.connect(self.s.connectOptions);\n    }, timeoutInterval);\n  } // Start all the servers\n\n\n  while (servers.length > 0) {\n    connect(servers.shift(), timeoutInterval++);\n  }\n}\n/**\r\n * Emit event if it exists\r\n * @method\r\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n/**\r\n * Initiate server connect\r\n */\n\n\nReplSet.prototype.connect = function (options) {\n  var self = this; // Add any connect level options to the internal state\n\n  this.s.connectOptions = options || {}; // Set connecting state\n\n  stateTransition(this, CONNECTING); // Create server instances\n\n  var servers = this.s.seedlist.map(function (x) {\n    return new Server(Object.assign({}, self.s.options, x, options, {\n      reconnect: false,\n      monitoring: false,\n      parent: self,\n      clientInfo: clone(self.s.clientInfo)\n    }));\n  }); // Error out as high availbility interval must be < than socketTimeout\n\n  if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {\n    return self.emit('error', new MongoError(f('haInterval [%s] MS must be set to less than socketTimeout [%s] MS', this.s.options.haInterval, this.s.options.socketTimeout)));\n  } // Emit the topology opening event\n\n\n  emitSDAMEvent(this, 'topologyOpening', {\n    topologyId: this.id\n  }); // Start all server connections\n\n  connectServers(self, servers);\n};\n/**\r\n * Authenticate the topology.\r\n * @method\r\n * @param {MongoCredentials} credentials The credentials for authentication we are using\r\n * @param {authResultCallback} callback A callback function\r\n */\n\n\nReplSet.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\r\n * Destroy the server connection\r\n * @param {boolean} [options.force=false] Force destroy the pool\r\n * @method\r\n */\n\n\nReplSet.prototype.destroy = function (options, callback) {\n  options = options || {};\n  let destroyCount = this.s.connectingServers.length + 1; // +1 for the callback from `replicaSetState.destroy`\n\n  const serverDestroyed = () => {\n    destroyCount--;\n\n    if (destroyCount > 0) {\n      return;\n    } // Emit toplogy closing event\n\n\n    emitSDAMEvent(this, 'topologyClosed', {\n      topologyId: this.id\n    }); // Transition state\n\n    stateTransition(this, DESTROYED);\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  }; // Clear out any monitoring process\n\n\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId); // Clear out all monitoring\n\n  for (var i = 0; i < this.intervalIds.length; i++) {\n    this.intervalIds[i].stop();\n  } // Reset list of intervalIds\n\n\n  this.intervalIds = [];\n\n  if (destroyCount === 0) {\n    serverDestroyed();\n    return;\n  } // Destroy the replicaset\n\n\n  this.s.replicaSetState.destroy(options, serverDestroyed); // Destroy all connecting servers\n\n  this.s.connectingServers.forEach(function (x) {\n    x.destroy(options, serverDestroyed);\n  });\n};\n/**\r\n * Unref all connections belong to this server\r\n * @method\r\n */\n\n\nReplSet.prototype.unref = function () {\n  // Transition state\n  stateTransition(this, UNREFERENCED);\n  this.s.replicaSetState.allServers().forEach(function (x) {\n    x.unref();\n  });\n  clearTimeout(this.haTimeoutId);\n};\n/**\r\n * Returns the last known ismaster document for this server\r\n * @method\r\n * @return {object}\r\n */\n\n\nReplSet.prototype.lastIsMaster = function () {\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\n  // return the secondaries ismaster result.\n  if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\n  }\n\n  return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;\n};\n/**\r\n * All raw connections\r\n * @method\r\n * @return {Connection[]}\r\n */\n\n\nReplSet.prototype.connections = function () {\n  var servers = this.s.replicaSetState.allServers();\n  var connections = [];\n\n  for (var i = 0; i < servers.length; i++) {\n    connections = connections.concat(servers[i].connections());\n  }\n\n  return connections;\n};\n/**\r\n * Figure out if the server is connected\r\n * @method\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @return {boolean}\r\n */\n\n\nReplSet.prototype.isConnected = function (options) {\n  options = options || {}; // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replicaSetState.hasSecondary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\n    return true;\n  }\n\n  return this.s.replicaSetState.hasPrimary();\n};\n/**\r\n * Figure out if the replicaset instance was destroyed by calling destroy\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nReplSet.prototype.isDestroyed = function () {\n  return this.state === DESTROYED;\n};\n\nconst SERVER_SELECTION_TIMEOUT_MS = 10000; // hardcoded `serverSelectionTimeoutMS` for legacy topology\n\nconst SERVER_SELECTION_INTERVAL_MS = 1000; // time to wait between selection attempts\n\n/**\r\n * Selects a server\r\n *\r\n * @method\r\n * @param {function} selector Unused\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {ClientSession} [options.session] Unused\r\n * @param {function} callback\r\n */\n\nReplSet.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector;\n  options = options || {};\n  let readPreference;\n\n  if (selector instanceof ReadPreference) {\n    readPreference = selector;\n  } else {\n    readPreference = options.readPreference || ReadPreference.primary;\n  }\n\n  let lastError;\n  const start = process.hrtime();\n\n  const _selectServer = () => {\n    if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {\n      if (lastError != null) {\n        callback(lastError, null);\n      } else {\n        callback(new MongoError('Server selection timed out'));\n      }\n\n      return;\n    }\n\n    const server = this.s.replicaSetState.pickServer(readPreference);\n\n    if (server == null) {\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (!(server instanceof Server)) {\n      lastError = server;\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\n    callback(null, server);\n  };\n\n  _selectServer();\n};\n/**\r\n * Get all connected servers\r\n * @method\r\n * @return {Server[]}\r\n */\n\n\nReplSet.prototype.getServers = function () {\n  return this.s.replicaSetState.allServers();\n}; //\n// Execute write operation\n\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  const self = args.self;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n\n  if (self.state === DESTROYED) {\n    return callback(new MongoError(f('topology was destroyed')));\n  }\n\n  const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self) && !options.session.inTransaction();\n\n  if (!self.s.replicaSetState.hasPrimary()) {\n    if (self.s.disconnectHandler) {\n      // Not connected but we have a disconnecthandler\n      return self.s.disconnectHandler.add(op, ns, ops, options, callback);\n    } else if (!willRetryWrite) {\n      // No server returned we had an error\n      return callback(new MongoError('no primary server found'));\n    }\n  }\n\n  const handler = (err, result) => {\n    if (!err) return callback(null, result);\n\n    if (!isRetryableError(err)) {\n      err = getMMAPError(err);\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newArgs = Object.assign({}, args, {\n        retrying: true\n      });\n      return executeWriteOperation(newArgs, options, callback);\n    } // Per SDAM, remove primary from replicaset\n\n\n    if (self.s.replicaSetState.primary) {\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n\n    return callback(err);\n  };\n\n  if (callback.operationId) {\n    handler.operationId = callback.operationId;\n  } // increment and assign txnNumber\n\n\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  self.s.replicaSetState.primary[op](ns, ops, options, handler);\n}\n/**\r\n * Insert one or more documents\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of documents to insert\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nReplSet.prototype.insert = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'insert',\n    ns,\n    ops\n  }, options, callback);\n};\n/**\r\n * Perform one or more update operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of updates\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nReplSet.prototype.update = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'update',\n    ns,\n    ops\n  }, options, callback);\n};\n/**\r\n * Perform one or more remove operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of removes\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nReplSet.prototype.remove = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'remove',\n    ns,\n    ops\n  }, options, callback);\n};\n\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\n\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n/**\r\n * Execute a command\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cmd The command hash\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Connection} [options.connection] Specify connection object to execute command against\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\n\n\nReplSet.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this; // Establish readPreference\n\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary; // If the readPreference is primary and we have no primary, store it\n\n  if (readPreference.preference === 'primary' && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference === 'secondary' && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference !== 'primary' && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } // Pick a server\n\n\n  var server = this.s.replicaSetState.pickServer(readPreference); // We received an error, return it\n\n  if (!(server instanceof Server)) return callback(server); // Emit debug event\n\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server); // No server returned we had an error\n\n  if (server == null) {\n    return callback(new MongoError(f('no server found that matches the provided readPreference %s', readPreference)));\n  }\n\n  const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self) && !options.session.inTransaction() && isWriteCommand(cmd);\n\n  const cb = (err, result) => {\n    if (!err) return callback(null, result);\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newOptions = Object.assign({}, options, {\n        retrying: true\n      });\n      return this.command(ns, cmd, newOptions, callback);\n    } // Per SDAM, remove primary from replicaset\n\n\n    if (this.s.replicaSetState.primary) {\n      this.s.replicaSetState.remove(this.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n\n    return callback(err);\n  }; // increment and assign txnNumber\n\n\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  } // Execute the command\n\n\n  server.command(ns, cmd, options, cb);\n};\n/**\r\n * Get a new cursor\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\r\n * @param {object} [options] Options for the cursor\r\n * @param {object} [options.batchSize=0] Batchsize for the operation\r\n * @param {array} [options.documents=[]] Initial documents list for cursor\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {object} [options.topology] The internal topology of the created cursor\r\n * @returns {Cursor}\r\n */\n\n\nReplSet.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this; // Set up final cursor type\n\n  var FinalCursor = options.cursorFactory || this.s.Cursor; // Return the cursor\n\n  return new FinalCursor(topology, ns, cmd, options);\n};\n/**\r\n * A replset connect event, used to verify that the connection is up and running\r\n *\r\n * @event ReplSet#connect\r\n * @type {ReplSet}\r\n */\n\n/**\r\n * A replset reconnect event, used to verify that the topology reconnected\r\n *\r\n * @event ReplSet#reconnect\r\n * @type {ReplSet}\r\n */\n\n/**\r\n * A replset fullsetup event, used to signal that all topology members have been contacted.\r\n *\r\n * @event ReplSet#fullsetup\r\n * @type {ReplSet}\r\n */\n\n/**\r\n * A replset all event, used to signal that all topology members have been contacted.\r\n *\r\n * @event ReplSet#all\r\n * @type {ReplSet}\r\n */\n\n/**\r\n * A replset failed event, used to signal that initial replset connection failed.\r\n *\r\n * @event ReplSet#failed\r\n * @type {ReplSet}\r\n */\n\n/**\r\n * A server member left the replicaset\r\n *\r\n * @event ReplSet#left\r\n * @type {function}\r\n * @param {string} type The type of member that left (primary|secondary|arbiter)\r\n * @param {Server} server The server object that left\r\n */\n\n/**\r\n * A server member joined the replicaset\r\n *\r\n * @event ReplSet#joined\r\n * @type {function}\r\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\r\n * @param {Server} server The server object that joined\r\n */\n\n/**\r\n * A server opening SDAM monitoring event\r\n *\r\n * @event ReplSet#serverOpening\r\n * @type {object}\r\n */\n\n/**\r\n * A server closed SDAM monitoring event\r\n *\r\n * @event ReplSet#serverClosed\r\n * @type {object}\r\n */\n\n/**\r\n * A server description SDAM change monitoring event\r\n *\r\n * @event ReplSet#serverDescriptionChanged\r\n * @type {object}\r\n */\n\n/**\r\n * A topology open SDAM event\r\n *\r\n * @event ReplSet#topologyOpening\r\n * @type {object}\r\n */\n\n/**\r\n * A topology closed SDAM event\r\n *\r\n * @event ReplSet#topologyClosed\r\n * @type {object}\r\n */\n\n/**\r\n * A topology structure SDAM change event\r\n *\r\n * @event ReplSet#topologyDescriptionChanged\r\n * @type {object}\r\n */\n\n/**\r\n * A topology serverHeartbeatStarted SDAM event\r\n *\r\n * @event ReplSet#serverHeartbeatStarted\r\n * @type {object}\r\n */\n\n/**\r\n * A topology serverHeartbeatFailed SDAM event\r\n *\r\n * @event ReplSet#serverHeartbeatFailed\r\n * @type {object}\r\n */\n\n/**\r\n * A topology serverHeartbeatSucceeded SDAM change event\r\n *\r\n * @event ReplSet#serverHeartbeatSucceeded\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command was started, if command monitoring is enabled\r\n *\r\n * @event ReplSet#commandStarted\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command succeeded, if command monitoring is enabled\r\n *\r\n * @event ReplSet#commandSucceeded\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command failed, if command monitoring is enabled\r\n *\r\n * @event ReplSet#commandFailed\r\n * @type {object}\r\n */\n\n\nmodule.exports = ReplSet;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/topologies/replset.js"],"names":["inherits","require","f","format","EventEmitter","ReadPreference","CoreCursor","retrieveBSON","Logger","MongoError","Server","ReplSetState","clone","Timeout","Interval","createClientInfo","SessionMixins","isRetryableWritesSupported","relayEvents","isRetryableError","BSON","calculateDurationInMs","getMMAPError","DISCONNECTED","CONNECTING","CONNECTED","UNREFERENCED","DESTROYED","stateTransition","self","newState","legalTransitions","disconnected","connecting","connected","unreferenced","destroyed","legalStates","state","indexOf","s","logger","error","id","handlers","ReplSet","seedlist","options","Array","isArray","length","forEach","e","host","port","call","localThresholdMS","acceptableLatency","Object","assign","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","Cursor","cursorFactory","replicaSetState","setName","heartbeatFrequencyMS","haInterval","connectingServers","minHeartbeatFrequencyMS","disconnectHandler","index","connectOptions","debug","clientInfo","on","r","emit","isWarn","socketTimeout","warn","types","x","t","initialConnectState","connect","fullsetup","all","haTimeoutId","ismaster","intervalIds","clusterTime","prototype","defineProperty","enumerable","get","native","logicalSessionTimeoutMinutes","rexecuteOperations","hasPrimaryAndSecondary","execute","hasPrimary","executePrimary","hasSecondary","executeSecondary","connectNewServers","servers","callback","count","_handleEvent","event","err","_self","destroy","force","result","update","lastIsMaster","i","removeAllListeners","handleEvent","monitorServer","me","_server","setTimeout","server","split","parseInt","reconnect","monitoring","parent","once","pingServer","cb","start","Date","getTime","emitSDAMEvent","connectionId","name","command","connectionTimeout","latencyMS","hrtime","process","lastUpdateTime","durationMS","failure","remove","lastWrite","lastWriteDate","lastIsMasterMS","reply","updateServerMaxStaleness","__host","_process","_haInterval","intervalId","stop","filter","isRunning","secondaryOnlyConnectionAllowed","nextTick","topologyMonitor","push","keys","set","unknownServers","executeReconnect","monitoringFrequencey","intervalTime","addServerToList","list","toLowerCase","isDebug","shouldTriggerConnect","isConnecting","readPreferenceSecondary","readPreference","equals","secondary","handleInitialConnectEvent","_this","JSON","stringify","splice","connectServers","concat","timeoutInterval","shift","description","listeners","map","topologyId","auth","credentials","destroyCount","serverDestroyed","clearTimeout","unref","allServers","secondaries","primary","connections","isConnected","primaryPreferred","secondaryPreferred","isDestroyed","SERVER_SELECTION_TIMEOUT_MS","SERVER_SELECTION_INTERVAL_MS","selectServer","selector","undefined","lastError","_selectServer","pickServer","getServers","executeWriteOperation","args","op","ns","ops","willRetryWrite","retrying","retryWrites","session","inTransaction","add","handler","newArgs","operationId","incrementTransactionNumber","insert","RETRYABLE_WRITE_OPERATIONS","isWriteCommand","some","cmd","preference","newOptions","cursor","topology","FinalCursor","module","exports"],"mappings":"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AD,CAAf;AACD,GAjBD,CAzD+D,CA4E/D;;;AACA,MAAI+G,cAAJ,EAAoB;AAClB5L,IAAAA,OAAO,CAAC+L,OAAR,CAAgBM,0BAAhB;AACArM,IAAAA,OAAO,CAAC4L,cAAR,GAAyBA,cAAzB;AACD,GAhF8D,CAkF/D;;;AACAjG,EAAAA,MAAM,CAACe,OAAP,CAAegF,EAAf,EAAmBgB,GAAnB,EAAwB1M,OAAxB,EAAiCmG,EAAjC;AACD,CApFD;AAsFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACArG,OAAO,CAAC4D,SAAR,CAAkBmJ,MAAlB,GAA2B,UAASnB,EAAT,EAAagB,GAAb,EAAkB1M,OAAlB,EAA2B;AACpDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAM8M,QAAQ,GAAG9M,OAAO,CAAC8M,QAAR,IAAoB,IAArC,CAFoD,CAIpD;;AACA,MAAIC,WAAW,GAAG/M,OAAO,CAAC6B,aAAR,IAAyB,KAAKpC,CAAL,CAAOmC,MAAlD,CALoD,CAOpD;;AACA,SAAO,IAAImL,WAAJ,CAAgBD,QAAhB,EAA0BpB,EAA1B,EAA8BgB,GAA9B,EAAmC1M,OAAnC,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEAgN,MAAM,CAACC,OAAP,GAAiBnN,OAAjB","sourcesContent":["'use strict';\r\n\r\nconst inherits = require('util').inherits;\r\nconst f = require('util').format;\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst ReadPreference = require('./read_preference');\r\nconst CoreCursor = require('../cursor').CoreCursor;\r\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\r\nconst Logger = require('../connection/logger');\r\nconst MongoError = require('../error').MongoError;\r\nconst Server = require('./server');\r\nconst ReplSetState = require('./replset_state');\r\nconst clone = require('./shared').clone;\r\nconst Timeout = require('./shared').Timeout;\r\nconst Interval = require('./shared').Interval;\r\nconst createClientInfo = require('./shared').createClientInfo;\r\nconst SessionMixins = require('./shared').SessionMixins;\r\nconst isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;\r\nconst relayEvents = require('../utils').relayEvents;\r\nconst isRetryableError = require('../error').isRetryableError;\r\nconst BSON = retrieveBSON();\r\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\r\nconst getMMAPError = require('./shared').getMMAPError;\r\n\r\n//\r\n// States\r\nvar DISCONNECTED = 'disconnected';\r\nvar CONNECTING = 'connecting';\r\nvar CONNECTED = 'connected';\r\nvar UNREFERENCED = 'unreferenced';\r\nvar DESTROYED = 'destroyed';\r\n\r\nfunction stateTransition(self, newState) {\r\n  var legalTransitions = {\r\n    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],\r\n    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\r\n    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\r\n    unreferenced: [UNREFERENCED, DESTROYED],\r\n    destroyed: [DESTROYED]\r\n  };\r\n\r\n  // Get current state\r\n  var legalStates = legalTransitions[self.state];\r\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\r\n    self.state = newState;\r\n  } else {\r\n    self.s.logger.error(\r\n      f(\r\n        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',\r\n        self.id,\r\n        self.state,\r\n        newState,\r\n        legalStates\r\n      )\r\n    );\r\n  }\r\n}\r\n\r\n//\r\n// ReplSet instance id\r\nvar id = 1;\r\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\r\n\r\n/**\r\n * Creates a new Replset instance\r\n * @class\r\n * @param {array} seedlist A list of seeds for the replicaset\r\n * @param {boolean} options.setName The Replicaset set name\r\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\r\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\r\n * @param {boolean} [options.emitError=false] Server will emit errors events\r\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\r\n * @param {number} [options.size=5] Server connection pool size\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passphrase] SSL Certificate pass phrase\r\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\r\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\r\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\r\n * @return {ReplSet} A cursor instance\r\n * @fires ReplSet#connect\r\n * @fires ReplSet#ha\r\n * @fires ReplSet#joined\r\n * @fires ReplSet#left\r\n * @fires ReplSet#failed\r\n * @fires ReplSet#fullsetup\r\n * @fires ReplSet#all\r\n * @fires ReplSet#error\r\n * @fires ReplSet#serverHeartbeatStarted\r\n * @fires ReplSet#serverHeartbeatSucceeded\r\n * @fires ReplSet#serverHeartbeatFailed\r\n * @fires ReplSet#topologyOpening\r\n * @fires ReplSet#topologyClosed\r\n * @fires ReplSet#topologyDescriptionChanged\r\n * @property {string} type the topology type.\r\n * @property {string} parserType the parser type used (c++ or js).\r\n */\r\nvar ReplSet = function(seedlist, options) {\r\n  var self = this;\r\n  options = options || {};\r\n\r\n  // Validate seedlist\r\n  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array');\r\n  // Validate list\r\n  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry');\r\n  // Validate entries\r\n  seedlist.forEach(function(e) {\r\n    if (typeof e.host !== 'string' || typeof e.port !== 'number')\r\n      throw new MongoError('seedlist entry must contain a host and port');\r\n  });\r\n\r\n  // Add event listener\r\n  EventEmitter.call(this);\r\n\r\n  // Get replSet Id\r\n  this.id = id++;\r\n\r\n  // Get the localThresholdMS\r\n  var localThresholdMS = options.localThresholdMS || 15;\r\n  // Backward compatibility\r\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency;\r\n\r\n  // Create a logger\r\n  var logger = Logger('ReplSet', options);\r\n\r\n  // Internal state\r\n  this.s = {\r\n    options: Object.assign({}, options),\r\n    // BSON instance\r\n    bson:\r\n      options.bson ||\r\n      new BSON([\r\n        BSON.Binary,\r\n        BSON.Code,\r\n        BSON.DBRef,\r\n        BSON.Decimal128,\r\n        BSON.Double,\r\n        BSON.Int32,\r\n        BSON.Long,\r\n        BSON.Map,\r\n        BSON.MaxKey,\r\n        BSON.MinKey,\r\n        BSON.ObjectId,\r\n        BSON.BSONRegExp,\r\n        BSON.Symbol,\r\n        BSON.Timestamp\r\n      ]),\r\n    // Factory overrides\r\n    Cursor: options.cursorFactory || CoreCursor,\r\n    // Logger instance\r\n    logger: logger,\r\n    // Seedlist\r\n    seedlist: seedlist,\r\n    // Replicaset state\r\n    replicaSetState: new ReplSetState({\r\n      id: this.id,\r\n      setName: options.setName,\r\n      acceptableLatency: localThresholdMS,\r\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\r\n      logger: logger\r\n    }),\r\n    // Current servers we are connecting to\r\n    connectingServers: [],\r\n    // Ha interval\r\n    haInterval: options.haInterval ? options.haInterval : 10000,\r\n    // Minimum heartbeat frequency used if we detect a server close\r\n    minHeartbeatFrequencyMS: 500,\r\n    // Disconnect handler\r\n    disconnectHandler: options.disconnectHandler,\r\n    // Server selection index\r\n    index: 0,\r\n    // Connect function options passed in\r\n    connectOptions: {},\r\n    // Are we running in debug mode\r\n    debug: typeof options.debug === 'boolean' ? options.debug : false,\r\n    // Client info\r\n    clientInfo: createClientInfo(options)\r\n  };\r\n\r\n  // Add handler for topology change\r\n  this.s.replicaSetState.on('topologyDescriptionChanged', function(r) {\r\n    self.emit('topologyDescriptionChanged', r);\r\n  });\r\n\r\n  // Log info warning if the socketTimeout < haInterval as it will cause\r\n  // a lot of recycled connections to happen.\r\n  if (\r\n    this.s.logger.isWarn() &&\r\n    this.s.options.socketTimeout !== 0 &&\r\n    this.s.options.socketTimeout < this.s.haInterval\r\n  ) {\r\n    this.s.logger.warn(\r\n      f(\r\n        'warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts',\r\n        this.s.options.socketTimeout,\r\n        this.s.haInterval\r\n      )\r\n    );\r\n  }\r\n\r\n  // Add forwarding of events from state handler\r\n  var types = ['joined', 'left'];\r\n  types.forEach(function(x) {\r\n    self.s.replicaSetState.on(x, function(t, s) {\r\n      self.emit(x, t, s);\r\n    });\r\n  });\r\n\r\n  // Connect stat\r\n  this.initialConnectState = {\r\n    connect: false,\r\n    fullsetup: false,\r\n    all: false\r\n  };\r\n\r\n  // Disconnected state\r\n  this.state = DISCONNECTED;\r\n  this.haTimeoutId = null;\r\n  // Last ismaster\r\n  this.ismaster = null;\r\n  // Contains the intervalId\r\n  this.intervalIds = [];\r\n\r\n  // Highest clusterTime seen in responses from the current deployment\r\n  this.clusterTime = null;\r\n};\r\n\r\ninherits(ReplSet, EventEmitter);\r\nObject.assign(ReplSet.prototype, SessionMixins);\r\n\r\nObject.defineProperty(ReplSet.prototype, 'type', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return 'replset';\r\n  }\r\n});\r\n\r\nObject.defineProperty(ReplSet.prototype, 'parserType', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return BSON.native ? 'c++' : 'js';\r\n  }\r\n});\r\n\r\nObject.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;\r\n  }\r\n});\r\n\r\nfunction rexecuteOperations(self) {\r\n  // If we have a primary and a disconnect handler, execute\r\n  // buffered operations\r\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\r\n    self.s.disconnectHandler.execute();\r\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\r\n    self.s.disconnectHandler.execute({ executePrimary: true });\r\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\r\n    self.s.disconnectHandler.execute({ executeSecondary: true });\r\n  }\r\n}\r\n\r\nfunction connectNewServers(self, servers, callback) {\r\n  // Count lefts\r\n  var count = servers.length;\r\n  var error = null;\r\n\r\n  // Handle events\r\n  var _handleEvent = function(self, event) {\r\n    return function(err) {\r\n      var _self = this;\r\n      count = count - 1;\r\n\r\n      // Destroyed\r\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n        return this.destroy({ force: true });\r\n      }\r\n\r\n      if (event === 'connect') {\r\n        // Destroyed\r\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n          return _self.destroy({ force: true });\r\n        }\r\n\r\n        // Update the state\r\n        var result = self.s.replicaSetState.update(_self);\r\n        // Update the state with the new server\r\n        if (result) {\r\n          // Primary lastIsMaster store it\r\n          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\r\n            self.ismaster = _self.lastIsMaster();\r\n          }\r\n\r\n          // Remove the handlers\r\n          for (let i = 0; i < handlers.length; i++) {\r\n            _self.removeAllListeners(handlers[i]);\r\n          }\r\n\r\n          // Add stable state handlers\r\n          _self.on('error', handleEvent(self, 'error'));\r\n          _self.on('close', handleEvent(self, 'close'));\r\n          _self.on('timeout', handleEvent(self, 'timeout'));\r\n          _self.on('parseError', handleEvent(self, 'parseError'));\r\n\r\n          // Enalbe the monitoring of the new server\r\n          monitorServer(_self.lastIsMaster().me, self, {});\r\n\r\n          // Rexecute any stalled operation\r\n          rexecuteOperations(self);\r\n        } else {\r\n          _self.destroy({ force: true });\r\n        }\r\n      } else if (event === 'error') {\r\n        error = err;\r\n      }\r\n\r\n      // Rexecute any stalled operation\r\n      rexecuteOperations(self);\r\n\r\n      // Are we done finish up callback\r\n      if (count === 0) {\r\n        callback(error);\r\n      }\r\n    };\r\n  };\r\n\r\n  // No new servers\r\n  if (count === 0) return callback();\r\n\r\n  // Execute method\r\n  function execute(_server, i) {\r\n    setTimeout(function() {\r\n      // Destroyed\r\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n        return;\r\n      }\r\n\r\n      // Create a new server instance\r\n      var server = new Server(\r\n        Object.assign({}, self.s.options, {\r\n          host: _server.split(':')[0],\r\n          port: parseInt(_server.split(':')[1], 10),\r\n          reconnect: false,\r\n          monitoring: false,\r\n          parent: self,\r\n          clientInfo: clone(self.s.clientInfo)\r\n        })\r\n      );\r\n\r\n      // Add temp handlers\r\n      server.once('connect', _handleEvent(self, 'connect'));\r\n      server.once('close', _handleEvent(self, 'close'));\r\n      server.once('timeout', _handleEvent(self, 'timeout'));\r\n      server.once('error', _handleEvent(self, 'error'));\r\n      server.once('parseError', _handleEvent(self, 'parseError'));\r\n\r\n      // SDAM Monitoring events\r\n      server.on('serverOpening', e => self.emit('serverOpening', e));\r\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\r\n      server.on('serverClosed', e => self.emit('serverClosed', e));\r\n\r\n      // Command Monitoring events\r\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\r\n\r\n      server.connect(self.s.connectOptions);\r\n    }, i);\r\n  }\r\n\r\n  // Create new instances\r\n  for (var i = 0; i < servers.length; i++) {\r\n    execute(servers[i], i);\r\n  }\r\n}\r\n\r\n// Ping the server\r\nvar pingServer = function(self, server, cb) {\r\n  // Measure running time\r\n  var start = new Date().getTime();\r\n\r\n  // Emit the server heartbeat start\r\n  emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: server.name });\r\n\r\n  // Execute ismaster\r\n  // Set the socketTimeout for a monitoring message to a low number\r\n  // Ensuring ismaster calls are timed out quickly\r\n  server.command(\r\n    'admin.$cmd',\r\n    {\r\n      ismaster: true\r\n    },\r\n    {\r\n      monitoring: true,\r\n      socketTimeout: self.s.options.connectionTimeout || 2000\r\n    },\r\n    function(err, r) {\r\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n        server.destroy({ force: true });\r\n        return cb(err, r);\r\n      }\r\n\r\n      // Calculate latency\r\n      var latencyMS = new Date().getTime() - start;\r\n\r\n      // Set the last updatedTime\r\n      var hrtime = process.hrtime();\r\n      server.lastUpdateTime = (hrtime[0] * 1e9 + hrtime[1]) / 1e6;\r\n\r\n      // We had an error, remove it from the state\r\n      if (err) {\r\n        // Emit the server heartbeat failure\r\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\r\n          durationMS: latencyMS,\r\n          failure: err,\r\n          connectionId: server.name\r\n        });\r\n\r\n        // Remove server from the state\r\n        self.s.replicaSetState.remove(server);\r\n      } else {\r\n        // Update the server ismaster\r\n        server.ismaster = r.result;\r\n\r\n        // Check if we have a lastWriteDate convert it to MS\r\n        // and store on the server instance for later use\r\n        if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\r\n          server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\r\n        }\r\n\r\n        // Do we have a brand new server\r\n        if (server.lastIsMasterMS === -1) {\r\n          server.lastIsMasterMS = latencyMS;\r\n        } else if (server.lastIsMasterMS) {\r\n          // After the first measurement, average RTT MUST be computed using an\r\n          // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\r\n          // If the prior average is denoted old_rtt, then the new average (new_rtt) is\r\n          // computed from a new RTT measurement (x) using the following formula:\r\n          // alpha = 0.2\r\n          // new_rtt = alpha * x + (1 - alpha) * old_rtt\r\n          server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\r\n        }\r\n\r\n        if (self.s.replicaSetState.update(server)) {\r\n          // Primary lastIsMaster store it\r\n          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\r\n            self.ismaster = server.lastIsMaster();\r\n          }\r\n        }\r\n\r\n        // Server heart beat event\r\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\r\n          durationMS: latencyMS,\r\n          reply: r.result,\r\n          connectionId: server.name\r\n        });\r\n      }\r\n\r\n      // Calculate the staleness for this server\r\n      self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);\r\n\r\n      // Callback\r\n      cb(err, r);\r\n    }\r\n  );\r\n};\r\n\r\n// Each server is monitored in parallel in their own timeout loop\r\nvar monitorServer = function(host, self, options) {\r\n  // If this is not the initial scan\r\n  // Is this server already being monitoried, then skip monitoring\r\n  if (!options.haInterval) {\r\n    for (var i = 0; i < self.intervalIds.length; i++) {\r\n      if (self.intervalIds[i].__host === host) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get the haInterval\r\n  var _process = options.haInterval ? Timeout : Interval;\r\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\r\n\r\n  // Create the interval\r\n  var intervalId = new _process(function() {\r\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n      // clearInterval(intervalId);\r\n      intervalId.stop();\r\n      return;\r\n    }\r\n\r\n    // Do we already have server connection available for this host\r\n    var _server = self.s.replicaSetState.get(host);\r\n\r\n    // Check if we have a known server connection and reuse\r\n    if (_server) {\r\n      // Ping the server\r\n      return pingServer(self, _server, function(err) {\r\n        if (err) {\r\n          // NOTE: should something happen here?\r\n          return;\r\n        }\r\n\r\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n          intervalId.stop();\r\n          return;\r\n        }\r\n\r\n        // Filter out all called intervaliIds\r\n        self.intervalIds = self.intervalIds.filter(function(intervalId) {\r\n          return intervalId.isRunning();\r\n        });\r\n\r\n        // Initial sweep\r\n        if (_process === Timeout) {\r\n          if (\r\n            self.state === CONNECTING &&\r\n            ((self.s.replicaSetState.hasSecondary() &&\r\n              self.s.options.secondaryOnlyConnectionAllowed) ||\r\n              self.s.replicaSetState.hasPrimary())\r\n          ) {\r\n            self.state = CONNECTED;\r\n\r\n            // Emit connected sign\r\n            process.nextTick(function() {\r\n              self.emit('connect', self);\r\n            });\r\n\r\n            // Start topology interval check\r\n            topologyMonitor(self, {});\r\n          }\r\n        } else {\r\n          if (\r\n            self.state === DISCONNECTED &&\r\n            ((self.s.replicaSetState.hasSecondary() &&\r\n              self.s.options.secondaryOnlyConnectionAllowed) ||\r\n              self.s.replicaSetState.hasPrimary())\r\n          ) {\r\n            self.state = CONNECTED;\r\n\r\n            // Rexecute any stalled operation\r\n            rexecuteOperations(self);\r\n\r\n            // Emit connected sign\r\n            process.nextTick(function() {\r\n              self.emit('reconnect', self);\r\n            });\r\n          }\r\n        }\r\n\r\n        if (\r\n          self.initialConnectState.connect &&\r\n          !self.initialConnectState.fullsetup &&\r\n          self.s.replicaSetState.hasPrimaryAndSecondary()\r\n        ) {\r\n          // Set initial connect state\r\n          self.initialConnectState.fullsetup = true;\r\n          self.initialConnectState.all = true;\r\n\r\n          process.nextTick(function() {\r\n            self.emit('fullsetup', self);\r\n            self.emit('all', self);\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }, _haInterval);\r\n\r\n  // Start the interval\r\n  intervalId.start();\r\n  // Add the intervalId host name\r\n  intervalId.__host = host;\r\n  // Add the intervalId to our list of intervalIds\r\n  self.intervalIds.push(intervalId);\r\n};\r\n\r\nfunction topologyMonitor(self, options) {\r\n  if (self.state === DESTROYED || self.state === UNREFERENCED) return;\r\n  options = options || {};\r\n\r\n  // Get the servers\r\n  var servers = Object.keys(self.s.replicaSetState.set);\r\n\r\n  // Get the haInterval\r\n  var _process = options.haInterval ? Timeout : Interval;\r\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\r\n\r\n  if (_process === Timeout) {\r\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function(err) {\r\n      // Don't emit errors if the connection was already\r\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n        return;\r\n      }\r\n\r\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\r\n        if (err) {\r\n          return self.emit('error', err);\r\n        }\r\n\r\n        self.emit(\r\n          'error',\r\n          new MongoError('no primary found in replicaset or invalid replica set name')\r\n        );\r\n        return self.destroy({ force: true });\r\n      } else if (\r\n        !self.s.replicaSetState.hasSecondary() &&\r\n        self.s.options.secondaryOnlyConnectionAllowed\r\n      ) {\r\n        if (err) {\r\n          return self.emit('error', err);\r\n        }\r\n\r\n        self.emit(\r\n          'error',\r\n          new MongoError('no secondary found in replicaset or invalid replica set name')\r\n        );\r\n        return self.destroy({ force: true });\r\n      }\r\n\r\n      for (var i = 0; i < servers.length; i++) {\r\n        monitorServer(servers[i], self, options);\r\n      }\r\n    });\r\n  } else {\r\n    for (var i = 0; i < servers.length; i++) {\r\n      monitorServer(servers[i], self, options);\r\n    }\r\n  }\r\n\r\n  // Run the reconnect process\r\n  function executeReconnect(self) {\r\n    return function() {\r\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n        return;\r\n      }\r\n\r\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function() {\r\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary()\r\n          ? _haInterval\r\n          : self.s.minHeartbeatFrequencyMS;\r\n\r\n        // Create a timeout\r\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\r\n      });\r\n    };\r\n  }\r\n\r\n  // Decide what kind of interval to use\r\n  var intervalTime = !self.s.replicaSetState.hasPrimary()\r\n    ? self.s.minHeartbeatFrequencyMS\r\n    : _haInterval;\r\n\r\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\r\n}\r\n\r\nfunction addServerToList(list, server) {\r\n  for (var i = 0; i < list.length; i++) {\r\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\r\n  }\r\n\r\n  list.push(server);\r\n}\r\n\r\nfunction handleEvent(self, event) {\r\n  return function() {\r\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\r\n    // Debug log\r\n    if (self.s.logger.isDebug()) {\r\n      self.s.logger.debug(\r\n        f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id)\r\n      );\r\n    }\r\n\r\n    // Remove from the replicaset state\r\n    self.s.replicaSetState.remove(this);\r\n\r\n    // Are we in a destroyed state return\r\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\r\n\r\n    // If no primary and secondary available\r\n    if (\r\n      !self.s.replicaSetState.hasPrimary() &&\r\n      !self.s.replicaSetState.hasSecondary() &&\r\n      self.s.options.secondaryOnlyConnectionAllowed\r\n    ) {\r\n      stateTransition(self, DISCONNECTED);\r\n    } else if (!self.s.replicaSetState.hasPrimary()) {\r\n      stateTransition(self, DISCONNECTED);\r\n    }\r\n\r\n    addServerToList(self.s.connectingServers, this);\r\n  };\r\n}\r\n\r\nfunction shouldTriggerConnect(self) {\r\n  const isConnecting = self.state === CONNECTING;\r\n  const hasPrimary = self.s.replicaSetState.hasPrimary();\r\n  const hasSecondary = self.s.replicaSetState.hasSecondary();\r\n  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\r\n  const readPreferenceSecondary =\r\n    self.s.connectOptions.readPreference &&\r\n    self.s.connectOptions.readPreference.equals(ReadPreference.secondary);\r\n\r\n  return (\r\n    (isConnecting &&\r\n      ((readPreferenceSecondary && hasSecondary) || (!readPreferenceSecondary && hasPrimary))) ||\r\n    (hasSecondary && secondaryOnlyConnectionAllowed)\r\n  );\r\n}\r\n\r\nfunction handleInitialConnectEvent(self, event) {\r\n  return function() {\r\n    var _this = this;\r\n    // Debug log\r\n    if (self.s.logger.isDebug()) {\r\n      self.s.logger.debug(\r\n        f(\r\n          'handleInitialConnectEvent %s from server %s in replset with id %s',\r\n          event,\r\n          this.name,\r\n          self.id\r\n        )\r\n      );\r\n    }\r\n\r\n    // Destroy the instance\r\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\r\n      return this.destroy({ force: true });\r\n    }\r\n\r\n    // Check the type of server\r\n    if (event === 'connect') {\r\n      // Update the state\r\n      var result = self.s.replicaSetState.update(_this);\r\n      if (result === true) {\r\n        // Primary lastIsMaster store it\r\n        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\r\n          self.ismaster = _this.lastIsMaster();\r\n        }\r\n\r\n        // Debug log\r\n        if (self.s.logger.isDebug()) {\r\n          self.s.logger.debug(\r\n            f(\r\n              'handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]',\r\n              event,\r\n              _this.name,\r\n              self.id,\r\n              JSON.stringify(self.s.replicaSetState.set)\r\n            )\r\n          );\r\n        }\r\n\r\n        // Remove the handlers\r\n        for (let i = 0; i < handlers.length; i++) {\r\n          _this.removeAllListeners(handlers[i]);\r\n        }\r\n\r\n        // Add stable state handlers\r\n        _this.on('error', handleEvent(self, 'error'));\r\n        _this.on('close', handleEvent(self, 'close'));\r\n        _this.on('timeout', handleEvent(self, 'timeout'));\r\n        _this.on('parseError', handleEvent(self, 'parseError'));\r\n\r\n        // Do we have a primary or primaryAndSecondary\r\n        if (shouldTriggerConnect(self)) {\r\n          // We are connected\r\n          self.state = CONNECTED;\r\n\r\n          // Set initial connect state\r\n          self.initialConnectState.connect = true;\r\n          // Emit connect event\r\n          process.nextTick(function() {\r\n            self.emit('connect', self);\r\n          });\r\n\r\n          topologyMonitor(self, {});\r\n        }\r\n      } else if (result instanceof MongoError) {\r\n        _this.destroy({ force: true });\r\n        self.destroy({ force: true });\r\n        return self.emit('error', result);\r\n      } else {\r\n        _this.destroy({ force: true });\r\n      }\r\n    } else {\r\n      // Emit failure to connect\r\n      self.emit('failed', this);\r\n\r\n      addServerToList(self.s.connectingServers, this);\r\n      // Remove from the state\r\n      self.s.replicaSetState.remove(this);\r\n    }\r\n\r\n    if (\r\n      self.initialConnectState.connect &&\r\n      !self.initialConnectState.fullsetup &&\r\n      self.s.replicaSetState.hasPrimaryAndSecondary()\r\n    ) {\r\n      // Set initial connect state\r\n      self.initialConnectState.fullsetup = true;\r\n      self.initialConnectState.all = true;\r\n\r\n      process.nextTick(function() {\r\n        self.emit('fullsetup', self);\r\n        self.emit('all', self);\r\n      });\r\n    }\r\n\r\n    // Remove from the list from connectingServers\r\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\r\n      if (self.s.connectingServers[i].equals(this)) {\r\n        self.s.connectingServers.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    // Trigger topologyMonitor\r\n    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {\r\n      topologyMonitor(self, { haInterval: 1 });\r\n    }\r\n  };\r\n}\r\n\r\nfunction connectServers(self, servers) {\r\n  // Update connectingServers\r\n  self.s.connectingServers = self.s.connectingServers.concat(servers);\r\n\r\n  // Index used to interleaf the server connects, avoiding\r\n  // runtime issues on io constrained vm's\r\n  var timeoutInterval = 0;\r\n\r\n  function connect(server, timeoutInterval) {\r\n    setTimeout(function() {\r\n      // Add the server to the state\r\n      if (self.s.replicaSetState.update(server)) {\r\n        // Primary lastIsMaster store it\r\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\r\n          self.ismaster = server.lastIsMaster();\r\n        }\r\n      }\r\n\r\n      // Add event handlers\r\n      server.once('close', handleInitialConnectEvent(self, 'close'));\r\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\r\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\r\n      server.once('error', handleInitialConnectEvent(self, 'error'));\r\n      server.once('connect', handleInitialConnectEvent(self, 'connect'));\r\n\r\n      // SDAM Monitoring events\r\n      server.on('serverOpening', e => self.emit('serverOpening', e));\r\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\r\n      server.on('serverClosed', e => self.emit('serverClosed', e));\r\n\r\n      // Command Monitoring events\r\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\r\n\r\n      // Start connection\r\n      server.connect(self.s.connectOptions);\r\n    }, timeoutInterval);\r\n  }\r\n\r\n  // Start all the servers\r\n  while (servers.length > 0) {\r\n    connect(servers.shift(), timeoutInterval++);\r\n  }\r\n}\r\n\r\n/**\r\n * Emit event if it exists\r\n * @method\r\n */\r\nfunction emitSDAMEvent(self, event, description) {\r\n  if (self.listeners(event).length > 0) {\r\n    self.emit(event, description);\r\n  }\r\n}\r\n\r\n/**\r\n * Initiate server connect\r\n */\r\nReplSet.prototype.connect = function(options) {\r\n  var self = this;\r\n  // Add any connect level options to the internal state\r\n  this.s.connectOptions = options || {};\r\n\r\n  // Set connecting state\r\n  stateTransition(this, CONNECTING);\r\n\r\n  // Create server instances\r\n  var servers = this.s.seedlist.map(function(x) {\r\n    return new Server(\r\n      Object.assign({}, self.s.options, x, options, {\r\n        reconnect: false,\r\n        monitoring: false,\r\n        parent: self,\r\n        clientInfo: clone(self.s.clientInfo)\r\n      })\r\n    );\r\n  });\r\n\r\n  // Error out as high availbility interval must be < than socketTimeout\r\n  if (\r\n    this.s.options.socketTimeout > 0 &&\r\n    this.s.options.socketTimeout <= this.s.options.haInterval\r\n  ) {\r\n    return self.emit(\r\n      'error',\r\n      new MongoError(\r\n        f(\r\n          'haInterval [%s] MS must be set to less than socketTimeout [%s] MS',\r\n          this.s.options.haInterval,\r\n          this.s.options.socketTimeout\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  // Emit the topology opening event\r\n  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });\r\n  // Start all server connections\r\n  connectServers(self, servers);\r\n};\r\n\r\n/**\r\n * Authenticate the topology.\r\n * @method\r\n * @param {MongoCredentials} credentials The credentials for authentication we are using\r\n * @param {authResultCallback} callback A callback function\r\n */\r\nReplSet.prototype.auth = function(credentials, callback) {\r\n  if (typeof callback === 'function') callback(null, null);\r\n};\r\n\r\n/**\r\n * Destroy the server connection\r\n * @param {boolean} [options.force=false] Force destroy the pool\r\n * @method\r\n */\r\nReplSet.prototype.destroy = function(options, callback) {\r\n  options = options || {};\r\n\r\n  let destroyCount = this.s.connectingServers.length + 1; // +1 for the callback from `replicaSetState.destroy`\r\n  const serverDestroyed = () => {\r\n    destroyCount--;\r\n    if (destroyCount > 0) {\r\n      return;\r\n    }\r\n\r\n    // Emit toplogy closing event\r\n    emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });\r\n\r\n    // Transition state\r\n    stateTransition(this, DESTROYED);\r\n\r\n    if (typeof callback === 'function') {\r\n      callback(null, null);\r\n    }\r\n  };\r\n\r\n  // Clear out any monitoring process\r\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId);\r\n\r\n  // Clear out all monitoring\r\n  for (var i = 0; i < this.intervalIds.length; i++) {\r\n    this.intervalIds[i].stop();\r\n  }\r\n\r\n  // Reset list of intervalIds\r\n  this.intervalIds = [];\r\n\r\n  if (destroyCount === 0) {\r\n    serverDestroyed();\r\n    return;\r\n  }\r\n\r\n  // Destroy the replicaset\r\n  this.s.replicaSetState.destroy(options, serverDestroyed);\r\n\r\n  // Destroy all connecting servers\r\n  this.s.connectingServers.forEach(function(x) {\r\n    x.destroy(options, serverDestroyed);\r\n  });\r\n};\r\n\r\n/**\r\n * Unref all connections belong to this server\r\n * @method\r\n */\r\nReplSet.prototype.unref = function() {\r\n  // Transition state\r\n  stateTransition(this, UNREFERENCED);\r\n\r\n  this.s.replicaSetState.allServers().forEach(function(x) {\r\n    x.unref();\r\n  });\r\n\r\n  clearTimeout(this.haTimeoutId);\r\n};\r\n\r\n/**\r\n * Returns the last known ismaster document for this server\r\n * @method\r\n * @return {object}\r\n */\r\nReplSet.prototype.lastIsMaster = function() {\r\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\r\n  // return the secondaries ismaster result.\r\n  if (\r\n    this.s.options.secondaryOnlyConnectionAllowed &&\r\n    !this.s.replicaSetState.hasPrimary() &&\r\n    this.s.replicaSetState.hasSecondary()\r\n  ) {\r\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\r\n  }\r\n\r\n  return this.s.replicaSetState.primary\r\n    ? this.s.replicaSetState.primary.lastIsMaster()\r\n    : this.ismaster;\r\n};\r\n\r\n/**\r\n * All raw connections\r\n * @method\r\n * @return {Connection[]}\r\n */\r\nReplSet.prototype.connections = function() {\r\n  var servers = this.s.replicaSetState.allServers();\r\n  var connections = [];\r\n  for (var i = 0; i < servers.length; i++) {\r\n    connections = connections.concat(servers[i].connections());\r\n  }\r\n\r\n  return connections;\r\n};\r\n\r\n/**\r\n * Figure out if the server is connected\r\n * @method\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @return {boolean}\r\n */\r\nReplSet.prototype.isConnected = function(options) {\r\n  options = options || {};\r\n\r\n  // If we specified a read preference check if we are connected to something\r\n  // than can satisfy this\r\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\r\n    return this.s.replicaSetState.hasSecondary();\r\n  }\r\n\r\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\r\n    return this.s.replicaSetState.hasPrimary();\r\n  }\r\n\r\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\r\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\r\n  }\r\n\r\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\r\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\r\n  }\r\n\r\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\r\n    return true;\r\n  }\r\n\r\n  return this.s.replicaSetState.hasPrimary();\r\n};\r\n\r\n/**\r\n * Figure out if the replicaset instance was destroyed by calling destroy\r\n * @method\r\n * @return {boolean}\r\n */\r\nReplSet.prototype.isDestroyed = function() {\r\n  return this.state === DESTROYED;\r\n};\r\n\r\nconst SERVER_SELECTION_TIMEOUT_MS = 10000; // hardcoded `serverSelectionTimeoutMS` for legacy topology\r\nconst SERVER_SELECTION_INTERVAL_MS = 1000; // time to wait between selection attempts\r\n/**\r\n * Selects a server\r\n *\r\n * @method\r\n * @param {function} selector Unused\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {ClientSession} [options.session] Unused\r\n * @param {function} callback\r\n */\r\nReplSet.prototype.selectServer = function(selector, options, callback) {\r\n  if (typeof selector === 'function' && typeof callback === 'undefined')\r\n    (callback = selector), (selector = undefined), (options = {});\r\n  if (typeof options === 'function') (callback = options), (options = selector);\r\n  options = options || {};\r\n\r\n  let readPreference;\r\n  if (selector instanceof ReadPreference) {\r\n    readPreference = selector;\r\n  } else {\r\n    readPreference = options.readPreference || ReadPreference.primary;\r\n  }\r\n\r\n  let lastError;\r\n  const start = process.hrtime();\r\n  const _selectServer = () => {\r\n    if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {\r\n      if (lastError != null) {\r\n        callback(lastError, null);\r\n      } else {\r\n        callback(new MongoError('Server selection timed out'));\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const server = this.s.replicaSetState.pickServer(readPreference);\r\n    if (server == null) {\r\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\r\n      return;\r\n    }\r\n\r\n    if (!(server instanceof Server)) {\r\n      lastError = server;\r\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\r\n      return;\r\n    }\r\n\r\n    if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\r\n    callback(null, server);\r\n  };\r\n\r\n  _selectServer();\r\n};\r\n\r\n/**\r\n * Get all connected servers\r\n * @method\r\n * @return {Server[]}\r\n */\r\nReplSet.prototype.getServers = function() {\r\n  return this.s.replicaSetState.allServers();\r\n};\r\n\r\n//\r\n// Execute write operation\r\nfunction executeWriteOperation(args, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\r\n  const self = args.self;\r\n  const op = args.op;\r\n  const ns = args.ns;\r\n  const ops = args.ops;\r\n\r\n  if (self.state === DESTROYED) {\r\n    return callback(new MongoError(f('topology was destroyed')));\r\n  }\r\n\r\n  const willRetryWrite =\r\n    !args.retrying &&\r\n    !!options.retryWrites &&\r\n    options.session &&\r\n    isRetryableWritesSupported(self) &&\r\n    !options.session.inTransaction();\r\n\r\n  if (!self.s.replicaSetState.hasPrimary()) {\r\n    if (self.s.disconnectHandler) {\r\n      // Not connected but we have a disconnecthandler\r\n      return self.s.disconnectHandler.add(op, ns, ops, options, callback);\r\n    } else if (!willRetryWrite) {\r\n      // No server returned we had an error\r\n      return callback(new MongoError('no primary server found'));\r\n    }\r\n  }\r\n\r\n  const handler = (err, result) => {\r\n    if (!err) return callback(null, result);\r\n    if (!isRetryableError(err)) {\r\n      err = getMMAPError(err);\r\n      return callback(err);\r\n    }\r\n\r\n    if (willRetryWrite) {\r\n      const newArgs = Object.assign({}, args, { retrying: true });\r\n      return executeWriteOperation(newArgs, options, callback);\r\n    }\r\n\r\n    // Per SDAM, remove primary from replicaset\r\n    if (self.s.replicaSetState.primary) {\r\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, { force: true });\r\n    }\r\n\r\n    return callback(err);\r\n  };\r\n\r\n  if (callback.operationId) {\r\n    handler.operationId = callback.operationId;\r\n  }\r\n\r\n  // increment and assign txnNumber\r\n  if (willRetryWrite) {\r\n    options.session.incrementTransactionNumber();\r\n    options.willRetryWrite = willRetryWrite;\r\n  }\r\n\r\n  self.s.replicaSetState.primary[op](ns, ops, options, handler);\r\n}\r\n\r\n/**\r\n * Insert one or more documents\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of documents to insert\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nReplSet.prototype.insert = function(ns, ops, options, callback) {\r\n  // Execute write operation\r\n  executeWriteOperation({ self: this, op: 'insert', ns, ops }, options, callback);\r\n};\r\n\r\n/**\r\n * Perform one or more update operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of updates\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nReplSet.prototype.update = function(ns, ops, options, callback) {\r\n  // Execute write operation\r\n  executeWriteOperation({ self: this, op: 'update', ns, ops }, options, callback);\r\n};\r\n\r\n/**\r\n * Perform one or more remove operations\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {array} ops An array of removes\r\n * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n * @param {object} [options.writeConcern={}] Write concern for the operation\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nReplSet.prototype.remove = function(ns, ops, options, callback) {\r\n  // Execute write operation\r\n  executeWriteOperation({ self: this, op: 'remove', ns, ops }, options, callback);\r\n};\r\n\r\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\r\n\r\nfunction isWriteCommand(command) {\r\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\r\n}\r\n\r\n/**\r\n * Execute a command\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object} cmd The command hash\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Connection} [options.connection] Specify connection object to execute command against\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {opResultCallback} callback A callback function\r\n */\r\nReplSet.prototype.command = function(ns, cmd, options, callback) {\r\n  if (typeof options === 'function') {\r\n    (callback = options), (options = {}), (options = options || {});\r\n  }\r\n\r\n  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));\r\n  var self = this;\r\n\r\n  // Establish readPreference\r\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;\r\n\r\n  // If the readPreference is primary and we have no primary, store it\r\n  if (\r\n    readPreference.preference === 'primary' &&\r\n    !this.s.replicaSetState.hasPrimary() &&\r\n    this.s.disconnectHandler != null\r\n  ) {\r\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\r\n  } else if (\r\n    readPreference.preference === 'secondary' &&\r\n    !this.s.replicaSetState.hasSecondary() &&\r\n    this.s.disconnectHandler != null\r\n  ) {\r\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\r\n  } else if (\r\n    readPreference.preference !== 'primary' &&\r\n    !this.s.replicaSetState.hasSecondary() &&\r\n    !this.s.replicaSetState.hasPrimary() &&\r\n    this.s.disconnectHandler != null\r\n  ) {\r\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\r\n  }\r\n\r\n  // Pick a server\r\n  var server = this.s.replicaSetState.pickServer(readPreference);\r\n  // We received an error, return it\r\n  if (!(server instanceof Server)) return callback(server);\r\n  // Emit debug event\r\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);\r\n\r\n  // No server returned we had an error\r\n  if (server == null) {\r\n    return callback(\r\n      new MongoError(\r\n        f('no server found that matches the provided readPreference %s', readPreference)\r\n      )\r\n    );\r\n  }\r\n\r\n  const willRetryWrite =\r\n    !options.retrying &&\r\n    !!options.retryWrites &&\r\n    options.session &&\r\n    isRetryableWritesSupported(self) &&\r\n    !options.session.inTransaction() &&\r\n    isWriteCommand(cmd);\r\n\r\n  const cb = (err, result) => {\r\n    if (!err) return callback(null, result);\r\n    if (!isRetryableError(err)) {\r\n      return callback(err);\r\n    }\r\n\r\n    if (willRetryWrite) {\r\n      const newOptions = Object.assign({}, options, { retrying: true });\r\n      return this.command(ns, cmd, newOptions, callback);\r\n    }\r\n\r\n    // Per SDAM, remove primary from replicaset\r\n    if (this.s.replicaSetState.primary) {\r\n      this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });\r\n    }\r\n\r\n    return callback(err);\r\n  };\r\n\r\n  // increment and assign txnNumber\r\n  if (willRetryWrite) {\r\n    options.session.incrementTransactionNumber();\r\n    options.willRetryWrite = willRetryWrite;\r\n  }\r\n\r\n  // Execute the command\r\n  server.command(ns, cmd, options, cb);\r\n};\r\n\r\n/**\r\n * Get a new cursor\r\n * @method\r\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\r\n * @param {object} [options] Options for the cursor\r\n * @param {object} [options.batchSize=0] Batchsize for the operation\r\n * @param {array} [options.documents=[]] Initial documents list for cursor\r\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n * @param {ClientSession} [options.session=null] Session to use for the operation\r\n * @param {object} [options.topology] The internal topology of the created cursor\r\n * @returns {Cursor}\r\n */\r\nReplSet.prototype.cursor = function(ns, cmd, options) {\r\n  options = options || {};\r\n  const topology = options.topology || this;\r\n\r\n  // Set up final cursor type\r\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\r\n\r\n  // Return the cursor\r\n  return new FinalCursor(topology, ns, cmd, options);\r\n};\r\n\r\n/**\r\n * A replset connect event, used to verify that the connection is up and running\r\n *\r\n * @event ReplSet#connect\r\n * @type {ReplSet}\r\n */\r\n\r\n/**\r\n * A replset reconnect event, used to verify that the topology reconnected\r\n *\r\n * @event ReplSet#reconnect\r\n * @type {ReplSet}\r\n */\r\n\r\n/**\r\n * A replset fullsetup event, used to signal that all topology members have been contacted.\r\n *\r\n * @event ReplSet#fullsetup\r\n * @type {ReplSet}\r\n */\r\n\r\n/**\r\n * A replset all event, used to signal that all topology members have been contacted.\r\n *\r\n * @event ReplSet#all\r\n * @type {ReplSet}\r\n */\r\n\r\n/**\r\n * A replset failed event, used to signal that initial replset connection failed.\r\n *\r\n * @event ReplSet#failed\r\n * @type {ReplSet}\r\n */\r\n\r\n/**\r\n * A server member left the replicaset\r\n *\r\n * @event ReplSet#left\r\n * @type {function}\r\n * @param {string} type The type of member that left (primary|secondary|arbiter)\r\n * @param {Server} server The server object that left\r\n */\r\n\r\n/**\r\n * A server member joined the replicaset\r\n *\r\n * @event ReplSet#joined\r\n * @type {function}\r\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\r\n * @param {Server} server The server object that joined\r\n */\r\n\r\n/**\r\n * A server opening SDAM monitoring event\r\n *\r\n * @event ReplSet#serverOpening\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A server closed SDAM monitoring event\r\n *\r\n * @event ReplSet#serverClosed\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A server description SDAM change monitoring event\r\n *\r\n * @event ReplSet#serverDescriptionChanged\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology open SDAM event\r\n *\r\n * @event ReplSet#topologyOpening\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology closed SDAM event\r\n *\r\n * @event ReplSet#topologyClosed\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology structure SDAM change event\r\n *\r\n * @event ReplSet#topologyDescriptionChanged\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology serverHeartbeatStarted SDAM event\r\n *\r\n * @event ReplSet#serverHeartbeatStarted\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology serverHeartbeatFailed SDAM event\r\n *\r\n * @event ReplSet#serverHeartbeatFailed\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * A topology serverHeartbeatSucceeded SDAM change event\r\n *\r\n * @event ReplSet#serverHeartbeatSucceeded\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command was started, if command monitoring is enabled\r\n *\r\n * @event ReplSet#commandStarted\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command succeeded, if command monitoring is enabled\r\n *\r\n * @event ReplSet#commandSucceeded\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command failed, if command monitoring is enabled\r\n *\r\n * @event ReplSet#commandFailed\r\n * @type {object}\r\n */\r\n\r\nmodule.exports = ReplSet;\r\n"]},"metadata":{},"sourceType":"script"}