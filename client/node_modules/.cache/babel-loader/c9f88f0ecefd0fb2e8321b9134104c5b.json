{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst CommandOperation = require('./command');\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst loadCollection = require('../dynamic_loaders').loadCollection;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference; // Filter out any write concern options\n\n\nconst illegalCommandFields = ['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'strict', 'serializeFunctions', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern'];\n\nclass CreateCollectionOperation extends CommandOperation {\n  constructor(db, name, options) {\n    super(db, options);\n    this.name = name;\n  }\n\n  _buildCommand() {\n    const name = this.name;\n    const options = this.options; // Create collection command\n\n    const cmd = {\n      create: name\n    }; // Add all optional parameters\n\n    for (let n in options) {\n      if (options[n] != null && typeof options[n] !== 'function' && illegalCommandFields.indexOf(n) === -1) {\n        cmd[n] = options[n];\n      }\n    }\n\n    return cmd;\n  }\n\n  execute(callback) {\n    const db = this.db;\n    const name = this.name;\n    const options = this.options;\n    let Collection = loadCollection(); // Did the user destroy the topology\n\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    let listCollectionOptions = Object.assign({}, options, {\n      nameOnly: true\n    });\n    listCollectionOptions = applyWriteConcern(listCollectionOptions, {\n      db\n    }, listCollectionOptions); // Check if we have the name\n\n    db.listCollections({\n      name\n    }, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {\n      if (err != null) return handleCallback(callback, err, null);\n\n      if (collections.length > 0 && listCollectionOptions.strict) {\n        return handleCallback(callback, MongoError.create({\n          message: `Collection ${name} already exists. Currently in strict mode.`,\n          driver: true\n        }), null);\n      } else if (collections.length > 0) {\n        try {\n          return handleCallback(callback, null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));\n        } catch (err) {\n          return handleCallback(callback, err);\n        }\n      } // Execute command\n\n\n      super.execute(err => {\n        if (err) return handleCallback(callback, err);\n\n        try {\n          return handleCallback(callback, null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));\n        } catch (err) {\n          return handleCallback(callback, err);\n        }\n      });\n    });\n  }\n\n}\n\ndefineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);\nmodule.exports = CreateCollectionOperation;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/create_collection.js"],"names":["Aspect","require","defineAspects","CommandOperation","applyWriteConcern","handleCallback","loadCollection","MongoError","ReadPreference","illegalCommandFields","CreateCollectionOperation","constructor","db","name","options","_buildCommand","cmd","create","n","indexOf","execute","callback","Collection","serverConfig","isDestroyed","listCollectionOptions","Object","assign","nameOnly","listCollections","setReadPreference","PRIMARY","toArray","err","collections","length","strict","message","driver","s","topology","databaseName","pkFactory","WRITE_OPERATION","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Aspect = require('./operation').Aspect;\r\nconst defineAspects = require('./operation').defineAspects;\r\nconst CommandOperation = require('./command');\r\nconst applyWriteConcern = require('../utils').applyWriteConcern;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst loadCollection = require('../dynamic_loaders').loadCollection;\r\nconst MongoError = require('../core').MongoError;\r\nconst ReadPreference = require('../core').ReadPreference;\r\n\r\n// Filter out any write concern options\r\nconst illegalCommandFields = [\r\n  'w',\r\n  'wtimeout',\r\n  'j',\r\n  'fsync',\r\n  'autoIndexId',\r\n  'strict',\r\n  'serializeFunctions',\r\n  'pkFactory',\r\n  'raw',\r\n  'readPreference',\r\n  'session',\r\n  'readConcern',\r\n  'writeConcern'\r\n];\r\n\r\nclass CreateCollectionOperation extends CommandOperation {\r\n  constructor(db, name, options) {\r\n    super(db, options);\r\n\r\n    this.name = name;\r\n  }\r\n\r\n  _buildCommand() {\r\n    const name = this.name;\r\n    const options = this.options;\r\n\r\n    // Create collection command\r\n    const cmd = { create: name };\r\n    // Add all optional parameters\r\n    for (let n in options) {\r\n      if (\r\n        options[n] != null &&\r\n        typeof options[n] !== 'function' &&\r\n        illegalCommandFields.indexOf(n) === -1\r\n      ) {\r\n        cmd[n] = options[n];\r\n      }\r\n    }\r\n\r\n    return cmd;\r\n  }\r\n\r\n  execute(callback) {\r\n    const db = this.db;\r\n    const name = this.name;\r\n    const options = this.options;\r\n\r\n    let Collection = loadCollection();\r\n\r\n    // Did the user destroy the topology\r\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\r\n      return callback(new MongoError('topology was destroyed'));\r\n    }\r\n\r\n    let listCollectionOptions = Object.assign({}, options, { nameOnly: true });\r\n    listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);\r\n\r\n    // Check if we have the name\r\n    db\r\n      .listCollections({ name }, listCollectionOptions)\r\n      .setReadPreference(ReadPreference.PRIMARY)\r\n      .toArray((err, collections) => {\r\n        if (err != null) return handleCallback(callback, err, null);\r\n        if (collections.length > 0 && listCollectionOptions.strict) {\r\n          return handleCallback(\r\n            callback,\r\n            MongoError.create({\r\n              message: `Collection ${name} already exists. Currently in strict mode.`,\r\n              driver: true\r\n            }),\r\n            null\r\n          );\r\n        } else if (collections.length > 0) {\r\n          try {\r\n            return handleCallback(\r\n              callback,\r\n              null,\r\n              new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options)\r\n            );\r\n          } catch (err) {\r\n            return handleCallback(callback, err);\r\n          }\r\n        }\r\n\r\n        // Execute command\r\n        super.execute(err => {\r\n          if (err) return handleCallback(callback, err);\r\n\r\n          try {\r\n            return handleCallback(\r\n              callback,\r\n              null,\r\n              new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options)\r\n            );\r\n          } catch (err) {\r\n            return handleCallback(callback, err);\r\n          }\r\n        });\r\n      });\r\n  }\r\n}\r\n\r\ndefineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);\r\n\r\nmodule.exports = CreateCollectionOperation;\r\n"]},"metadata":{},"sourceType":"script"}