{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst MongoError = require('../error').MongoError;\n\nconst Pool = require('../connection/pool');\n\nconst relayEvents = require('../utils').relayEvents;\n\nconst wireProtocol = require('../wireprotocol');\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst createClientInfo = require('../topologies/shared').createClientInfo;\n\nconst Logger = require('../connection/logger');\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst monitorServer = require('./monitoring').monitorServer;\n\nconst MongoParseError = require('../error').MongoParseError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst collationNotSupported = require('../utils').collationNotSupported;\n\nconst debugOptions = require('../connection/utils').debugOptions;\n\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError; // Used for filtering out fields for logging\n\n\nconst DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername'];\nconst STATE_DISCONNECTED = 0;\nconst STATE_CONNECTING = 1;\nconst STATE_CONNECTED = 2;\n/**\r\n *\r\n * @fires Server#serverHeartbeatStarted\r\n * @fires Server#serverHeartbeatSucceeded\r\n * @fires Server#serverHeartbeatFailed\r\n */\n\nclass Server extends EventEmitter {\n  /**\r\n   * Create a server\r\n   *\r\n   * @param {ServerDescription} description\r\n   * @param {Object} options\r\n   */\n  constructor(description, options, topology) {\n    super();\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson: options.bson || new BSON(),\n      // client metadata for the initial handshake\n      clientInfo: createClientInfo(options),\n      // state variable to determine if there is an active server check in progress\n      monitoring: false,\n      // the implementation of the monitoring method\n      monitorFunction: options.monitorFunction || monitorServer,\n      // the connection pool\n      pool: null,\n      // the server state\n      state: STATE_DISCONNECTED,\n      credentials: options.credentials,\n      topology\n    };\n  }\n\n  get description() {\n    return this.s.description;\n  }\n\n  get name() {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n\n    return null;\n  }\n  /**\r\n   * Initiate server connect\r\n   */\n\n\n  connect(options) {\n    options = options || {}; // do not allow connect to be called on anything that's not disconnected\n\n    if (this.s.pool && !this.s.pool.isDisconnected() && !this.s.pool.isDestroyed()) {\n      throw new MongoError(`Server instance in invalid state ${this.s.pool.state}`);\n    } // create a pool\n\n\n    const addressParts = this.description.address.split(':');\n    const poolOptions = Object.assign({\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10)\n    }, this.s.options, options, {\n      bson: this.s.bson\n    }); // NOTE: this should only be the case if we are connecting to a single server\n\n    poolOptions.reconnect = true;\n    this.s.pool = new Pool(this, poolOptions); // setup listeners\n\n    this.s.pool.on('connect', connectEventHandler(this));\n    this.s.pool.on('close', errorEventHandler(this));\n    this.s.pool.on('error', errorEventHandler(this));\n    this.s.pool.on('parseError', parseErrorEventHandler(this)); // it is unclear whether consumers should even know about these events\n    // this.s.pool.on('timeout', timeoutEventHandler(this));\n    // this.s.pool.on('reconnect', reconnectEventHandler(this));\n    // this.s.pool.on('reconnectFailed', errorEventHandler(this));\n    // relay all command monitoring events\n\n    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n    this.s.state = STATE_CONNECTING; // If auth settings have been provided, use them\n\n    if (options.auth) {\n      this.s.pool.connect.apply(this.s.pool, options.auth);\n      return;\n    }\n\n    this.s.pool.connect();\n  }\n  /**\r\n   * Destroy the server connection\r\n   *\r\n   * @param {Boolean} [options.force=false] Force destroy the pool\r\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = Object.assign({}, {\n      force: false\n    }, options);\n\n    const done = err => {\n      this.emit('closed');\n      this.s.state = STATE_DISCONNECTED;\n\n      if (typeof callback === 'function') {\n        callback(err, null);\n      }\n    };\n\n    if (!this.s.pool) {\n      return done();\n    }\n\n    ['close', 'error', 'timeout', 'parseError', 'connect'].forEach(event => {\n      this.s.pool.removeAllListeners(event);\n    });\n\n    if (this.s.monitorId) {\n      clearTimeout(this.s.monitorId);\n    }\n\n    this.s.pool.destroy(options.force, done);\n  }\n  /**\r\n   * Immediately schedule monitoring of this server. If there already an attempt being made\r\n   * this will be a no-op.\r\n   */\n\n\n  monitor(options) {\n    options = options || {};\n    if (this.s.state !== STATE_CONNECTED || this.s.monitoring) return;\n    if (this.s.monitorId) clearTimeout(this.s.monitorId);\n    this.s.monitorFunction(this, options);\n  }\n  /**\r\n   * Execute a command\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cmd The command hash\r\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options || {};\n    }\n\n    const error = basicReadValidations(this, options);\n\n    if (error) {\n      return callback(error, null);\n    } // Clone the options\n\n\n    options = Object.assign({}, options, {\n      wireProtocolCommand: false\n    }); // Debug log\n\n    if (this.s.logger.isDebug()) {\n      this.s.logger.debug(`executing command [${JSON.stringify({\n        ns,\n        cmd,\n        options: debugOptions(DEBUG_FIELDS, options)\n      })}] against ${this.name}`);\n    } // error if collation not supported\n\n\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(`server ${this.name} does not support collation`));\n      return;\n    }\n\n    wireProtocol.command(this, ns, cmd, options, (err, result) => {\n      if (err) {\n        if (options.session && err instanceof MongoNetworkError) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (isSDAMUnrecoverableError(err, this)) {\n          this.emit('error', err);\n        }\n      }\n\n      callback(err, result);\n    });\n  }\n  /**\r\n   * Execute a query against the server\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cmd The command document for the query\r\n   * @param {object} options Optional settings\r\n   * @param {function} callback\r\n   */\n\n\n  query(ns, cmd, cursorState, options, callback) {\n    wireProtocol.query(this, ns, cmd, cursorState, options, (err, result) => {\n      if (err) {\n        if (options.session && err instanceof MongoNetworkError) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (isSDAMUnrecoverableError(err, this)) {\n          this.emit('error', err);\n        }\n      }\n\n      callback(err, result);\n    });\n  }\n  /**\r\n   * Execute a `getMore` against the server\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cursorState State data associated with the cursor calling this method\r\n   * @param {object} options Optional settings\r\n   * @param {function} callback\r\n   */\n\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wireProtocol.getMore(this, ns, cursorState, batchSize, options, (err, result) => {\n      if (err) {\n        if (options.session && err instanceof MongoNetworkError) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (isSDAMUnrecoverableError(err, this)) {\n          this.emit('error', err);\n        }\n      }\n\n      callback(err, result);\n    });\n  }\n  /**\r\n   * Execute a `killCursors` command against the server\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cursorState State data associated with the cursor calling this method\r\n   * @param {function} callback\r\n   */\n\n\n  killCursors(ns, cursorState, callback) {\n    wireProtocol.killCursors(this, ns, cursorState, (err, result) => {\n      if (err && isSDAMUnrecoverableError(err, this)) {\n        this.emit('error', err);\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, result);\n      }\n    });\n  }\n  /**\r\n   * Insert one or more documents\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of documents to insert\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'insert',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\r\n   * Perform one or more update operations\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of updates\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  update(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'update',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\r\n   * Perform one or more remove operations\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of removes\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'remove',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n}\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function () {\n    return this.s.topology.clusterTime;\n  },\n  set: function (clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction basicWriteValidations(server) {\n  if (!server.s.pool) {\n    return new MongoError('server instance is not connected');\n  }\n\n  if (server.s.pool.isDestroyed()) {\n    return new MongoError('server instance pool was destroyed');\n  }\n\n  return null;\n}\n\nfunction basicReadValidations(server, options) {\n  const error = basicWriteValidations(server, options);\n\n  if (error) {\n    return error;\n  }\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n  const error = basicWriteValidations(server, options);\n\n  if (error) {\n    callback(error, null);\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(`server ${server.name} does not support collation`));\n    return;\n  }\n\n  return wireProtocol[op](server, ns, ops, options, (err, result) => {\n    if (err) {\n      if (options.session && err instanceof MongoNetworkError) {\n        options.session.serverSession.isDirty = true;\n      }\n\n      if (isSDAMUnrecoverableError(err, server)) {\n        server.emit('error', err);\n      }\n    }\n\n    callback(err, result);\n  });\n}\n\nfunction connectEventHandler(server) {\n  return function (pool, conn) {\n    const ismaster = conn.ismaster;\n    server.s.lastIsMasterMS = conn.lastIsMasterMS;\n\n    if (conn.agreedCompressor) {\n      server.s.pool.options.agreedCompressor = conn.agreedCompressor;\n    }\n\n    if (conn.zlibCompressionLevel) {\n      server.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n    }\n\n    if (conn.ismaster.$clusterTime) {\n      const $clusterTime = conn.ismaster.$clusterTime;\n      server.s.sclusterTime = $clusterTime;\n    } // log the connection event if requested\n\n\n    if (server.s.logger.isInfo()) {\n      server.s.logger.info(`server ${server.name} connected with ismaster [${JSON.stringify(ismaster)}]`);\n    } // emit an event indicating that our description has changed\n\n\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, ismaster)); // we are connected and handshaked (guaranteed by the pool)\n\n    server.s.state = STATE_CONNECTED;\n    server.emit('connect', server);\n  };\n}\n\nfunction errorEventHandler(server) {\n  return function (err) {\n    if (err) {\n      server.emit('error', new MongoNetworkError(err));\n    }\n\n    server.emit('close');\n  };\n}\n\nfunction parseErrorEventHandler(server) {\n  return function (err) {\n    server.s.state = STATE_DISCONNECTED;\n    server.emit('error', new MongoParseError(err));\n  };\n}\n\nmodule.exports = Server;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/sdam/server.js"],"names":["EventEmitter","require","MongoError","Pool","relayEvents","wireProtocol","BSON","retrieveBSON","createClientInfo","Logger","ServerDescription","ReadPreference","monitorServer","MongoParseError","MongoNetworkError","collationNotSupported","debugOptions","isSDAMUnrecoverableError","DEBUG_FIELDS","STATE_DISCONNECTED","STATE_CONNECTING","STATE_CONNECTED","Server","constructor","description","options","topology","s","logger","bson","clientInfo","monitoring","monitorFunction","pool","state","credentials","name","address","autoEncrypter","connect","isDisconnected","isDestroyed","addressParts","split","poolOptions","Object","assign","host","port","parseInt","reconnect","on","connectEventHandler","errorEventHandler","parseErrorEventHandler","auth","apply","destroy","callback","force","done","err","emit","forEach","event","removeAllListeners","monitorId","clearTimeout","monitor","command","ns","cmd","error","basicReadValidations","wireProtocolCommand","isDebug","debug","JSON","stringify","result","session","serverSession","isDirty","query","cursorState","getMore","batchSize","killCursors","insert","ops","executeWriteOperation","server","op","update","remove","defineProperty","prototype","get","clusterTime","set","basicWriteValidations","readPreference","args","Array","isArray","conn","ismaster","lastIsMasterMS","agreedCompressor","zlibCompressionLevel","$clusterTime","sclusterTime","isInfo","info","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\nconst EventEmitter = require('events');\r\nconst MongoError = require('../error').MongoError;\r\nconst Pool = require('../connection/pool');\r\nconst relayEvents = require('../utils').relayEvents;\r\nconst wireProtocol = require('../wireprotocol');\r\nconst BSON = require('../connection/utils').retrieveBSON();\r\nconst createClientInfo = require('../topologies/shared').createClientInfo;\r\nconst Logger = require('../connection/logger');\r\nconst ServerDescription = require('./server_description').ServerDescription;\r\nconst ReadPreference = require('../topologies/read_preference');\r\nconst monitorServer = require('./monitoring').monitorServer;\r\nconst MongoParseError = require('../error').MongoParseError;\r\nconst MongoNetworkError = require('../error').MongoNetworkError;\r\nconst collationNotSupported = require('../utils').collationNotSupported;\r\nconst debugOptions = require('../connection/utils').debugOptions;\r\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\r\n\r\n// Used for filtering out fields for logging\r\nconst DEBUG_FIELDS = [\r\n  'reconnect',\r\n  'reconnectTries',\r\n  'reconnectInterval',\r\n  'emitError',\r\n  'cursorFactory',\r\n  'host',\r\n  'port',\r\n  'size',\r\n  'keepAlive',\r\n  'keepAliveInitialDelay',\r\n  'noDelay',\r\n  'connectionTimeout',\r\n  'checkServerIdentity',\r\n  'socketTimeout',\r\n  'ssl',\r\n  'ca',\r\n  'crl',\r\n  'cert',\r\n  'key',\r\n  'rejectUnauthorized',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'servername'\r\n];\r\n\r\nconst STATE_DISCONNECTED = 0;\r\nconst STATE_CONNECTING = 1;\r\nconst STATE_CONNECTED = 2;\r\n\r\n/**\r\n *\r\n * @fires Server#serverHeartbeatStarted\r\n * @fires Server#serverHeartbeatSucceeded\r\n * @fires Server#serverHeartbeatFailed\r\n */\r\nclass Server extends EventEmitter {\r\n  /**\r\n   * Create a server\r\n   *\r\n   * @param {ServerDescription} description\r\n   * @param {Object} options\r\n   */\r\n  constructor(description, options, topology) {\r\n    super();\r\n\r\n    this.s = {\r\n      // the server description\r\n      description,\r\n      // a saved copy of the incoming options\r\n      options,\r\n      // the server logger\r\n      logger: Logger('Server', options),\r\n      // the bson parser\r\n      bson: options.bson || new BSON(),\r\n      // client metadata for the initial handshake\r\n      clientInfo: createClientInfo(options),\r\n      // state variable to determine if there is an active server check in progress\r\n      monitoring: false,\r\n      // the implementation of the monitoring method\r\n      monitorFunction: options.monitorFunction || monitorServer,\r\n      // the connection pool\r\n      pool: null,\r\n      // the server state\r\n      state: STATE_DISCONNECTED,\r\n      credentials: options.credentials,\r\n      topology\r\n    };\r\n  }\r\n\r\n  get description() {\r\n    return this.s.description;\r\n  }\r\n\r\n  get name() {\r\n    return this.s.description.address;\r\n  }\r\n\r\n  get autoEncrypter() {\r\n    if (this.s.options && this.s.options.autoEncrypter) {\r\n      return this.s.options.autoEncrypter;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Initiate server connect\r\n   */\r\n  connect(options) {\r\n    options = options || {};\r\n\r\n    // do not allow connect to be called on anything that's not disconnected\r\n    if (this.s.pool && !this.s.pool.isDisconnected() && !this.s.pool.isDestroyed()) {\r\n      throw new MongoError(`Server instance in invalid state ${this.s.pool.state}`);\r\n    }\r\n\r\n    // create a pool\r\n    const addressParts = this.description.address.split(':');\r\n    const poolOptions = Object.assign(\r\n      { host: addressParts[0], port: parseInt(addressParts[1], 10) },\r\n      this.s.options,\r\n      options,\r\n      { bson: this.s.bson }\r\n    );\r\n\r\n    // NOTE: this should only be the case if we are connecting to a single server\r\n    poolOptions.reconnect = true;\r\n\r\n    this.s.pool = new Pool(this, poolOptions);\r\n\r\n    // setup listeners\r\n    this.s.pool.on('connect', connectEventHandler(this));\r\n    this.s.pool.on('close', errorEventHandler(this));\r\n    this.s.pool.on('error', errorEventHandler(this));\r\n    this.s.pool.on('parseError', parseErrorEventHandler(this));\r\n\r\n    // it is unclear whether consumers should even know about these events\r\n    // this.s.pool.on('timeout', timeoutEventHandler(this));\r\n    // this.s.pool.on('reconnect', reconnectEventHandler(this));\r\n    // this.s.pool.on('reconnectFailed', errorEventHandler(this));\r\n\r\n    // relay all command monitoring events\r\n    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed']);\r\n\r\n    this.s.state = STATE_CONNECTING;\r\n\r\n    // If auth settings have been provided, use them\r\n    if (options.auth) {\r\n      this.s.pool.connect.apply(this.s.pool, options.auth);\r\n      return;\r\n    }\r\n\r\n    this.s.pool.connect();\r\n  }\r\n\r\n  /**\r\n   * Destroy the server connection\r\n   *\r\n   * @param {Boolean} [options.force=false] Force destroy the pool\r\n   */\r\n  destroy(options, callback) {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = Object.assign({}, { force: false }, options);\r\n\r\n    const done = err => {\r\n      this.emit('closed');\r\n      this.s.state = STATE_DISCONNECTED;\r\n      if (typeof callback === 'function') {\r\n        callback(err, null);\r\n      }\r\n    };\r\n\r\n    if (!this.s.pool) {\r\n      return done();\r\n    }\r\n\r\n    ['close', 'error', 'timeout', 'parseError', 'connect'].forEach(event => {\r\n      this.s.pool.removeAllListeners(event);\r\n    });\r\n\r\n    if (this.s.monitorId) {\r\n      clearTimeout(this.s.monitorId);\r\n    }\r\n\r\n    this.s.pool.destroy(options.force, done);\r\n  }\r\n\r\n  /**\r\n   * Immediately schedule monitoring of this server. If there already an attempt being made\r\n   * this will be a no-op.\r\n   */\r\n  monitor(options) {\r\n    options = options || {};\r\n    if (this.s.state !== STATE_CONNECTED || this.s.monitoring) return;\r\n    if (this.s.monitorId) clearTimeout(this.s.monitorId);\r\n    this.s.monitorFunction(this, options);\r\n  }\r\n\r\n  /**\r\n   * Execute a command\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cmd The command hash\r\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  command(ns, cmd, options, callback) {\r\n    if (typeof options === 'function') {\r\n      (callback = options), (options = {}), (options = options || {});\r\n    }\r\n\r\n    const error = basicReadValidations(this, options);\r\n    if (error) {\r\n      return callback(error, null);\r\n    }\r\n\r\n    // Clone the options\r\n    options = Object.assign({}, options, { wireProtocolCommand: false });\r\n\r\n    // Debug log\r\n    if (this.s.logger.isDebug()) {\r\n      this.s.logger.debug(\r\n        `executing command [${JSON.stringify({\r\n          ns,\r\n          cmd,\r\n          options: debugOptions(DEBUG_FIELDS, options)\r\n        })}] against ${this.name}`\r\n      );\r\n    }\r\n\r\n    // error if collation not supported\r\n    if (collationNotSupported(this, cmd)) {\r\n      callback(new MongoError(`server ${this.name} does not support collation`));\r\n      return;\r\n    }\r\n\r\n    wireProtocol.command(this, ns, cmd, options, (err, result) => {\r\n      if (err) {\r\n        if (options.session && err instanceof MongoNetworkError) {\r\n          options.session.serverSession.isDirty = true;\r\n        }\r\n\r\n        if (isSDAMUnrecoverableError(err, this)) {\r\n          this.emit('error', err);\r\n        }\r\n      }\r\n\r\n      callback(err, result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute a query against the server\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cmd The command document for the query\r\n   * @param {object} options Optional settings\r\n   * @param {function} callback\r\n   */\r\n  query(ns, cmd, cursorState, options, callback) {\r\n    wireProtocol.query(this, ns, cmd, cursorState, options, (err, result) => {\r\n      if (err) {\r\n        if (options.session && err instanceof MongoNetworkError) {\r\n          options.session.serverSession.isDirty = true;\r\n        }\r\n\r\n        if (isSDAMUnrecoverableError(err, this)) {\r\n          this.emit('error', err);\r\n        }\r\n      }\r\n\r\n      callback(err, result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute a `getMore` against the server\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cursorState State data associated with the cursor calling this method\r\n   * @param {object} options Optional settings\r\n   * @param {function} callback\r\n   */\r\n  getMore(ns, cursorState, batchSize, options, callback) {\r\n    wireProtocol.getMore(this, ns, cursorState, batchSize, options, (err, result) => {\r\n      if (err) {\r\n        if (options.session && err instanceof MongoNetworkError) {\r\n          options.session.serverSession.isDirty = true;\r\n        }\r\n\r\n        if (isSDAMUnrecoverableError(err, this)) {\r\n          this.emit('error', err);\r\n        }\r\n      }\r\n\r\n      callback(err, result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute a `killCursors` command against the server\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cursorState State data associated with the cursor calling this method\r\n   * @param {function} callback\r\n   */\r\n  killCursors(ns, cursorState, callback) {\r\n    wireProtocol.killCursors(this, ns, cursorState, (err, result) => {\r\n      if (err && isSDAMUnrecoverableError(err, this)) {\r\n        this.emit('error', err);\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        callback(err, result);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Insert one or more documents\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of documents to insert\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  insert(ns, ops, options, callback) {\r\n    executeWriteOperation({ server: this, op: 'insert', ns, ops }, options, callback);\r\n  }\r\n\r\n  /**\r\n   * Perform one or more update operations\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of updates\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  update(ns, ops, options, callback) {\r\n    executeWriteOperation({ server: this, op: 'update', ns, ops }, options, callback);\r\n  }\r\n\r\n  /**\r\n   * Perform one or more remove operations\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of removes\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  remove(ns, ops, options, callback) {\r\n    executeWriteOperation({ server: this, op: 'remove', ns, ops }, options, callback);\r\n  }\r\n}\r\n\r\nObject.defineProperty(Server.prototype, 'clusterTime', {\r\n  get: function() {\r\n    return this.s.topology.clusterTime;\r\n  },\r\n  set: function(clusterTime) {\r\n    this.s.topology.clusterTime = clusterTime;\r\n  }\r\n});\r\n\r\nfunction basicWriteValidations(server) {\r\n  if (!server.s.pool) {\r\n    return new MongoError('server instance is not connected');\r\n  }\r\n\r\n  if (server.s.pool.isDestroyed()) {\r\n    return new MongoError('server instance pool was destroyed');\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction basicReadValidations(server, options) {\r\n  const error = basicWriteValidations(server, options);\r\n  if (error) {\r\n    return error;\r\n  }\r\n\r\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\r\n    return new MongoError('readPreference must be an instance of ReadPreference');\r\n  }\r\n}\r\n\r\nfunction executeWriteOperation(args, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\r\n  const server = args.server;\r\n  const op = args.op;\r\n  const ns = args.ns;\r\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\r\n\r\n  const error = basicWriteValidations(server, options);\r\n  if (error) {\r\n    callback(error, null);\r\n    return;\r\n  }\r\n\r\n  if (collationNotSupported(server, options)) {\r\n    callback(new MongoError(`server ${server.name} does not support collation`));\r\n    return;\r\n  }\r\n\r\n  return wireProtocol[op](server, ns, ops, options, (err, result) => {\r\n    if (err) {\r\n      if (options.session && err instanceof MongoNetworkError) {\r\n        options.session.serverSession.isDirty = true;\r\n      }\r\n\r\n      if (isSDAMUnrecoverableError(err, server)) {\r\n        server.emit('error', err);\r\n      }\r\n    }\r\n\r\n    callback(err, result);\r\n  });\r\n}\r\n\r\nfunction connectEventHandler(server) {\r\n  return function(pool, conn) {\r\n    const ismaster = conn.ismaster;\r\n    server.s.lastIsMasterMS = conn.lastIsMasterMS;\r\n    if (conn.agreedCompressor) {\r\n      server.s.pool.options.agreedCompressor = conn.agreedCompressor;\r\n    }\r\n\r\n    if (conn.zlibCompressionLevel) {\r\n      server.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\r\n    }\r\n\r\n    if (conn.ismaster.$clusterTime) {\r\n      const $clusterTime = conn.ismaster.$clusterTime;\r\n      server.s.sclusterTime = $clusterTime;\r\n    }\r\n\r\n    // log the connection event if requested\r\n    if (server.s.logger.isInfo()) {\r\n      server.s.logger.info(\r\n        `server ${server.name} connected with ismaster [${JSON.stringify(ismaster)}]`\r\n      );\r\n    }\r\n\r\n    // emit an event indicating that our description has changed\r\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, ismaster));\r\n\r\n    // we are connected and handshaked (guaranteed by the pool)\r\n    server.s.state = STATE_CONNECTED;\r\n    server.emit('connect', server);\r\n  };\r\n}\r\n\r\nfunction errorEventHandler(server) {\r\n  return function(err) {\r\n    if (err) {\r\n      server.emit('error', new MongoNetworkError(err));\r\n    }\r\n\r\n    server.emit('close');\r\n  };\r\n}\r\n\r\nfunction parseErrorEventHandler(server) {\r\n  return function(err) {\r\n    server.s.state = STATE_DISCONNECTED;\r\n    server.emit('error', new MongoParseError(err));\r\n  };\r\n}\r\n\r\nmodule.exports = Server;\r\n"]},"metadata":{},"sourceType":"script"}