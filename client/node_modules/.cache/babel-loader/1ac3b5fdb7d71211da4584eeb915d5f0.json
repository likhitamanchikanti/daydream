{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst ServerType = require('./server_description').ServerType;\n\nconst TopologyDescription = require('./topology_description').TopologyDescription;\n\nconst TopologyType = require('./topology_description').TopologyType;\n\nconst monitoring = require('./monitoring');\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\n\nconst Server = require('./server');\n\nconst relayEvents = require('../utils').relayEvents;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst readPreferenceServerSelector = require('./server_selectors').readPreferenceServerSelector;\n\nconst writableServerSelector = require('./server_selectors').writableServerSelector;\n\nconst isRetryableWritesSupported = require('../topologies/shared').isRetryableWritesSupported;\n\nconst CoreCursor = require('../cursor').CoreCursor;\n\nconst deprecate = require('util').deprecate;\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst createCompressionInfo = require('../topologies/shared').createCompressionInfo;\n\nconst isRetryableError = require('../error').isRetryableError;\n\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\n\nconst ClientSession = require('../sessions').ClientSession;\n\nconst createClientInfo = require('../topologies/shared').createClientInfo;\n\nconst MongoError = require('../error').MongoError;\n\nconst resolveClusterTime = require('../topologies/shared').resolveClusterTime;\n\nconst SrvPoller = require('./srv_polling').SrvPoller;\n\nconst getMMAPError = require('../topologies/shared').getMMAPError; // Global state\n\n\nlet globalTopologyCounter = 0; // Constants\n\nconst TOPOLOGY_DEFAULTS = {\n  localThresholdMS: 15,\n  serverSelectionTimeoutMS: 30000,\n  heartbeatFrequencyMS: 10000,\n  minHeartbeatFrequencyMS: 500\n}; // events that we relay to the `Topology`\n\nconst SERVER_RELAY_EVENTS = ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'commandStarted', 'commandSucceeded', 'commandFailed', // NOTE: Legacy events\n'monitoring']; // all events we listen to from `Server` instances\n\nconst LOCAL_SERVER_EVENTS = SERVER_RELAY_EVENTS.concat(['error', 'connect', 'descriptionReceived', 'close', 'ended']);\n/**\r\n * A container of server instances representing a connection to a MongoDB topology.\r\n *\r\n * @fires Topology#serverOpening\r\n * @fires Topology#serverClosed\r\n * @fires Topology#serverDescriptionChanged\r\n * @fires Topology#topologyOpening\r\n * @fires Topology#topologyClosed\r\n * @fires Topology#topologyDescriptionChanged\r\n * @fires Topology#serverHeartbeatStarted\r\n * @fires Topology#serverHeartbeatSucceeded\r\n * @fires Topology#serverHeartbeatFailed\r\n */\n\nclass Topology extends EventEmitter {\n  /**\r\n   * Create a topology\r\n   *\r\n   * @param {Array|String} [seedlist] a string list, or array of Server instances to connect to\r\n   * @param {Object} [options] Optional settings\r\n   * @param {Number} [options.localThresholdMS=15] The size of the latency window for selecting among multiple suitable servers\r\n   * @param {Number} [options.serverSelectionTimeoutMS=30000] How long to block for server selection before throwing an error\r\n   * @param {Number} [options.heartbeatFrequencyMS=10000] The frequency with which topology updates are scheduled\r\n   */\n  constructor(seedlist, options) {\n    super();\n\n    if (typeof options === 'undefined' && typeof seedlist !== 'string') {\n      options = seedlist;\n      seedlist = []; // this is for legacy single server constructor support\n\n      if (options.host) {\n        seedlist.push({\n          host: options.host,\n          port: options.port\n        });\n      }\n    }\n\n    seedlist = seedlist || [];\n\n    if (typeof seedlist === 'string') {\n      seedlist = parseStringSeedlist(seedlist);\n    }\n\n    options = Object.assign({}, TOPOLOGY_DEFAULTS, options);\n    const topologyType = topologyTypeFromSeedlist(seedlist, options);\n    const topologyId = globalTopologyCounter++;\n    const serverDescriptions = seedlist.reduce((result, seed) => {\n      if (seed.domain_socket) seed.host = seed.domain_socket;\n      const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;\n      result.set(address, new ServerDescription(address));\n      return result;\n    }, new Map());\n    this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options,\n      // initial seedlist of servers to connect to\n      seedlist: seedlist,\n      // the topology description\n      description: new TopologyDescription(topologyType, serverDescriptions, options.replicaSet, null, null, null, options),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatIntervalMS: options.minHeartbeatIntervalMS,\n      // allow users to override the cursor factory\n      Cursor: options.cursorFactory || CoreCursor,\n      // the bson parser\n      bson: options.bson || new BSON(),\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: options.promiseLibrary || Promise,\n      credentials: options.credentials,\n      clusterTime: null,\n      // timer management\n      monitorTimers: [],\n      iterationTimers: []\n    }; // amend options for server instance creation\n\n    this.s.options.compression = {\n      compressors: createCompressionInfo(options)\n    }; // add client info\n\n    this.s.clientInfo = createClientInfo(options);\n\n    if (options.srvHost) {\n      this.s.srvPoller = options.srvPoller || new SrvPoller({\n        heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,\n        srvHost: options.srvHost,\n        // TODO: GET THIS\n        logger: options.logger,\n        loggerLevel: options.loggerLevel\n      });\n\n      this.s.detectTopologyDescriptionChange = ev => {\n        const previousType = ev.previousDescription.type;\n        const newType = ev.newDescription.type;\n\n        if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {\n          this.s.handleSrvPolling = srvPollingHandler(this);\n          this.s.srvPoller.on('srvRecordDiscovery', this.s.handleSrvPolling);\n          this.s.srvPoller.start();\n        }\n      };\n\n      this.on('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\n    }\n  }\n  /**\r\n   * @return A `TopologyDescription` for this topology\r\n   */\n\n\n  get description() {\n    return this.s.description;\n  }\n\n  get parserType() {\n    return BSON.native ? 'c++' : 'js';\n  }\n  /**\r\n   * All raw connections\r\n   * @method\r\n   * @return {Connection[]}\r\n   */\n\n\n  connections() {\n    return Array.from(this.s.servers.values()).reduce((result, server) => {\n      return result.concat(server.s.pool.allConnections());\n    }, []);\n  }\n  /**\r\n   * Initiate server connect\r\n   *\r\n   * @param {Object} [options] Optional settings\r\n   * @param {Array} [options.auth=null] Array of auth options to apply on connect\r\n   * @param {function} [callback] An optional callback called once on the first connected server\r\n   */\n\n\n  connect(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {}; // emit SDAM monitoring events\n\n    this.emit('topologyOpening', new monitoring.TopologyOpeningEvent(this.s.id)); // emit an event for the topology change\n\n    this.emit('topologyDescriptionChanged', new monitoring.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), // initial is always Unknown\n    this.s.description));\n    connectServers(this, Array.from(this.s.description.servers.values()));\n    this.s.connected = true; // otherwise, wait for a server to properly connect based on user provided read preference,\n    // or primary.\n\n    translateReadPreference(options);\n    const readPreference = options.readPreference || ReadPreference.primary;\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\n      if (err) {\n        if (typeof callback === 'function') {\n          callback(err, null);\n        } else {\n          this.emit('error', err);\n        }\n\n        return;\n      }\n\n      const errorHandler = err => {\n        server.removeListener('connect', connectHandler);\n        if (typeof callback === 'function') callback(err, null);\n      };\n\n      const connectHandler = (_, err) => {\n        server.removeListener('error', errorHandler);\n        this.emit('open', err, this);\n        this.emit('connect', this);\n        if (typeof callback === 'function') callback(err, this);\n      };\n\n      const STATE_CONNECTING = 1;\n\n      if (server.s.state === STATE_CONNECTING) {\n        server.once('error', errorHandler);\n        server.once('connect', connectHandler);\n        return;\n      }\n\n      connectHandler();\n    });\n  }\n  /**\r\n   * Close this topology\r\n   */\n\n\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {}; // clear all existing monitor timers\n\n    this.s.monitorTimers.map(timer => clearTimeout(timer));\n    this.s.monitorTimers = [];\n    this.s.iterationTimers.map(timer => clearTimeout(timer));\n    this.s.iterationTimers = [];\n\n    if (this.s.sessionPool) {\n      this.s.sessions.forEach(session => session.endSession());\n      this.s.sessionPool.endAllPooledSessions();\n    }\n\n    if (this.s.srvPoller) {\n      this.s.srvPoller.stop();\n\n      if (this.s.handleSrvPolling) {\n        this.s.srvPoller.removeListener('srvRecordDiscovery', this.s.handleSrvPolling);\n        delete this.s.handleSrvPolling;\n      }\n    }\n\n    if (this.s.detectTopologyDescriptionChange) {\n      this.removeListener('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\n      delete this.s.detectTopologyDescriptionChange;\n    }\n\n    const servers = this.s.servers;\n\n    if (servers.size === 0) {\n      this.s.connected = false;\n\n      if (typeof callback === 'function') {\n        callback(null, null);\n      }\n\n      return;\n    } // destroy all child servers\n\n\n    let destroyed = 0;\n    servers.forEach(server => destroyServer(server, this, () => {\n      destroyed++;\n\n      if (destroyed === servers.size) {\n        // emit an event for close\n        this.emit('topologyClosed', new monitoring.TopologyClosedEvent(this.s.id));\n        this.s.connected = false;\n\n        if (typeof callback === 'function') {\n          callback(null, null);\n        }\n      }\n    }));\n  }\n  /**\r\n   * Selects a server according to the selection predicate provided\r\n   *\r\n   * @param {function} [selector] An optional selector to select servers by, defaults to a random selection within a latency window\r\n   * @param {object} [options] Optional settings related to server selection\r\n   * @param {number} [options.serverSelectionTimeoutMS] How long to block for server selection before throwing an error\r\n   * @param {function} callback The callback used to indicate success or failure\r\n   * @return {Server} An instance of a `Server` meeting the criteria of the predicate provided\r\n   */\n\n\n  selectServer(selector, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n\n      if (typeof selector !== 'function') {\n        options = selector;\n        let readPreference;\n\n        if (selector instanceof ReadPreference) {\n          readPreference = selector;\n        } else {\n          translateReadPreference(options);\n          readPreference = options.readPreference || ReadPreference.primary;\n        }\n\n        selector = readPreferenceServerSelector(readPreference);\n      } else {\n        options = {};\n      }\n    }\n\n    options = Object.assign({}, {\n      serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS\n    }, options);\n    const isSharded = this.description.type === TopologyType.Sharded;\n    const session = options.session;\n    const transaction = session && session.transaction;\n\n    if (isSharded && transaction && transaction.server) {\n      callback(null, transaction.server);\n      return;\n    } // clear out any existing iteration timers\n\n\n    this.s.iterationTimers.map(timer => clearTimeout(timer));\n    this.s.iterationTimers = [];\n    selectServers(this, selector, options.serverSelectionTimeoutMS, process.hrtime(), (err, servers) => {\n      if (err) return callback(err, null);\n      const selectedServer = randomSelection(servers);\n\n      if (isSharded && transaction && transaction.isActive) {\n        transaction.pinServer(selectedServer);\n      }\n\n      callback(null, selectedServer);\n    });\n  } // Sessions related methods\n\n  /**\r\n   * @return Whether the topology should initiate selection to determine session support\r\n   */\n\n\n  shouldCheckForSessionSupport() {\n    return this.description.type === TopologyType.Single && !this.description.hasKnownServers || !this.description.hasDataBearingServers;\n  }\n  /**\r\n   * @return Whether sessions are supported on the current topology\r\n   */\n\n\n  hasSessionSupport() {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n  /**\r\n   * Start a logical session\r\n   */\n\n\n  startSession(options, clientOptions) {\n    const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);\n    session.once('ended', () => {\n      this.s.sessions.delete(session);\n    });\n    this.s.sessions.add(session);\n    return session;\n  }\n  /**\r\n   * Send endSessions command(s) with the given session ids\r\n   *\r\n   * @param {Array} sessions The sessions to end\r\n   * @param {function} [callback]\r\n   */\n\n\n  endSessions(sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred,\n      noResponse: true\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n  /**\r\n   * Update the internal TopologyDescription with a ServerDescription\r\n   *\r\n   * @param {object} serverDescription The server to update in the internal list of server descriptions\r\n   */\n\n\n  serverUpdateHandler(serverDescription) {\n    if (!this.s.description.hasServer(serverDescription.address)) {\n      return;\n    } // these will be used for monitoring events later\n\n\n    const previousTopologyDescription = this.s.description;\n    const previousServerDescription = this.s.description.servers.get(serverDescription.address); // first update the TopologyDescription\n\n    this.s.description = this.s.description.update(serverDescription);\n\n    if (this.s.description.compatibilityError) {\n      this.emit('error', new MongoError(this.s.description.compatibilityError));\n      return;\n    } // emit monitoring events for this change\n\n\n    this.emit('serverDescriptionChanged', new monitoring.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address))); // update server list from updated descriptions\n\n    updateServers(this, serverDescription); // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n    // a server it MUST compare it to the current highest seen cluster time\n    // for the deployment. If the new cluster time is higher than the\n    // highest seen cluster time it MUST become the new highest seen cluster\n    // time. Two cluster times are compared using only the BsonTimestamp\n    // value of the clusterTime embedded field.\"\n\n    const clusterTime = serverDescription.$clusterTime;\n\n    if (clusterTime) {\n      resolveClusterTime(this, clusterTime);\n    }\n\n    this.emit('topologyDescriptionChanged', new monitoring.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n  }\n\n  auth(credentials, callback) {\n    if (typeof credentials === 'function') callback = credentials, credentials = null;\n    if (typeof callback === 'function') callback(null, true);\n  }\n\n  logout(callback) {\n    if (typeof callback === 'function') callback(null, true);\n  } // Basic operation support. Eventually this should be moved into command construction\n  // during the command refactor.\n\n  /**\r\n   * Insert one or more documents\r\n   *\r\n   * @param {String} ns The full qualified namespace for this operation\r\n   * @param {Array} ops An array of documents to insert\r\n   * @param {Boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {Object} [options.writeConcern] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\r\n   * @param {ClientSession} [options.session] Session to use for the operation\r\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({\n      topology: this,\n      op: 'insert',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\r\n   * Perform one or more update operations\r\n   *\r\n   * @param {string} ns The fully qualified namespace for this operation\r\n   * @param {array} ops An array of updates\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\r\n   * @param {ClientSession} [options.session] Session to use for the operation\r\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  update(ns, ops, options, callback) {\n    executeWriteOperation({\n      topology: this,\n      op: 'update',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\r\n   * Perform one or more remove operations\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of removes\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({\n      topology: this,\n      op: 'remove',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\r\n   * Execute a command\r\n   *\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cmd The command hash\r\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n   * @param {Connection} [options.connection] Specify connection object to execute command against\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\n\n\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options || {};\n    }\n\n    translateReadPreference(options);\n    const readPreference = options.readPreference || ReadPreference.primary;\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(this) && !options.session.inTransaction() && isWriteCommand(cmd);\n\n      const cb = (err, result) => {\n        if (!err) return callback(null, result);\n\n        if (!isRetryableError(err)) {\n          return callback(err);\n        }\n\n        if (willRetryWrite) {\n          const newOptions = Object.assign({}, options, {\n            retrying: true\n          });\n          return this.command(ns, cmd, newOptions, callback);\n        }\n\n        return callback(err);\n      }; // increment and assign txnNumber\n\n\n      if (willRetryWrite) {\n        options.session.incrementTransactionNumber();\n        options.willRetryWrite = willRetryWrite;\n      }\n\n      server.command(ns, cmd, options, cb);\n    });\n  }\n  /**\r\n   * Create a new cursor\r\n   *\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\r\n   * @param {object} [options] Options for the cursor\r\n   * @param {object} [options.batchSize=0] Batchsize for the operation\r\n   * @param {array} [options.documents=[]] Initial documents list for cursor\r\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {object} [options.topology] The internal topology of the created cursor\r\n   * @returns {Cursor}\r\n   */\n\n\n  cursor(ns, cmd, options) {\n    options = options || {};\n    const topology = options.topology || this;\n    const CursorClass = options.cursorFactory || this.s.Cursor;\n    translateReadPreference(options);\n    return new CursorClass(topology, ns, cmd, options);\n  }\n\n  get clientInfo() {\n    return this.s.clientInfo;\n  } // Legacy methods for compat with old topology types\n\n\n  isConnected() {\n    // console.log('not implemented: `isConnected`');\n    return true;\n  }\n\n  isDestroyed() {\n    // console.log('not implemented: `isDestroyed`');\n    return false;\n  }\n\n  unref() {\n    console.log('not implemented: `unref`');\n  } // NOTE: There are many places in code where we explicitly check the last isMaster\n  //       to do feature support detection. This should be done any other way, but for\n  //       now we will just return the first isMaster seen, which should suffice.\n\n\n  lastIsMaster() {\n    const serverDescriptions = Array.from(this.description.servers.values());\n    if (serverDescriptions.length === 0) return {};\n    const sd = serverDescriptions.filter(sd => sd.type !== ServerType.Unknown)[0];\n    const result = sd || {\n      maxWireVersion: this.description.commonWireVersion\n    };\n    return result;\n  }\n\n  get logicalSessionTimeoutMinutes() {\n    return this.description.logicalSessionTimeoutMinutes;\n  }\n\n  get bson() {\n    return this.s.bson;\n  }\n\n}\n\nObject.defineProperty(Topology.prototype, 'clusterTime', {\n  enumerable: true,\n  get: function () {\n    return this.s.clusterTime;\n  },\n  set: function (clusterTime) {\n    this.s.clusterTime = clusterTime;\n  }\n}); // legacy aliases\n\nTopology.prototype.destroy = deprecate(Topology.prototype.close, 'destroy() is deprecated, please use close() instead');\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\n\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n/**\r\n * Destroys a server, and removes all event listeners from the instance\r\n *\r\n * @param {Server} server\r\n */\n\n\nfunction destroyServer(server, topology, callback) {\n  LOCAL_SERVER_EVENTS.forEach(event => server.removeAllListeners(event));\n  server.destroy(() => {\n    topology.emit('serverClosed', new monitoring.ServerClosedEvent(topology.s.id, server.description.address));\n    if (typeof callback === 'function') callback(null, null);\n  });\n}\n/**\r\n * Parses a basic seedlist in string form\r\n *\r\n * @param {string} seedlist The seedlist to parse\r\n */\n\n\nfunction parseStringSeedlist(seedlist) {\n  return seedlist.split(',').map(seed => ({\n    host: seed.split(':')[0],\n    port: seed.split(':')[1] || 27017\n  }));\n}\n\nfunction topologyTypeFromSeedlist(seedlist, options) {\n  const replicaSet = options.replicaSet || options.setName || options.rs_name;\n  if (seedlist.length === 1 && !replicaSet) return TopologyType.Single;\n  if (replicaSet) return TopologyType.ReplicaSetNoPrimary;\n  return TopologyType.Unknown;\n}\n\nfunction randomSelection(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}\n/**\r\n * Selects servers using the provided selector\r\n *\r\n * @private\r\n * @param {Topology} topology The topology to select servers from\r\n * @param {function} selector The actual predicate used for selecting servers\r\n * @param {Number} timeout The max time we are willing wait for selection\r\n * @param {Number} start A high precision timestamp for the start of the selection process\r\n * @param {function} callback The callback used to convey errors or the resultant servers\r\n */\n\n\nfunction selectServers(topology, selector, timeout, start, callback) {\n  const duration = calculateDurationInMs(start);\n\n  if (duration >= timeout) {\n    return callback(new MongoTimeoutError(`Server selection timed out after ${timeout} ms`));\n  } // ensure we are connected\n\n\n  if (!topology.s.connected) {\n    topology.connect(); // we want to make sure we're still within the requested timeout window\n\n    const failToConnectTimer = setTimeout(() => {\n      topology.removeListener('connect', connectHandler);\n      callback(new MongoTimeoutError('Server selection timed out waiting to connect'));\n    }, timeout - duration);\n\n    const connectHandler = () => {\n      clearTimeout(failToConnectTimer);\n      selectServers(topology, selector, timeout, process.hrtime(), callback);\n    };\n\n    topology.once('connect', connectHandler);\n    return;\n  } // otherwise, attempt server selection\n\n\n  const serverDescriptions = Array.from(topology.description.servers.values());\n  let descriptions; // support server selection by options with readPreference\n\n  if (typeof selector === 'object') {\n    const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;\n    selector = readPreferenceServerSelector(readPreference);\n  }\n\n  try {\n    descriptions = selector ? selector(topology.description, serverDescriptions) : serverDescriptions;\n  } catch (e) {\n    return callback(e, null);\n  }\n\n  if (descriptions.length) {\n    const servers = descriptions.map(description => topology.s.servers.get(description.address));\n    return callback(null, servers);\n  }\n\n  const retrySelection = () => {\n    // clear all existing monitor timers\n    topology.s.monitorTimers.map(timer => clearTimeout(timer));\n    topology.s.monitorTimers = []; // ensure all server monitors attempt monitoring soon\n\n    topology.s.servers.forEach(server => {\n      const timer = setTimeout(() => server.monitor({\n        heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS\n      }), TOPOLOGY_DEFAULTS.minHeartbeatFrequencyMS);\n      topology.s.monitorTimers.push(timer);\n    });\n\n    const descriptionChangedHandler = () => {\n      // successful iteration, clear the check timer\n      clearTimeout(iterationTimer);\n      topology.s.iterationTimers.splice(timerIndex, 1);\n\n      if (topology.description.error) {\n        callback(topology.description.error, null);\n        return;\n      } // topology description has changed due to monitoring, reattempt server selection\n\n\n      selectServers(topology, selector, timeout, start, callback);\n    };\n\n    const iterationTimer = setTimeout(() => {\n      topology.removeListener('topologyDescriptionChanged', descriptionChangedHandler);\n      callback(new MongoTimeoutError(`Server selection timed out after ${timeout} ms`));\n    }, timeout - duration); // track this timer in case we need to clean it up outside this loop\n\n    const timerIndex = topology.s.iterationTimers.push(iterationTimer);\n    topology.once('topologyDescriptionChanged', descriptionChangedHandler);\n  };\n\n  retrySelection();\n}\n\nfunction createAndConnectServer(topology, serverDescription) {\n  topology.emit('serverOpening', new monitoring.ServerOpeningEvent(topology.s.id, serverDescription.address));\n  const server = new Server(serverDescription, topology.s.options, topology);\n  relayEvents(server, topology, SERVER_RELAY_EVENTS);\n  server.once('connect', serverConnectEventHandler(server, topology));\n  server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));\n  server.on('error', serverErrorEventHandler(server, topology));\n  server.on('close', () => topology.emit('close', server));\n  server.connect();\n  return server;\n}\n/**\r\n * Create `Server` instances for all initially known servers, connect them, and assign\r\n * them to the passed in `Topology`.\r\n *\r\n * @param {Topology} topology The topology responsible for the servers\r\n * @param {ServerDescription[]} serverDescriptions A list of server descriptions to connect\r\n */\n\n\nfunction connectServers(topology, serverDescriptions) {\n  topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {\n    const server = createAndConnectServer(topology, serverDescription);\n    servers.set(serverDescription.address, server);\n    return servers;\n  }, new Map());\n}\n\nfunction updateServers(topology, incomingServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    const server = topology.s.servers.get(incomingServerDescription.address);\n    server.s.description = incomingServerDescription;\n  } // add new servers for all descriptions we currently don't know about locally\n\n\n  for (const serverDescription of topology.description.servers.values()) {\n    if (!topology.s.servers.has(serverDescription.address)) {\n      const server = createAndConnectServer(topology, serverDescription);\n      topology.s.servers.set(serverDescription.address, server);\n    }\n  } // for all servers no longer known, remove their descriptions and destroy their instances\n\n\n  for (const entry of topology.s.servers) {\n    const serverAddress = entry[0];\n\n    if (topology.description.hasServer(serverAddress)) {\n      continue;\n    }\n\n    const server = topology.s.servers.get(serverAddress);\n    topology.s.servers.delete(serverAddress); // prepare server for garbage collection\n\n    destroyServer(server, topology);\n  }\n}\n\nfunction serverConnectEventHandler(server, topology) {\n  return function ()\n  /* isMaster, err */\n  {\n    server.monitor({\n      initial: true,\n      heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS\n    });\n  };\n}\n\nfunction serverErrorEventHandler(server, topology) {\n  return function (err) {\n    topology.emit('serverClosed', new monitoring.ServerClosedEvent(topology.s.id, server.description.address));\n\n    if (isSDAMUnrecoverableError(err, server)) {\n      resetServerState(server, err, {\n        clearPool: true\n      });\n      return;\n    }\n\n    resetServerState(server, err);\n  };\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  const topology = args.topology;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n  const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(topology) && !options.session.inTransaction();\n  topology.selectServer(writableServerSelector(), options, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const handler = (err, result) => {\n      if (!err) return callback(null, result);\n\n      if (!isRetryableError(err)) {\n        err = getMMAPError(err);\n        return callback(err);\n      }\n\n      if (willRetryWrite) {\n        const newArgs = Object.assign({}, args, {\n          retrying: true\n        });\n        return executeWriteOperation(newArgs, options, callback);\n      }\n\n      return callback(err);\n    };\n\n    if (callback.operationId) {\n      handler.operationId = callback.operationId;\n    } // increment and assign txnNumber\n\n\n    if (willRetryWrite) {\n      options.session.incrementTransactionNumber();\n      options.willRetryWrite = willRetryWrite;\n    } // execute the write operation\n\n\n    server[op](ns, ops, options, handler);\n  });\n}\n/**\r\n * Resets the internal state of this server to `Unknown` by simulating an empty ismaster\r\n *\r\n * @private\r\n * @param {Server} server\r\n * @param {MongoError} error The error that caused the state reset\r\n * @param {object} [options] Optional settings\r\n * @param {boolean} [options.clearPool=false] Pool should be cleared out on state reset\r\n */\n\n\nfunction resetServerState(server, error, options) {\n  options = Object.assign({}, {\n    clearPool: false\n  }, options);\n\n  function resetState() {\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n      error\n    }));\n    server.monitor();\n  }\n\n  if (options.clearPool && server.s.pool) {\n    server.s.pool.reset(() => resetState());\n    return;\n  }\n\n  resetState();\n}\n\nfunction translateReadPreference(options) {\n  if (options.readPreference == null) {\n    return;\n  }\n\n  let r = options.readPreference;\n\n  if (typeof r === 'string') {\n    options.readPreference = new ReadPreference(r);\n  } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\n    const mode = r.mode || r.preference;\n\n    if (mode && typeof mode === 'string') {\n      options.readPreference = new ReadPreference(mode, r.tags, {\n        maxStalenessSeconds: r.maxStalenessSeconds\n      });\n    }\n  } else if (!(r instanceof ReadPreference)) {\n    throw new TypeError('Invalid read preference: ' + r);\n  }\n\n  return options;\n}\n\nfunction srvPollingHandler(topology) {\n  return function handleSrvPolling(ev) {\n    const previousTopologyDescription = topology.s.description;\n    topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);\n\n    if (topology.s.description === previousTopologyDescription) {\n      // Nothing changed, so return\n      return;\n    }\n\n    updateServers(topology);\n    topology.emit('topologyDescriptionChanged', new monitoring.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));\n  };\n}\n/**\r\n * A server opening SDAM monitoring event\r\n *\r\n * @event Topology#serverOpening\r\n * @type {ServerOpeningEvent}\r\n */\n\n/**\r\n * A server closed SDAM monitoring event\r\n *\r\n * @event Topology#serverClosed\r\n * @type {ServerClosedEvent}\r\n */\n\n/**\r\n * A server description SDAM change monitoring event\r\n *\r\n * @event Topology#serverDescriptionChanged\r\n * @type {ServerDescriptionChangedEvent}\r\n */\n\n/**\r\n * A topology open SDAM event\r\n *\r\n * @event Topology#topologyOpening\r\n * @type {TopologyOpeningEvent}\r\n */\n\n/**\r\n * A topology closed SDAM event\r\n *\r\n * @event Topology#topologyClosed\r\n * @type {TopologyClosedEvent}\r\n */\n\n/**\r\n * A topology structure SDAM change event\r\n *\r\n * @event Topology#topologyDescriptionChanged\r\n * @type {TopologyDescriptionChangedEvent}\r\n */\n\n/**\r\n * A topology serverHeartbeatStarted SDAM event\r\n *\r\n * @event Topology#serverHeartbeatStarted\r\n * @type {ServerHeartbeatStartedEvent}\r\n */\n\n/**\r\n * A topology serverHeartbeatFailed SDAM event\r\n *\r\n * @event Topology#serverHeartbeatFailed\r\n * @type {ServerHearbeatFailedEvent}\r\n */\n\n/**\r\n * A topology serverHeartbeatSucceeded SDAM change event\r\n *\r\n * @event Topology#serverHeartbeatSucceeded\r\n * @type {ServerHeartbeatSucceededEvent}\r\n */\n\n/**\r\n * An event emitted indicating a command was started, if command monitoring is enabled\r\n *\r\n * @event Topology#commandStarted\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command succeeded, if command monitoring is enabled\r\n *\r\n * @event Topology#commandSucceeded\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command failed, if command monitoring is enabled\r\n *\r\n * @event Topology#commandFailed\r\n * @type {object}\r\n */\n\n\nmodule.exports = Topology;","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/sdam/topology.js"],"names":["EventEmitter","require","ServerDescription","ServerType","TopologyDescription","TopologyType","monitoring","calculateDurationInMs","MongoTimeoutError","Server","relayEvents","ReadPreference","readPreferenceServerSelector","writableServerSelector","isRetryableWritesSupported","CoreCursor","deprecate","BSON","retrieveBSON","createCompressionInfo","isRetryableError","isSDAMUnrecoverableError","ClientSession","createClientInfo","MongoError","resolveClusterTime","SrvPoller","getMMAPError","globalTopologyCounter","TOPOLOGY_DEFAULTS","localThresholdMS","serverSelectionTimeoutMS","heartbeatFrequencyMS","minHeartbeatFrequencyMS","SERVER_RELAY_EVENTS","LOCAL_SERVER_EVENTS","concat","Topology","constructor","seedlist","options","host","push","port","parseStringSeedlist","Object","assign","topologyType","topologyTypeFromSeedlist","topologyId","serverDescriptions","reduce","result","seed","domain_socket","address","set","Map","s","id","description","replicaSet","minHeartbeatIntervalMS","Cursor","cursorFactory","bson","servers","sessionPool","sessions","Set","promiseLibrary","Promise","credentials","clusterTime","monitorTimers","iterationTimers","compression","compressors","clientInfo","srvHost","srvPoller","logger","loggerLevel","detectTopologyDescriptionChange","ev","previousType","previousDescription","type","newType","newDescription","Sharded","handleSrvPolling","srvPollingHandler","on","start","parserType","native","connections","Array","from","values","server","pool","allConnections","connect","callback","emit","TopologyOpeningEvent","TopologyDescriptionChangedEvent","Unknown","connectServers","connected","translateReadPreference","readPreference","primary","selectServer","err","errorHandler","removeListener","connectHandler","_","STATE_CONNECTING","state","once","close","map","timer","clearTimeout","forEach","session","endSession","endAllPooledSessions","stop","size","destroyed","destroyServer","TopologyClosedEvent","selector","isSharded","transaction","selectServers","process","hrtime","selectedServer","randomSelection","isActive","pinServer","shouldCheckForSessionSupport","Single","hasKnownServers","hasDataBearingServers","hasSessionSupport","logicalSessionTimeoutMinutes","startSession","clientOptions","delete","add","endSessions","isArray","command","primaryPreferred","noResponse","serverUpdateHandler","serverDescription","hasServer","previousTopologyDescription","previousServerDescription","get","update","compatibilityError","ServerDescriptionChangedEvent","updateServers","$clusterTime","auth","logout","insert","ns","ops","executeWriteOperation","topology","op","remove","cmd","willRetryWrite","retrying","retryWrites","inTransaction","isWriteCommand","cb","newOptions","incrementTransactionNumber","cursor","CursorClass","isConnected","isDestroyed","unref","console","log","lastIsMaster","length","sd","filter","maxWireVersion","commonWireVersion","defineProperty","prototype","enumerable","destroy","RETRYABLE_WRITE_OPERATIONS","some","event","removeAllListeners","ServerClosedEvent","split","setName","rs_name","ReplicaSetNoPrimary","array","Math","floor","random","timeout","duration","failToConnectTimer","setTimeout","descriptions","e","retrySelection","monitor","descriptionChangedHandler","iterationTimer","splice","timerIndex","error","createAndConnectServer","ServerOpeningEvent","serverConnectEventHandler","bind","serverErrorEventHandler","incomingServerDescription","has","entry","serverAddress","initial","resetServerState","clearPool","args","handler","newArgs","operationId","resetState","reset","r","mode","preference","tags","maxStalenessSeconds","TypeError","updateFromSrvPollingEvent","module","exports"],"mappings":"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AACD;;AAEDM,IAAAA,aAAa,CAACQ,QAAD,CAAb;AAEAA,IAAAA,QAAQ,CAACzE,IAAT,CACE,4BADF,EAEE,IAAIpG,UAAU,CAACsG,+BAAf,CACEuE,QAAQ,CAACzH,CAAT,CAAWC,EADb,EAEE0G,2BAFF,EAGEc,QAAQ,CAACzH,CAAT,CAAWE,WAHb,CAFF;AAQD,GAlBD;AAmBD;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEAuM,MAAM,CAACC,OAAP,GAAiB/N,QAAjB","sourcesContent":["'use strict';\r\nconst EventEmitter = require('events');\r\nconst ServerDescription = require('./server_description').ServerDescription;\r\nconst ServerType = require('./server_description').ServerType;\r\nconst TopologyDescription = require('./topology_description').TopologyDescription;\r\nconst TopologyType = require('./topology_description').TopologyType;\r\nconst monitoring = require('./monitoring');\r\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\r\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\r\nconst Server = require('./server');\r\nconst relayEvents = require('../utils').relayEvents;\r\nconst ReadPreference = require('../topologies/read_preference');\r\nconst readPreferenceServerSelector = require('./server_selectors').readPreferenceServerSelector;\r\nconst writableServerSelector = require('./server_selectors').writableServerSelector;\r\nconst isRetryableWritesSupported = require('../topologies/shared').isRetryableWritesSupported;\r\nconst CoreCursor = require('../cursor').CoreCursor;\r\nconst deprecate = require('util').deprecate;\r\nconst BSON = require('../connection/utils').retrieveBSON();\r\nconst createCompressionInfo = require('../topologies/shared').createCompressionInfo;\r\nconst isRetryableError = require('../error').isRetryableError;\r\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\r\nconst ClientSession = require('../sessions').ClientSession;\r\nconst createClientInfo = require('../topologies/shared').createClientInfo;\r\nconst MongoError = require('../error').MongoError;\r\nconst resolveClusterTime = require('../topologies/shared').resolveClusterTime;\r\nconst SrvPoller = require('./srv_polling').SrvPoller;\r\nconst getMMAPError = require('../topologies/shared').getMMAPError;\r\n\r\n// Global state\r\nlet globalTopologyCounter = 0;\r\n\r\n// Constants\r\nconst TOPOLOGY_DEFAULTS = {\r\n  localThresholdMS: 15,\r\n  serverSelectionTimeoutMS: 30000,\r\n  heartbeatFrequencyMS: 10000,\r\n  minHeartbeatFrequencyMS: 500\r\n};\r\n\r\n// events that we relay to the `Topology`\r\nconst SERVER_RELAY_EVENTS = [\r\n  'serverHeartbeatStarted',\r\n  'serverHeartbeatSucceeded',\r\n  'serverHeartbeatFailed',\r\n  'commandStarted',\r\n  'commandSucceeded',\r\n  'commandFailed',\r\n\r\n  // NOTE: Legacy events\r\n  'monitoring'\r\n];\r\n\r\n// all events we listen to from `Server` instances\r\nconst LOCAL_SERVER_EVENTS = SERVER_RELAY_EVENTS.concat([\r\n  'error',\r\n  'connect',\r\n  'descriptionReceived',\r\n  'close',\r\n  'ended'\r\n]);\r\n\r\n/**\r\n * A container of server instances representing a connection to a MongoDB topology.\r\n *\r\n * @fires Topology#serverOpening\r\n * @fires Topology#serverClosed\r\n * @fires Topology#serverDescriptionChanged\r\n * @fires Topology#topologyOpening\r\n * @fires Topology#topologyClosed\r\n * @fires Topology#topologyDescriptionChanged\r\n * @fires Topology#serverHeartbeatStarted\r\n * @fires Topology#serverHeartbeatSucceeded\r\n * @fires Topology#serverHeartbeatFailed\r\n */\r\nclass Topology extends EventEmitter {\r\n  /**\r\n   * Create a topology\r\n   *\r\n   * @param {Array|String} [seedlist] a string list, or array of Server instances to connect to\r\n   * @param {Object} [options] Optional settings\r\n   * @param {Number} [options.localThresholdMS=15] The size of the latency window for selecting among multiple suitable servers\r\n   * @param {Number} [options.serverSelectionTimeoutMS=30000] How long to block for server selection before throwing an error\r\n   * @param {Number} [options.heartbeatFrequencyMS=10000] The frequency with which topology updates are scheduled\r\n   */\r\n  constructor(seedlist, options) {\r\n    super();\r\n    if (typeof options === 'undefined' && typeof seedlist !== 'string') {\r\n      options = seedlist;\r\n      seedlist = [];\r\n\r\n      // this is for legacy single server constructor support\r\n      if (options.host) {\r\n        seedlist.push({ host: options.host, port: options.port });\r\n      }\r\n    }\r\n\r\n    seedlist = seedlist || [];\r\n    if (typeof seedlist === 'string') {\r\n      seedlist = parseStringSeedlist(seedlist);\r\n    }\r\n\r\n    options = Object.assign({}, TOPOLOGY_DEFAULTS, options);\r\n\r\n    const topologyType = topologyTypeFromSeedlist(seedlist, options);\r\n    const topologyId = globalTopologyCounter++;\r\n    const serverDescriptions = seedlist.reduce((result, seed) => {\r\n      if (seed.domain_socket) seed.host = seed.domain_socket;\r\n      const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;\r\n      result.set(address, new ServerDescription(address));\r\n      return result;\r\n    }, new Map());\r\n\r\n    this.s = {\r\n      // the id of this topology\r\n      id: topologyId,\r\n      // passed in options\r\n      options,\r\n      // initial seedlist of servers to connect to\r\n      seedlist: seedlist,\r\n      // the topology description\r\n      description: new TopologyDescription(\r\n        topologyType,\r\n        serverDescriptions,\r\n        options.replicaSet,\r\n        null,\r\n        null,\r\n        null,\r\n        options\r\n      ),\r\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\r\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\r\n      minHeartbeatIntervalMS: options.minHeartbeatIntervalMS,\r\n      // allow users to override the cursor factory\r\n      Cursor: options.cursorFactory || CoreCursor,\r\n      // the bson parser\r\n      bson: options.bson || new BSON(),\r\n      // a map of server instances to normalized addresses\r\n      servers: new Map(),\r\n      // Server Session Pool\r\n      sessionPool: null,\r\n      // Active client sessions\r\n      sessions: new Set(),\r\n      // Promise library\r\n      promiseLibrary: options.promiseLibrary || Promise,\r\n      credentials: options.credentials,\r\n      clusterTime: null,\r\n\r\n      // timer management\r\n      monitorTimers: [],\r\n      iterationTimers: []\r\n    };\r\n\r\n    // amend options for server instance creation\r\n    this.s.options.compression = { compressors: createCompressionInfo(options) };\r\n\r\n    // add client info\r\n    this.s.clientInfo = createClientInfo(options);\r\n\r\n    if (options.srvHost) {\r\n      this.s.srvPoller =\r\n        options.srvPoller ||\r\n        new SrvPoller({\r\n          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,\r\n          srvHost: options.srvHost, // TODO: GET THIS\r\n          logger: options.logger,\r\n          loggerLevel: options.loggerLevel\r\n        });\r\n      this.s.detectTopologyDescriptionChange = ev => {\r\n        const previousType = ev.previousDescription.type;\r\n        const newType = ev.newDescription.type;\r\n\r\n        if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {\r\n          this.s.handleSrvPolling = srvPollingHandler(this);\r\n          this.s.srvPoller.on('srvRecordDiscovery', this.s.handleSrvPolling);\r\n          this.s.srvPoller.start();\r\n        }\r\n      };\r\n\r\n      this.on('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return A `TopologyDescription` for this topology\r\n   */\r\n  get description() {\r\n    return this.s.description;\r\n  }\r\n\r\n  get parserType() {\r\n    return BSON.native ? 'c++' : 'js';\r\n  }\r\n\r\n  /**\r\n   * All raw connections\r\n   * @method\r\n   * @return {Connection[]}\r\n   */\r\n  connections() {\r\n    return Array.from(this.s.servers.values()).reduce((result, server) => {\r\n      return result.concat(server.s.pool.allConnections());\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Initiate server connect\r\n   *\r\n   * @param {Object} [options] Optional settings\r\n   * @param {Array} [options.auth=null] Array of auth options to apply on connect\r\n   * @param {function} [callback] An optional callback called once on the first connected server\r\n   */\r\n  connect(options, callback) {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = options || {};\r\n\r\n    // emit SDAM monitoring events\r\n    this.emit('topologyOpening', new monitoring.TopologyOpeningEvent(this.s.id));\r\n\r\n    // emit an event for the topology change\r\n    this.emit(\r\n      'topologyDescriptionChanged',\r\n      new monitoring.TopologyDescriptionChangedEvent(\r\n        this.s.id,\r\n        new TopologyDescription(TopologyType.Unknown), // initial is always Unknown\r\n        this.s.description\r\n      )\r\n    );\r\n\r\n    connectServers(this, Array.from(this.s.description.servers.values()));\r\n    this.s.connected = true;\r\n\r\n    // otherwise, wait for a server to properly connect based on user provided read preference,\r\n    // or primary.\r\n\r\n    translateReadPreference(options);\r\n    const readPreference = options.readPreference || ReadPreference.primary;\r\n\r\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\r\n      if (err) {\r\n        if (typeof callback === 'function') {\r\n          callback(err, null);\r\n        } else {\r\n          this.emit('error', err);\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      const errorHandler = err => {\r\n        server.removeListener('connect', connectHandler);\r\n        if (typeof callback === 'function') callback(err, null);\r\n      };\r\n\r\n      const connectHandler = (_, err) => {\r\n        server.removeListener('error', errorHandler);\r\n        this.emit('open', err, this);\r\n        this.emit('connect', this);\r\n\r\n        if (typeof callback === 'function') callback(err, this);\r\n      };\r\n\r\n      const STATE_CONNECTING = 1;\r\n      if (server.s.state === STATE_CONNECTING) {\r\n        server.once('error', errorHandler);\r\n        server.once('connect', connectHandler);\r\n        return;\r\n      }\r\n\r\n      connectHandler();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Close this topology\r\n   */\r\n  close(options, callback) {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = options || {};\r\n\r\n    // clear all existing monitor timers\r\n    this.s.monitorTimers.map(timer => clearTimeout(timer));\r\n    this.s.monitorTimers = [];\r\n\r\n    this.s.iterationTimers.map(timer => clearTimeout(timer));\r\n    this.s.iterationTimers = [];\r\n\r\n    if (this.s.sessionPool) {\r\n      this.s.sessions.forEach(session => session.endSession());\r\n      this.s.sessionPool.endAllPooledSessions();\r\n    }\r\n\r\n    if (this.s.srvPoller) {\r\n      this.s.srvPoller.stop();\r\n      if (this.s.handleSrvPolling) {\r\n        this.s.srvPoller.removeListener('srvRecordDiscovery', this.s.handleSrvPolling);\r\n        delete this.s.handleSrvPolling;\r\n      }\r\n    }\r\n\r\n    if (this.s.detectTopologyDescriptionChange) {\r\n      this.removeListener('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\r\n      delete this.s.detectTopologyDescriptionChange;\r\n    }\r\n\r\n    const servers = this.s.servers;\r\n    if (servers.size === 0) {\r\n      this.s.connected = false;\r\n      if (typeof callback === 'function') {\r\n        callback(null, null);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // destroy all child servers\r\n    let destroyed = 0;\r\n    servers.forEach(server =>\r\n      destroyServer(server, this, () => {\r\n        destroyed++;\r\n        if (destroyed === servers.size) {\r\n          // emit an event for close\r\n          this.emit('topologyClosed', new monitoring.TopologyClosedEvent(this.s.id));\r\n\r\n          this.s.connected = false;\r\n          if (typeof callback === 'function') {\r\n            callback(null, null);\r\n          }\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Selects a server according to the selection predicate provided\r\n   *\r\n   * @param {function} [selector] An optional selector to select servers by, defaults to a random selection within a latency window\r\n   * @param {object} [options] Optional settings related to server selection\r\n   * @param {number} [options.serverSelectionTimeoutMS] How long to block for server selection before throwing an error\r\n   * @param {function} callback The callback used to indicate success or failure\r\n   * @return {Server} An instance of a `Server` meeting the criteria of the predicate provided\r\n   */\r\n  selectServer(selector, options, callback) {\r\n    if (typeof options === 'function') {\r\n      callback = options;\r\n      if (typeof selector !== 'function') {\r\n        options = selector;\r\n\r\n        let readPreference;\r\n        if (selector instanceof ReadPreference) {\r\n          readPreference = selector;\r\n        } else {\r\n          translateReadPreference(options);\r\n          readPreference = options.readPreference || ReadPreference.primary;\r\n        }\r\n\r\n        selector = readPreferenceServerSelector(readPreference);\r\n      } else {\r\n        options = {};\r\n      }\r\n    }\r\n\r\n    options = Object.assign(\r\n      {},\r\n      { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS },\r\n      options\r\n    );\r\n\r\n    const isSharded = this.description.type === TopologyType.Sharded;\r\n    const session = options.session;\r\n    const transaction = session && session.transaction;\r\n\r\n    if (isSharded && transaction && transaction.server) {\r\n      callback(null, transaction.server);\r\n      return;\r\n    }\r\n\r\n    // clear out any existing iteration timers\r\n    this.s.iterationTimers.map(timer => clearTimeout(timer));\r\n    this.s.iterationTimers = [];\r\n\r\n    selectServers(\r\n      this,\r\n      selector,\r\n      options.serverSelectionTimeoutMS,\r\n      process.hrtime(),\r\n      (err, servers) => {\r\n        if (err) return callback(err, null);\r\n\r\n        const selectedServer = randomSelection(servers);\r\n        if (isSharded && transaction && transaction.isActive) {\r\n          transaction.pinServer(selectedServer);\r\n        }\r\n\r\n        callback(null, selectedServer);\r\n      }\r\n    );\r\n  }\r\n\r\n  // Sessions related methods\r\n\r\n  /**\r\n   * @return Whether the topology should initiate selection to determine session support\r\n   */\r\n  shouldCheckForSessionSupport() {\r\n    return (\r\n      (this.description.type === TopologyType.Single && !this.description.hasKnownServers) ||\r\n      !this.description.hasDataBearingServers\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return Whether sessions are supported on the current topology\r\n   */\r\n  hasSessionSupport() {\r\n    return this.description.logicalSessionTimeoutMinutes != null;\r\n  }\r\n\r\n  /**\r\n   * Start a logical session\r\n   */\r\n  startSession(options, clientOptions) {\r\n    const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);\r\n    session.once('ended', () => {\r\n      this.s.sessions.delete(session);\r\n    });\r\n\r\n    this.s.sessions.add(session);\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Send endSessions command(s) with the given session ids\r\n   *\r\n   * @param {Array} sessions The sessions to end\r\n   * @param {function} [callback]\r\n   */\r\n  endSessions(sessions, callback) {\r\n    if (!Array.isArray(sessions)) {\r\n      sessions = [sessions];\r\n    }\r\n\r\n    this.command(\r\n      'admin.$cmd',\r\n      { endSessions: sessions },\r\n      { readPreference: ReadPreference.primaryPreferred, noResponse: true },\r\n      () => {\r\n        // intentionally ignored, per spec\r\n        if (typeof callback === 'function') callback();\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update the internal TopologyDescription with a ServerDescription\r\n   *\r\n   * @param {object} serverDescription The server to update in the internal list of server descriptions\r\n   */\r\n  serverUpdateHandler(serverDescription) {\r\n    if (!this.s.description.hasServer(serverDescription.address)) {\r\n      return;\r\n    }\r\n\r\n    // these will be used for monitoring events later\r\n    const previousTopologyDescription = this.s.description;\r\n    const previousServerDescription = this.s.description.servers.get(serverDescription.address);\r\n\r\n    // first update the TopologyDescription\r\n    this.s.description = this.s.description.update(serverDescription);\r\n    if (this.s.description.compatibilityError) {\r\n      this.emit('error', new MongoError(this.s.description.compatibilityError));\r\n      return;\r\n    }\r\n\r\n    // emit monitoring events for this change\r\n    this.emit(\r\n      'serverDescriptionChanged',\r\n      new monitoring.ServerDescriptionChangedEvent(\r\n        this.s.id,\r\n        serverDescription.address,\r\n        previousServerDescription,\r\n        this.s.description.servers.get(serverDescription.address)\r\n      )\r\n    );\r\n\r\n    // update server list from updated descriptions\r\n    updateServers(this, serverDescription);\r\n\r\n    // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\r\n    // a server it MUST compare it to the current highest seen cluster time\r\n    // for the deployment. If the new cluster time is higher than the\r\n    // highest seen cluster time it MUST become the new highest seen cluster\r\n    // time. Two cluster times are compared using only the BsonTimestamp\r\n    // value of the clusterTime embedded field.\"\r\n    const clusterTime = serverDescription.$clusterTime;\r\n    if (clusterTime) {\r\n      resolveClusterTime(this, clusterTime);\r\n    }\r\n\r\n    this.emit(\r\n      'topologyDescriptionChanged',\r\n      new monitoring.TopologyDescriptionChangedEvent(\r\n        this.s.id,\r\n        previousTopologyDescription,\r\n        this.s.description\r\n      )\r\n    );\r\n  }\r\n\r\n  auth(credentials, callback) {\r\n    if (typeof credentials === 'function') (callback = credentials), (credentials = null);\r\n    if (typeof callback === 'function') callback(null, true);\r\n  }\r\n\r\n  logout(callback) {\r\n    if (typeof callback === 'function') callback(null, true);\r\n  }\r\n\r\n  // Basic operation support. Eventually this should be moved into command construction\r\n  // during the command refactor.\r\n\r\n  /**\r\n   * Insert one or more documents\r\n   *\r\n   * @param {String} ns The full qualified namespace for this operation\r\n   * @param {Array} ops An array of documents to insert\r\n   * @param {Boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {Object} [options.writeConcern] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\r\n   * @param {ClientSession} [options.session] Session to use for the operation\r\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  insert(ns, ops, options, callback) {\r\n    executeWriteOperation({ topology: this, op: 'insert', ns, ops }, options, callback);\r\n  }\r\n\r\n  /**\r\n   * Perform one or more update operations\r\n   *\r\n   * @param {string} ns The fully qualified namespace for this operation\r\n   * @param {array} ops An array of updates\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\r\n   * @param {ClientSession} [options.session] Session to use for the operation\r\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  update(ns, ops, options, callback) {\r\n    executeWriteOperation({ topology: this, op: 'update', ns, ops }, options, callback);\r\n  }\r\n\r\n  /**\r\n   * Perform one or more remove operations\r\n   *\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {array} ops An array of removes\r\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\r\n   * @param {object} [options.writeConcern={}] Write concern for the operation\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  remove(ns, ops, options, callback) {\r\n    executeWriteOperation({ topology: this, op: 'remove', ns, ops }, options, callback);\r\n  }\r\n\r\n  /**\r\n   * Execute a command\r\n   *\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object} cmd The command hash\r\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n   * @param {Connection} [options.connection] Specify connection object to execute command against\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {opResultCallback} callback A callback function\r\n   */\r\n  command(ns, cmd, options, callback) {\r\n    if (typeof options === 'function') {\r\n      (callback = options), (options = {}), (options = options || {});\r\n    }\r\n\r\n    translateReadPreference(options);\r\n    const readPreference = options.readPreference || ReadPreference.primary;\r\n\r\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\r\n      if (err) {\r\n        callback(err, null);\r\n        return;\r\n      }\r\n\r\n      const willRetryWrite =\r\n        !options.retrying &&\r\n        !!options.retryWrites &&\r\n        options.session &&\r\n        isRetryableWritesSupported(this) &&\r\n        !options.session.inTransaction() &&\r\n        isWriteCommand(cmd);\r\n\r\n      const cb = (err, result) => {\r\n        if (!err) return callback(null, result);\r\n        if (!isRetryableError(err)) {\r\n          return callback(err);\r\n        }\r\n\r\n        if (willRetryWrite) {\r\n          const newOptions = Object.assign({}, options, { retrying: true });\r\n          return this.command(ns, cmd, newOptions, callback);\r\n        }\r\n\r\n        return callback(err);\r\n      };\r\n\r\n      // increment and assign txnNumber\r\n      if (willRetryWrite) {\r\n        options.session.incrementTransactionNumber();\r\n        options.willRetryWrite = willRetryWrite;\r\n      }\r\n\r\n      server.command(ns, cmd, options, cb);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a new cursor\r\n   *\r\n   * @method\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\r\n   * @param {object} [options] Options for the cursor\r\n   * @param {object} [options.batchSize=0] Batchsize for the operation\r\n   * @param {array} [options.documents=[]] Initial documents list for cursor\r\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\r\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\r\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\r\n   * @param {ClientSession} [options.session=null] Session to use for the operation\r\n   * @param {object} [options.topology] The internal topology of the created cursor\r\n   * @returns {Cursor}\r\n   */\r\n  cursor(ns, cmd, options) {\r\n    options = options || {};\r\n    const topology = options.topology || this;\r\n    const CursorClass = options.cursorFactory || this.s.Cursor;\r\n    translateReadPreference(options);\r\n\r\n    return new CursorClass(topology, ns, cmd, options);\r\n  }\r\n\r\n  get clientInfo() {\r\n    return this.s.clientInfo;\r\n  }\r\n\r\n  // Legacy methods for compat with old topology types\r\n  isConnected() {\r\n    // console.log('not implemented: `isConnected`');\r\n    return true;\r\n  }\r\n\r\n  isDestroyed() {\r\n    // console.log('not implemented: `isDestroyed`');\r\n    return false;\r\n  }\r\n\r\n  unref() {\r\n    console.log('not implemented: `unref`');\r\n  }\r\n\r\n  // NOTE: There are many places in code where we explicitly check the last isMaster\r\n  //       to do feature support detection. This should be done any other way, but for\r\n  //       now we will just return the first isMaster seen, which should suffice.\r\n  lastIsMaster() {\r\n    const serverDescriptions = Array.from(this.description.servers.values());\r\n    if (serverDescriptions.length === 0) return {};\r\n\r\n    const sd = serverDescriptions.filter(sd => sd.type !== ServerType.Unknown)[0];\r\n    const result = sd || { maxWireVersion: this.description.commonWireVersion };\r\n    return result;\r\n  }\r\n\r\n  get logicalSessionTimeoutMinutes() {\r\n    return this.description.logicalSessionTimeoutMinutes;\r\n  }\r\n\r\n  get bson() {\r\n    return this.s.bson;\r\n  }\r\n}\r\n\r\nObject.defineProperty(Topology.prototype, 'clusterTime', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.s.clusterTime;\r\n  },\r\n  set: function(clusterTime) {\r\n    this.s.clusterTime = clusterTime;\r\n  }\r\n});\r\n\r\n// legacy aliases\r\nTopology.prototype.destroy = deprecate(\r\n  Topology.prototype.close,\r\n  'destroy() is deprecated, please use close() instead'\r\n);\r\n\r\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\r\nfunction isWriteCommand(command) {\r\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\r\n}\r\n\r\n/**\r\n * Destroys a server, and removes all event listeners from the instance\r\n *\r\n * @param {Server} server\r\n */\r\nfunction destroyServer(server, topology, callback) {\r\n  LOCAL_SERVER_EVENTS.forEach(event => server.removeAllListeners(event));\r\n\r\n  server.destroy(() => {\r\n    topology.emit(\r\n      'serverClosed',\r\n      new monitoring.ServerClosedEvent(topology.s.id, server.description.address)\r\n    );\r\n\r\n    if (typeof callback === 'function') callback(null, null);\r\n  });\r\n}\r\n\r\n/**\r\n * Parses a basic seedlist in string form\r\n *\r\n * @param {string} seedlist The seedlist to parse\r\n */\r\nfunction parseStringSeedlist(seedlist) {\r\n  return seedlist.split(',').map(seed => ({\r\n    host: seed.split(':')[0],\r\n    port: seed.split(':')[1] || 27017\r\n  }));\r\n}\r\n\r\nfunction topologyTypeFromSeedlist(seedlist, options) {\r\n  const replicaSet = options.replicaSet || options.setName || options.rs_name;\r\n  if (seedlist.length === 1 && !replicaSet) return TopologyType.Single;\r\n  if (replicaSet) return TopologyType.ReplicaSetNoPrimary;\r\n  return TopologyType.Unknown;\r\n}\r\n\r\nfunction randomSelection(array) {\r\n  return array[Math.floor(Math.random() * array.length)];\r\n}\r\n\r\n/**\r\n * Selects servers using the provided selector\r\n *\r\n * @private\r\n * @param {Topology} topology The topology to select servers from\r\n * @param {function} selector The actual predicate used for selecting servers\r\n * @param {Number} timeout The max time we are willing wait for selection\r\n * @param {Number} start A high precision timestamp for the start of the selection process\r\n * @param {function} callback The callback used to convey errors or the resultant servers\r\n */\r\nfunction selectServers(topology, selector, timeout, start, callback) {\r\n  const duration = calculateDurationInMs(start);\r\n  if (duration >= timeout) {\r\n    return callback(new MongoTimeoutError(`Server selection timed out after ${timeout} ms`));\r\n  }\r\n\r\n  // ensure we are connected\r\n  if (!topology.s.connected) {\r\n    topology.connect();\r\n\r\n    // we want to make sure we're still within the requested timeout window\r\n    const failToConnectTimer = setTimeout(() => {\r\n      topology.removeListener('connect', connectHandler);\r\n      callback(new MongoTimeoutError('Server selection timed out waiting to connect'));\r\n    }, timeout - duration);\r\n\r\n    const connectHandler = () => {\r\n      clearTimeout(failToConnectTimer);\r\n      selectServers(topology, selector, timeout, process.hrtime(), callback);\r\n    };\r\n\r\n    topology.once('connect', connectHandler);\r\n    return;\r\n  }\r\n\r\n  // otherwise, attempt server selection\r\n  const serverDescriptions = Array.from(topology.description.servers.values());\r\n  let descriptions;\r\n\r\n  // support server selection by options with readPreference\r\n  if (typeof selector === 'object') {\r\n    const readPreference = selector.readPreference\r\n      ? selector.readPreference\r\n      : ReadPreference.primary;\r\n\r\n    selector = readPreferenceServerSelector(readPreference);\r\n  }\r\n\r\n  try {\r\n    descriptions = selector\r\n      ? selector(topology.description, serverDescriptions)\r\n      : serverDescriptions;\r\n  } catch (e) {\r\n    return callback(e, null);\r\n  }\r\n\r\n  if (descriptions.length) {\r\n    const servers = descriptions.map(description => topology.s.servers.get(description.address));\r\n    return callback(null, servers);\r\n  }\r\n\r\n  const retrySelection = () => {\r\n    // clear all existing monitor timers\r\n    topology.s.monitorTimers.map(timer => clearTimeout(timer));\r\n    topology.s.monitorTimers = [];\r\n\r\n    // ensure all server monitors attempt monitoring soon\r\n    topology.s.servers.forEach(server => {\r\n      const timer = setTimeout(\r\n        () => server.monitor({ heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS }),\r\n        TOPOLOGY_DEFAULTS.minHeartbeatFrequencyMS\r\n      );\r\n\r\n      topology.s.monitorTimers.push(timer);\r\n    });\r\n\r\n    const descriptionChangedHandler = () => {\r\n      // successful iteration, clear the check timer\r\n      clearTimeout(iterationTimer);\r\n      topology.s.iterationTimers.splice(timerIndex, 1);\r\n\r\n      if (topology.description.error) {\r\n        callback(topology.description.error, null);\r\n        return;\r\n      }\r\n\r\n      // topology description has changed due to monitoring, reattempt server selection\r\n      selectServers(topology, selector, timeout, start, callback);\r\n    };\r\n\r\n    const iterationTimer = setTimeout(() => {\r\n      topology.removeListener('topologyDescriptionChanged', descriptionChangedHandler);\r\n      callback(new MongoTimeoutError(`Server selection timed out after ${timeout} ms`));\r\n    }, timeout - duration);\r\n\r\n    // track this timer in case we need to clean it up outside this loop\r\n    const timerIndex = topology.s.iterationTimers.push(iterationTimer);\r\n\r\n    topology.once('topologyDescriptionChanged', descriptionChangedHandler);\r\n  };\r\n\r\n  retrySelection();\r\n}\r\n\r\nfunction createAndConnectServer(topology, serverDescription) {\r\n  topology.emit(\r\n    'serverOpening',\r\n    new monitoring.ServerOpeningEvent(topology.s.id, serverDescription.address)\r\n  );\r\n\r\n  const server = new Server(serverDescription, topology.s.options, topology);\r\n  relayEvents(server, topology, SERVER_RELAY_EVENTS);\r\n\r\n  server.once('connect', serverConnectEventHandler(server, topology));\r\n  server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));\r\n  server.on('error', serverErrorEventHandler(server, topology));\r\n  server.on('close', () => topology.emit('close', server));\r\n  server.connect();\r\n  return server;\r\n}\r\n\r\n/**\r\n * Create `Server` instances for all initially known servers, connect them, and assign\r\n * them to the passed in `Topology`.\r\n *\r\n * @param {Topology} topology The topology responsible for the servers\r\n * @param {ServerDescription[]} serverDescriptions A list of server descriptions to connect\r\n */\r\nfunction connectServers(topology, serverDescriptions) {\r\n  topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {\r\n    const server = createAndConnectServer(topology, serverDescription);\r\n    servers.set(serverDescription.address, server);\r\n    return servers;\r\n  }, new Map());\r\n}\r\n\r\nfunction updateServers(topology, incomingServerDescription) {\r\n  // update the internal server's description\r\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\r\n    const server = topology.s.servers.get(incomingServerDescription.address);\r\n    server.s.description = incomingServerDescription;\r\n  }\r\n\r\n  // add new servers for all descriptions we currently don't know about locally\r\n  for (const serverDescription of topology.description.servers.values()) {\r\n    if (!topology.s.servers.has(serverDescription.address)) {\r\n      const server = createAndConnectServer(topology, serverDescription);\r\n      topology.s.servers.set(serverDescription.address, server);\r\n    }\r\n  }\r\n\r\n  // for all servers no longer known, remove their descriptions and destroy their instances\r\n  for (const entry of topology.s.servers) {\r\n    const serverAddress = entry[0];\r\n    if (topology.description.hasServer(serverAddress)) {\r\n      continue;\r\n    }\r\n\r\n    const server = topology.s.servers.get(serverAddress);\r\n    topology.s.servers.delete(serverAddress);\r\n\r\n    // prepare server for garbage collection\r\n    destroyServer(server, topology);\r\n  }\r\n}\r\n\r\nfunction serverConnectEventHandler(server, topology) {\r\n  return function(/* isMaster, err */) {\r\n    server.monitor({\r\n      initial: true,\r\n      heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS\r\n    });\r\n  };\r\n}\r\n\r\nfunction serverErrorEventHandler(server, topology) {\r\n  return function(err) {\r\n    topology.emit(\r\n      'serverClosed',\r\n      new monitoring.ServerClosedEvent(topology.s.id, server.description.address)\r\n    );\r\n\r\n    if (isSDAMUnrecoverableError(err, server)) {\r\n      resetServerState(server, err, { clearPool: true });\r\n      return;\r\n    }\r\n\r\n    resetServerState(server, err);\r\n  };\r\n}\r\n\r\nfunction executeWriteOperation(args, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\r\n  const topology = args.topology;\r\n  const op = args.op;\r\n  const ns = args.ns;\r\n  const ops = args.ops;\r\n\r\n  const willRetryWrite =\r\n    !args.retrying &&\r\n    !!options.retryWrites &&\r\n    options.session &&\r\n    isRetryableWritesSupported(topology) &&\r\n    !options.session.inTransaction();\r\n\r\n  topology.selectServer(writableServerSelector(), options, (err, server) => {\r\n    if (err) {\r\n      callback(err, null);\r\n      return;\r\n    }\r\n\r\n    const handler = (err, result) => {\r\n      if (!err) return callback(null, result);\r\n      if (!isRetryableError(err)) {\r\n        err = getMMAPError(err);\r\n        return callback(err);\r\n      }\r\n\r\n      if (willRetryWrite) {\r\n        const newArgs = Object.assign({}, args, { retrying: true });\r\n        return executeWriteOperation(newArgs, options, callback);\r\n      }\r\n\r\n      return callback(err);\r\n    };\r\n\r\n    if (callback.operationId) {\r\n      handler.operationId = callback.operationId;\r\n    }\r\n\r\n    // increment and assign txnNumber\r\n    if (willRetryWrite) {\r\n      options.session.incrementTransactionNumber();\r\n      options.willRetryWrite = willRetryWrite;\r\n    }\r\n\r\n    // execute the write operation\r\n    server[op](ns, ops, options, handler);\r\n  });\r\n}\r\n\r\n/**\r\n * Resets the internal state of this server to `Unknown` by simulating an empty ismaster\r\n *\r\n * @private\r\n * @param {Server} server\r\n * @param {MongoError} error The error that caused the state reset\r\n * @param {object} [options] Optional settings\r\n * @param {boolean} [options.clearPool=false] Pool should be cleared out on state reset\r\n */\r\nfunction resetServerState(server, error, options) {\r\n  options = Object.assign({}, { clearPool: false }, options);\r\n\r\n  function resetState() {\r\n    server.emit(\r\n      'descriptionReceived',\r\n      new ServerDescription(server.description.address, null, { error })\r\n    );\r\n    server.monitor();\r\n  }\r\n\r\n  if (options.clearPool && server.s.pool) {\r\n    server.s.pool.reset(() => resetState());\r\n    return;\r\n  }\r\n\r\n  resetState();\r\n}\r\n\r\nfunction translateReadPreference(options) {\r\n  if (options.readPreference == null) {\r\n    return;\r\n  }\r\n\r\n  let r = options.readPreference;\r\n  if (typeof r === 'string') {\r\n    options.readPreference = new ReadPreference(r);\r\n  } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\r\n    const mode = r.mode || r.preference;\r\n    if (mode && typeof mode === 'string') {\r\n      options.readPreference = new ReadPreference(mode, r.tags, {\r\n        maxStalenessSeconds: r.maxStalenessSeconds\r\n      });\r\n    }\r\n  } else if (!(r instanceof ReadPreference)) {\r\n    throw new TypeError('Invalid read preference: ' + r);\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\nfunction srvPollingHandler(topology) {\r\n  return function handleSrvPolling(ev) {\r\n    const previousTopologyDescription = topology.s.description;\r\n    topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);\r\n    if (topology.s.description === previousTopologyDescription) {\r\n      // Nothing changed, so return\r\n      return;\r\n    }\r\n\r\n    updateServers(topology);\r\n\r\n    topology.emit(\r\n      'topologyDescriptionChanged',\r\n      new monitoring.TopologyDescriptionChangedEvent(\r\n        topology.s.id,\r\n        previousTopologyDescription,\r\n        topology.s.description\r\n      )\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * A server opening SDAM monitoring event\r\n *\r\n * @event Topology#serverOpening\r\n * @type {ServerOpeningEvent}\r\n */\r\n\r\n/**\r\n * A server closed SDAM monitoring event\r\n *\r\n * @event Topology#serverClosed\r\n * @type {ServerClosedEvent}\r\n */\r\n\r\n/**\r\n * A server description SDAM change monitoring event\r\n *\r\n * @event Topology#serverDescriptionChanged\r\n * @type {ServerDescriptionChangedEvent}\r\n */\r\n\r\n/**\r\n * A topology open SDAM event\r\n *\r\n * @event Topology#topologyOpening\r\n * @type {TopologyOpeningEvent}\r\n */\r\n\r\n/**\r\n * A topology closed SDAM event\r\n *\r\n * @event Topology#topologyClosed\r\n * @type {TopologyClosedEvent}\r\n */\r\n\r\n/**\r\n * A topology structure SDAM change event\r\n *\r\n * @event Topology#topologyDescriptionChanged\r\n * @type {TopologyDescriptionChangedEvent}\r\n */\r\n\r\n/**\r\n * A topology serverHeartbeatStarted SDAM event\r\n *\r\n * @event Topology#serverHeartbeatStarted\r\n * @type {ServerHeartbeatStartedEvent}\r\n */\r\n\r\n/**\r\n * A topology serverHeartbeatFailed SDAM event\r\n *\r\n * @event Topology#serverHeartbeatFailed\r\n * @type {ServerHearbeatFailedEvent}\r\n */\r\n\r\n/**\r\n * A topology serverHeartbeatSucceeded SDAM change event\r\n *\r\n * @event Topology#serverHeartbeatSucceeded\r\n * @type {ServerHeartbeatSucceededEvent}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command was started, if command monitoring is enabled\r\n *\r\n * @event Topology#commandStarted\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command succeeded, if command monitoring is enabled\r\n *\r\n * @event Topology#commandSucceeded\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command failed, if command monitoring is enabled\r\n *\r\n * @event Topology#commandFailed\r\n * @type {object}\r\n */\r\n\r\nmodule.exports = Topology;\r\n"]},"metadata":{},"sourceType":"script"}