{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst MongoError = require('../error').MongoError;\n\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nlet saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nvar parsePayload = function (payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function (username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty'); // Use node md5 generator\n\n  var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n}; // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nvar _hiCachePurge = function () {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n/**\r\n * Creates a new ScramSHA authentication mechanism\r\n * @class\r\n * @extends AuthProvider\r\n */\n\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  static _getError(err, r) {\n    if (err) {\n      return err;\n    }\n\n    if (r.$err || r.errmsg) {\n      return new MongoError(r);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\n    let username = credentials.username;\n    const password = credentials.password;\n    const db = credentials.source;\n    const cryptoMethod = this.cryptoMethod;\n    let mechanism = 'SCRAM-SHA-1';\n    let processedPassword;\n\n    if (cryptoMethod === 'sha256') {\n      mechanism = 'SCRAM-SHA-256';\n      processedPassword = saslprep ? saslprep(password) : password;\n    } else {\n      try {\n        processedPassword = passwordDigest(username, password);\n      } catch (e) {\n        return callback(e);\n      }\n    } // Clean up the user\n\n\n    username = username.replace('=', '=3D').replace(',', '=2C'); // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n\n    const firstBare = Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce, 'utf8')]); // Build command structure\n\n    const saslStartCmd = {\n      saslStart: 1,\n      mechanism,\n      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n      autoAuthorize: 1\n    }; // Write the commmand on the connection\n\n    sendAuthCommand(connection, `${db}.$cmd`, saslStartCmd, (err, r) => {\n      let tmpError = ScramSHA._getError(err, r);\n\n      if (tmpError) {\n        return callback(tmpError, null);\n      }\n\n      const payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\n      const dict = parsePayload(payload.value());\n      const iterations = parseInt(dict.i, 10);\n      const salt = dict.s;\n      const rnonce = dict.r; // Set up start of proof\n\n      const withoutProof = `c=biws,r=${rnonce}`;\n      const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n\n      if (iterations && iterations < 4096) {\n        const error = new MongoError(`Server returned an invalid iteration count ${iterations}`);\n        return callback(error, false);\n      }\n\n      const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n      const storedKey = H(cryptoMethod, clientKey);\n      const authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\n      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n      const clientProof = `p=${xor(clientKey, clientSignature)}`;\n      const clientFinal = [withoutProof, clientProof].join(',');\n      const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: r.conversationId,\n        payload: new Binary(Buffer.from(clientFinal))\n      };\n      sendAuthCommand(connection, `${db}.$cmd`, saslContinueCmd, (err, r) => {\n        if (!r || r.done !== false) {\n          return callback(err, r);\n        }\n\n        const retrySaslContinueCmd = {\n          saslContinue: 1,\n          conversationId: r.conversationId,\n          payload: Buffer.alloc(0)\n        };\n        sendAuthCommand(connection, `${db}.$cmd`, retrySaslContinueCmd, callback);\n      });\n    });\n  }\n  /**\r\n   * Implementation of authentication for a single connection\r\n   * @override\r\n   */\n\n\n  _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\n    // Create a random nonce\n    crypto.randomBytes(24, (err, buff) => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return this._executeScram(sendAuthCommand, connection, credentials, buff.toString('base64'), callback);\n    });\n  }\n  /**\r\n   * Authenticate\r\n   * @override\r\n   * @method\r\n   */\n\n\n  auth(sendAuthCommand, connections, credentials, callback) {\n    this._checkSaslprep();\n\n    super.auth(sendAuthCommand, connections, credentials, callback);\n  }\n\n  _checkSaslprep() {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256') {\n      if (!saslprep) {\n        console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n    }\n  }\n\n}\n/**\r\n * Creates a new ScramSHA1 authentication mechanism\r\n * @class\r\n * @extends ScramSHA\r\n */\n\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n\n}\n/**\r\n * Creates a new ScramSHA256 authentication mechanism\r\n * @class\r\n * @extends ScramSHA\r\n */\n\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n\n}\n\nmodule.exports = {\n  ScramSHA1,\n  ScramSHA256\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/core/auth/scram.js"],"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","BSON","Binary","saslprep","e","parsePayload","payload","dict","parts","split","i","length","valueParts","passwordDigest","username","password","md5","createHash","update","digest","xor","a","b","isBuffer","from","Math","max","res","push","toString","H","method","text","HMAC","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","HI","data","salt","iterations","cryptoMethod","join","undefined","saltedData","pbkdf2Sync","ScramSHA","constructor","bson","_getError","err","r","$err","errmsg","_executeScram","sendAuthCommand","connection","credentials","nonce","callback","db","source","mechanism","processedPassword","replace","firstBare","concat","saslStartCmd","saslStart","autoAuthorize","tmpError","value","parseInt","s","rnonce","withoutProof","saltedPassword","error","clientKey","storedKey","authMessage","clientSignature","clientProof","clientFinal","saslContinueCmd","saslContinue","conversationId","done","retrySaslContinueCmd","alloc","_authenticateSingleConnection","randomBytes","buff","auth","connections","_checkSaslprep","console","warn","ScramSHA1","ScramSHA256","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst crypto = require('crypto');\r\nconst Buffer = require('safe-buffer').Buffer;\r\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\r\nconst MongoError = require('../error').MongoError;\r\nconst AuthProvider = require('./auth_provider').AuthProvider;\r\n\r\nconst BSON = retrieveBSON();\r\nconst Binary = BSON.Binary;\r\n\r\nlet saslprep;\r\ntry {\r\n  saslprep = require('saslprep');\r\n} catch (e) {\r\n  // don't do anything;\r\n}\r\n\r\nvar parsePayload = function(payload) {\r\n  var dict = {};\r\n  var parts = payload.split(',');\r\n\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var valueParts = parts[i].split('=');\r\n    dict[valueParts[0]] = valueParts[1];\r\n  }\r\n\r\n  return dict;\r\n};\r\n\r\nvar passwordDigest = function(username, password) {\r\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\r\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\r\n  if (password.length === 0) throw new MongoError('password cannot be empty');\r\n  // Use node md5 generator\r\n  var md5 = crypto.createHash('md5');\r\n  // Generate keys used for authentication\r\n  md5.update(username + ':mongo:' + password, 'utf8');\r\n  return md5.digest('hex');\r\n};\r\n\r\n// XOR two buffers\r\nfunction xor(a, b) {\r\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\r\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\r\n  const length = Math.max(a.length, b.length);\r\n  const res = [];\r\n\r\n  for (let i = 0; i < length; i += 1) {\r\n    res.push(a[i] ^ b[i]);\r\n  }\r\n\r\n  return Buffer.from(res).toString('base64');\r\n}\r\n\r\nfunction H(method, text) {\r\n  return crypto\r\n    .createHash(method)\r\n    .update(text)\r\n    .digest();\r\n}\r\n\r\nfunction HMAC(method, key, text) {\r\n  return crypto\r\n    .createHmac(method, key)\r\n    .update(text)\r\n    .digest();\r\n}\r\n\r\nvar _hiCache = {};\r\nvar _hiCacheCount = 0;\r\nvar _hiCachePurge = function() {\r\n  _hiCache = {};\r\n  _hiCacheCount = 0;\r\n};\r\n\r\nconst hiLengthMap = {\r\n  sha256: 32,\r\n  sha1: 20\r\n};\r\n\r\nfunction HI(data, salt, iterations, cryptoMethod) {\r\n  // omit the work if already generated\r\n  const key = [data, salt.toString('base64'), iterations].join('_');\r\n  if (_hiCache[key] !== undefined) {\r\n    return _hiCache[key];\r\n  }\r\n\r\n  // generate the salt\r\n  const saltedData = crypto.pbkdf2Sync(\r\n    data,\r\n    salt,\r\n    iterations,\r\n    hiLengthMap[cryptoMethod],\r\n    cryptoMethod\r\n  );\r\n\r\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\r\n  if (_hiCacheCount >= 200) {\r\n    _hiCachePurge();\r\n  }\r\n\r\n  _hiCache[key] = saltedData;\r\n  _hiCacheCount += 1;\r\n  return saltedData;\r\n}\r\n\r\n/**\r\n * Creates a new ScramSHA authentication mechanism\r\n * @class\r\n * @extends AuthProvider\r\n */\r\nclass ScramSHA extends AuthProvider {\r\n  constructor(bson, cryptoMethod) {\r\n    super(bson);\r\n    this.cryptoMethod = cryptoMethod || 'sha1';\r\n  }\r\n\r\n  static _getError(err, r) {\r\n    if (err) {\r\n      return err;\r\n    }\r\n\r\n    if (r.$err || r.errmsg) {\r\n      return new MongoError(r);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\r\n    let username = credentials.username;\r\n    const password = credentials.password;\r\n    const db = credentials.source;\r\n\r\n    const cryptoMethod = this.cryptoMethod;\r\n    let mechanism = 'SCRAM-SHA-1';\r\n    let processedPassword;\r\n\r\n    if (cryptoMethod === 'sha256') {\r\n      mechanism = 'SCRAM-SHA-256';\r\n\r\n      processedPassword = saslprep ? saslprep(password) : password;\r\n    } else {\r\n      try {\r\n        processedPassword = passwordDigest(username, password);\r\n      } catch (e) {\r\n        return callback(e);\r\n      }\r\n    }\r\n\r\n    // Clean up the user\r\n    username = username.replace('=', '=3D').replace(',', '=2C');\r\n\r\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\r\n    // Since the username is not sasl-prep-d, we need to do this here.\r\n    const firstBare = Buffer.concat([\r\n      Buffer.from('n=', 'utf8'),\r\n      Buffer.from(username, 'utf8'),\r\n      Buffer.from(',r=', 'utf8'),\r\n      Buffer.from(nonce, 'utf8')\r\n    ]);\r\n\r\n    // Build command structure\r\n    const saslStartCmd = {\r\n      saslStart: 1,\r\n      mechanism,\r\n      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\r\n      autoAuthorize: 1\r\n    };\r\n\r\n    // Write the commmand on the connection\r\n    sendAuthCommand(connection, `${db}.$cmd`, saslStartCmd, (err, r) => {\r\n      let tmpError = ScramSHA._getError(err, r);\r\n      if (tmpError) {\r\n        return callback(tmpError, null);\r\n      }\r\n\r\n      const payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\r\n      const dict = parsePayload(payload.value());\r\n      const iterations = parseInt(dict.i, 10);\r\n      const salt = dict.s;\r\n      const rnonce = dict.r;\r\n\r\n      // Set up start of proof\r\n      const withoutProof = `c=biws,r=${rnonce}`;\r\n      const saltedPassword = HI(\r\n        processedPassword,\r\n        Buffer.from(salt, 'base64'),\r\n        iterations,\r\n        cryptoMethod\r\n      );\r\n\r\n      if (iterations && iterations < 4096) {\r\n        const error = new MongoError(`Server returned an invalid iteration count ${iterations}`);\r\n        return callback(error, false);\r\n      }\r\n\r\n      const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\r\n      const storedKey = H(cryptoMethod, clientKey);\r\n      const authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\r\n\r\n      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\r\n      const clientProof = `p=${xor(clientKey, clientSignature)}`;\r\n      const clientFinal = [withoutProof, clientProof].join(',');\r\n      const saslContinueCmd = {\r\n        saslContinue: 1,\r\n        conversationId: r.conversationId,\r\n        payload: new Binary(Buffer.from(clientFinal))\r\n      };\r\n\r\n      sendAuthCommand(connection, `${db}.$cmd`, saslContinueCmd, (err, r) => {\r\n        if (!r || r.done !== false) {\r\n          return callback(err, r);\r\n        }\r\n\r\n        const retrySaslContinueCmd = {\r\n          saslContinue: 1,\r\n          conversationId: r.conversationId,\r\n          payload: Buffer.alloc(0)\r\n        };\r\n\r\n        sendAuthCommand(connection, `${db}.$cmd`, retrySaslContinueCmd, callback);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Implementation of authentication for a single connection\r\n   * @override\r\n   */\r\n  _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\r\n    // Create a random nonce\r\n    crypto.randomBytes(24, (err, buff) => {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n\r\n      return this._executeScram(\r\n        sendAuthCommand,\r\n        connection,\r\n        credentials,\r\n        buff.toString('base64'),\r\n        callback\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Authenticate\r\n   * @override\r\n   * @method\r\n   */\r\n  auth(sendAuthCommand, connections, credentials, callback) {\r\n    this._checkSaslprep();\r\n    super.auth(sendAuthCommand, connections, credentials, callback);\r\n  }\r\n\r\n  _checkSaslprep() {\r\n    const cryptoMethod = this.cryptoMethod;\r\n\r\n    if (cryptoMethod === 'sha256') {\r\n      if (!saslprep) {\r\n        console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new ScramSHA1 authentication mechanism\r\n * @class\r\n * @extends ScramSHA\r\n */\r\nclass ScramSHA1 extends ScramSHA {\r\n  constructor(bson) {\r\n    super(bson, 'sha1');\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new ScramSHA256 authentication mechanism\r\n * @class\r\n * @extends ScramSHA\r\n */\r\nclass ScramSHA256 extends ScramSHA {\r\n  constructor(bson) {\r\n    super(bson, 'sha256');\r\n  }\r\n}\r\n\r\nmodule.exports = { ScramSHA1, ScramSHA256 };\r\n"]},"metadata":{},"sourceType":"script"}