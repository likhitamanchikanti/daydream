{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst createIndexDb = require('./db_ops').createIndex;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst ensureIndexDb = require('./db_ops').ensureIndex;\n\nconst evaluate = require('./db_ops').evaluate;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst resolveReadPreference = require('../utils').resolveReadPreference;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst indexInformationDb = require('./db_ops').indexInformation;\n\nconst Long = require('../core').BSON.Long;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst insertDocuments = require('./common_functions').insertDocuments;\n\nconst updateDocuments = require('./common_functions').updateDocuments;\n/**\r\n * Group function helper\r\n * @ignore\r\n */\n// var groupFunction = function () {\n//   var c = db[ns].find(condition);\n//   var map = new Map();\n//   var reduce_function = reduce;\n//\n//   while (c.hasNext()) {\n//     var obj = c.next();\n//     var key = {};\n//\n//     for (var i = 0, len = keys.length; i < len; ++i) {\n//       var k = keys[i];\n//       key[k] = obj[k];\n//     }\n//\n//     var aggObj = map.get(key);\n//\n//     if (aggObj == null) {\n//       var newObj = Object.extend({}, key);\n//       aggObj = Object.extend(newObj, initial);\n//       map.put(key, aggObj);\n//     }\n//\n//     reduce_function(obj, aggObj);\n//   }\n//\n//   return { \"result\": map.values() };\n// }.toString();\n\n\nconst groupFunction = 'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}'; // Check the update operation to ensure it has atomic operators.\n\nfunction checkForAtomicOperators(update) {\n  if (Array.isArray(update)) {\n    return update.reduce((err, u) => err || checkForAtomicOperators(u), null);\n  }\n\n  const keys = Object.keys(update); // same errors as the server would give for update doc lacking atomic operators\n\n  if (keys.length === 0) {\n    return toError('The update operation document must contain at least one atomic operator.');\n  }\n\n  if (keys[0][0] !== '$') {\n    return toError('the update operation document must contain atomic operators.');\n  }\n}\n/**\r\n * Create an index on the db and collection.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction createIndex(coll, fieldOrSpec, options, callback) {\n  createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n/**\r\n * Create multiple indexes in the collection. This method is only supported for\r\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\r\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {array} indexSpecs An array of index specifications to be created\r\n * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction createIndexes(coll, indexSpecs, options, callback) {\n  const capabilities = coll.s.topology.capabilities(); // Ensure we generate the correct name if the parameter is not set\n\n  for (let i = 0; i < indexSpecs.length; i++) {\n    if (indexSpecs[i].name == null) {\n      const keys = []; // Did the user pass in a collation, check if our write server supports it\n\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      }\n\n      for (let name in indexSpecs[i].key) {\n        keys.push(`${name}_${indexSpecs[i].key[name]}`);\n      } // Set the name\n\n\n      indexSpecs[i].name = keys.join('_');\n    }\n  }\n\n  options = Object.assign({}, options, {\n    readPreference: ReadPreference.PRIMARY\n  }); // Execute the index\n\n  executeCommand(coll.s.db, {\n    createIndexes: coll.collectionName,\n    indexes: indexSpecs\n  }, options, callback);\n}\n/**\r\n * Ensure that an index exists. If the index does not exist, this function creates it.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction ensureIndex(coll, fieldOrSpec, options, callback) {\n  ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n/**\r\n * Run a group command across a collection.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\r\n * @param {object} condition An optional condition that must be true for a row to be considered.\r\n * @param {object} initial Initial value of the aggregation counter object.\r\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\r\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\r\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\r\n * @param {object} [options] Optional settings. See Collection.prototype.group for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\r\n */\n\n\nfunction group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {\n  // Execute using the command\n  if (command) {\n    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);\n    const selector = {\n      group: {\n        ns: coll.collectionName,\n        $reduce: reduceFunction,\n        cond: condition,\n        initial: initial,\n        out: 'inline'\n      }\n    }; // if finalize is defined\n\n    if (finalize != null) selector.group['finalize'] = finalize; // Set up group selector\n\n    if ('function' === typeof keys || keys && keys._bsontype === 'Code') {\n      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);\n    } else {\n      const hash = {};\n      keys.forEach(key => {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n    options.readPreference = resolveReadPreference(coll, options); // Do we have a readConcern specified\n\n    decorateWithReadConcern(selector, coll, options); // Have we specified collation\n\n    try {\n      decorateWithCollation(selector, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    } // Execute command\n\n\n    executeCommand(coll.s.db, selector, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, result.retval);\n    });\n  } else {\n    // Create execution scope\n    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};\n    scope.ns = coll.collectionName;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial; // Pass in the function text to execute within mongodb.\n\n    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, results.result || results);\n    });\n  }\n}\n/**\r\n * Retrieve all the indexes on the collection.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {Object} [options] Optional settings. See Collection.prototype.indexes for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction indexes(coll, options, callback) {\n  options = Object.assign({}, {\n    full: true\n  }, options);\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n/**\r\n * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(string|array)} indexes One or more index names to check.\r\n * @param {Object} [options] Optional settings. See Collection.prototype.indexExists for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction indexExists(coll, indexes, options, callback) {\n  indexInformation(coll, options, (err, indexInformation) => {\n    // If we have an error return\n    if (err != null) return handleCallback(callback, err, null); // Let's check for the index names\n\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null); // Check in list of indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexInformation[indexes[i]] == null) {\n        return handleCallback(callback, null, false);\n      }\n    } // All keys found return true\n\n\n    return handleCallback(callback, null, true);\n  });\n}\n/**\r\n * Retrieve this collection's index info.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} [options] Optional settings. See Collection.prototype.indexInformation for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction indexInformation(coll, options, callback) {\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n/**\r\n * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are\r\n * no ordering guarantees for returned results.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.\r\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\r\n */\n\n\nfunction parallelCollectionScan(coll, options, callback) {\n  // Create command object\n  const commandObject = {\n    parallelCollectionScan: coll.collectionName,\n    numCursors: options.numCursors\n  }; // Do we have a readConcern specified\n\n  decorateWithReadConcern(commandObject, coll, options); // Store the raw value\n\n  const raw = options.raw;\n  delete options['raw']; // Execute the command\n\n  executeCommand(coll.s.db, commandObject, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, new Error('no result returned for parallelCollectionScan'), null);\n    options = Object.assign({\n      explicitlyIgnoreSession: true\n    }, options);\n    const cursors = []; // Add the raw back to the option\n\n    if (raw) options.raw = raw; // Create command cursors for each item\n\n    for (let i = 0; i < result.cursors.length; i++) {\n      const rawId = result.cursors[i].cursor.id; // Convert cursorId to Long if needed\n\n      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId; // Add a command cursor\n\n      cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));\n    }\n\n    handleCallback(callback, null, cursors);\n  });\n}\n/**\r\n * Save a document.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} doc Document to save\r\n * @param {object} [options] Optional settings. See Collection.prototype.save for a list of options.\r\n * @param {Collection~writeOpCallback} [callback] The command result callback\r\n * @deprecated use insertOne, insertMany, updateOne or updateMany\r\n */\n\n\nfunction save(coll, doc, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern(Object.assign({}, options), {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Establish if we need to perform an insert or update\n\n  if (doc._id != null) {\n    finalOptions.upsert = true;\n    return updateDocuments(coll, {\n      _id: doc._id\n    }, doc, finalOptions, callback);\n  } // Insert the document\n\n\n  insertDocuments(coll, [doc], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (doc == null) return handleCallback(callback, null, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n}\n\nmodule.exports = {\n  checkForAtomicOperators,\n  createIndex,\n  createIndexes,\n  ensureIndex,\n  group,\n  indexes,\n  indexExists,\n  indexInformation,\n  parallelCollectionScan,\n  save\n};","map":{"version":3,"sources":["C:/Users/mehta/daydream/node_modules/mongodb/lib/operations/collection_ops.js"],"names":["applyWriteConcern","require","Code","BSON","createIndexDb","createIndex","decorateWithCollation","decorateWithReadConcern","ensureIndexDb","ensureIndex","evaluate","executeCommand","resolveReadPreference","handleCallback","indexInformationDb","indexInformation","Long","MongoError","ReadPreference","toError","insertDocuments","updateDocuments","groupFunction","checkForAtomicOperators","update","Array","isArray","reduce","err","u","keys","Object","length","coll","fieldOrSpec","options","callback","s","db","collectionName","createIndexes","indexSpecs","capabilities","topology","i","name","collation","commandsTakeCollation","key","push","join","assign","readPreference","PRIMARY","indexes","group","condition","initial","finalize","command","reduceFunction","_bsontype","selector","ns","$reduce","cond","out","$keyf","hash","forEach","result","retval","scope","groupfn","replace","toString","results","full","indexExists","parallelCollectionScan","commandObject","numCursors","raw","Error","explicitlyIgnoreSession","cursors","rawId","cursor","id","cursorId","fromNumber","namespace","save","doc","finalOptions","collection","_id","upsert","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst applyWriteConcern = require('../utils').applyWriteConcern;\r\nconst Code = require('../core').BSON.Code;\r\nconst createIndexDb = require('./db_ops').createIndex;\r\nconst decorateWithCollation = require('../utils').decorateWithCollation;\r\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\r\nconst ensureIndexDb = require('./db_ops').ensureIndex;\r\nconst evaluate = require('./db_ops').evaluate;\r\nconst executeCommand = require('./db_ops').executeCommand;\r\nconst resolveReadPreference = require('../utils').resolveReadPreference;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst indexInformationDb = require('./db_ops').indexInformation;\r\nconst Long = require('../core').BSON.Long;\r\nconst MongoError = require('../core').MongoError;\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst toError = require('../utils').toError;\r\nconst insertDocuments = require('./common_functions').insertDocuments;\r\nconst updateDocuments = require('./common_functions').updateDocuments;\r\n\r\n/**\r\n * Group function helper\r\n * @ignore\r\n */\r\n// var groupFunction = function () {\r\n//   var c = db[ns].find(condition);\r\n//   var map = new Map();\r\n//   var reduce_function = reduce;\r\n//\r\n//   while (c.hasNext()) {\r\n//     var obj = c.next();\r\n//     var key = {};\r\n//\r\n//     for (var i = 0, len = keys.length; i < len; ++i) {\r\n//       var k = keys[i];\r\n//       key[k] = obj[k];\r\n//     }\r\n//\r\n//     var aggObj = map.get(key);\r\n//\r\n//     if (aggObj == null) {\r\n//       var newObj = Object.extend({}, key);\r\n//       aggObj = Object.extend(newObj, initial);\r\n//       map.put(key, aggObj);\r\n//     }\r\n//\r\n//     reduce_function(obj, aggObj);\r\n//   }\r\n//\r\n//   return { \"result\": map.values() };\r\n// }.toString();\r\nconst groupFunction =\r\n  'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}';\r\n\r\n// Check the update operation to ensure it has atomic operators.\r\nfunction checkForAtomicOperators(update) {\r\n  if (Array.isArray(update)) {\r\n    return update.reduce((err, u) => err || checkForAtomicOperators(u), null);\r\n  }\r\n\r\n  const keys = Object.keys(update);\r\n\r\n  // same errors as the server would give for update doc lacking atomic operators\r\n  if (keys.length === 0) {\r\n    return toError('The update operation document must contain at least one atomic operator.');\r\n  }\r\n\r\n  if (keys[0][0] !== '$') {\r\n    return toError('the update operation document must contain atomic operators.');\r\n  }\r\n}\r\n\r\n/**\r\n * Create an index on the db and collection.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\r\nfunction createIndex(coll, fieldOrSpec, options, callback) {\r\n  createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\r\n}\r\n\r\n/**\r\n * Create multiple indexes in the collection. This method is only supported for\r\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\r\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {array} indexSpecs An array of index specifications to be created\r\n * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\r\nfunction createIndexes(coll, indexSpecs, options, callback) {\r\n  const capabilities = coll.s.topology.capabilities();\r\n\r\n  // Ensure we generate the correct name if the parameter is not set\r\n  for (let i = 0; i < indexSpecs.length; i++) {\r\n    if (indexSpecs[i].name == null) {\r\n      const keys = [];\r\n\r\n      // Did the user pass in a collation, check if our write server supports it\r\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\r\n        return callback(new MongoError('server/primary/mongos does not support collation'));\r\n      }\r\n\r\n      for (let name in indexSpecs[i].key) {\r\n        keys.push(`${name}_${indexSpecs[i].key[name]}`);\r\n      }\r\n\r\n      // Set the name\r\n      indexSpecs[i].name = keys.join('_');\r\n    }\r\n  }\r\n\r\n  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });\r\n\r\n  // Execute the index\r\n  executeCommand(\r\n    coll.s.db,\r\n    {\r\n      createIndexes: coll.collectionName,\r\n      indexes: indexSpecs\r\n    },\r\n    options,\r\n    callback\r\n  );\r\n}\r\n\r\n/**\r\n * Ensure that an index exists. If the index does not exist, this function creates it.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\r\nfunction ensureIndex(coll, fieldOrSpec, options, callback) {\r\n  ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\r\n}\r\n\r\n/**\r\n * Run a group command across a collection.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\r\n * @param {object} condition An optional condition that must be true for a row to be considered.\r\n * @param {object} initial Initial value of the aggregation counter object.\r\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\r\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\r\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\r\n * @param {object} [options] Optional settings. See Collection.prototype.group for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\r\n */\r\nfunction group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {\r\n  // Execute using the command\r\n  if (command) {\r\n    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);\r\n\r\n    const selector = {\r\n      group: {\r\n        ns: coll.collectionName,\r\n        $reduce: reduceFunction,\r\n        cond: condition,\r\n        initial: initial,\r\n        out: 'inline'\r\n      }\r\n    };\r\n\r\n    // if finalize is defined\r\n    if (finalize != null) selector.group['finalize'] = finalize;\r\n    // Set up group selector\r\n    if ('function' === typeof keys || (keys && keys._bsontype === 'Code')) {\r\n      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);\r\n    } else {\r\n      const hash = {};\r\n      keys.forEach(key => {\r\n        hash[key] = 1;\r\n      });\r\n      selector.group.key = hash;\r\n    }\r\n\r\n    options = Object.assign({}, options);\r\n    // Ensure we have the right read preference inheritance\r\n    options.readPreference = resolveReadPreference(coll, options);\r\n\r\n    // Do we have a readConcern specified\r\n    decorateWithReadConcern(selector, coll, options);\r\n\r\n    // Have we specified collation\r\n    try {\r\n      decorateWithCollation(selector, coll, options);\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n\r\n    // Execute command\r\n    executeCommand(coll.s.db, selector, options, (err, result) => {\r\n      if (err) return handleCallback(callback, err, null);\r\n      handleCallback(callback, null, result.retval);\r\n    });\r\n  } else {\r\n    // Create execution scope\r\n    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};\r\n\r\n    scope.ns = coll.collectionName;\r\n    scope.keys = keys;\r\n    scope.condition = condition;\r\n    scope.initial = initial;\r\n\r\n    // Pass in the function text to execute within mongodb.\r\n    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\r\n\r\n    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => {\r\n      if (err) return handleCallback(callback, err, null);\r\n      handleCallback(callback, null, results.result || results);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieve all the indexes on the collection.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {Object} [options] Optional settings. See Collection.prototype.indexes for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\r\nfunction indexes(coll, options, callback) {\r\n  options = Object.assign({}, { full: true }, options);\r\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\r\n}\r\n\r\n/**\r\n * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {(string|array)} indexes One or more index names to check.\r\n * @param {Object} [options] Optional settings. See Collection.prototype.indexExists for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\r\nfunction indexExists(coll, indexes, options, callback) {\r\n  indexInformation(coll, options, (err, indexInformation) => {\r\n    // If we have an error return\r\n    if (err != null) return handleCallback(callback, err, null);\r\n    // Let's check for the index names\r\n    if (!Array.isArray(indexes))\r\n      return handleCallback(callback, null, indexInformation[indexes] != null);\r\n    // Check in list of indexes\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      if (indexInformation[indexes[i]] == null) {\r\n        return handleCallback(callback, null, false);\r\n      }\r\n    }\r\n\r\n    // All keys found return true\r\n    return handleCallback(callback, null, true);\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieve this collection's index info.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} [options] Optional settings. See Collection.prototype.indexInformation for a list of options.\r\n * @param {Collection~resultCallback} [callback] The command result callback\r\n */\r\nfunction indexInformation(coll, options, callback) {\r\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\r\n}\r\n\r\n/**\r\n * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are\r\n * no ordering guarantees for returned results.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.\r\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\r\n */\r\nfunction parallelCollectionScan(coll, options, callback) {\r\n  // Create command object\r\n  const commandObject = {\r\n    parallelCollectionScan: coll.collectionName,\r\n    numCursors: options.numCursors\r\n  };\r\n\r\n  // Do we have a readConcern specified\r\n  decorateWithReadConcern(commandObject, coll, options);\r\n\r\n  // Store the raw value\r\n  const raw = options.raw;\r\n  delete options['raw'];\r\n\r\n  // Execute the command\r\n  executeCommand(coll.s.db, commandObject, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result == null)\r\n      return handleCallback(\r\n        callback,\r\n        new Error('no result returned for parallelCollectionScan'),\r\n        null\r\n      );\r\n\r\n    options = Object.assign({ explicitlyIgnoreSession: true }, options);\r\n\r\n    const cursors = [];\r\n    // Add the raw back to the option\r\n    if (raw) options.raw = raw;\r\n    // Create command cursors for each item\r\n    for (let i = 0; i < result.cursors.length; i++) {\r\n      const rawId = result.cursors[i].cursor.id;\r\n      // Convert cursorId to Long if needed\r\n      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId;\r\n      // Add a command cursor\r\n      cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));\r\n    }\r\n\r\n    handleCallback(callback, null, cursors);\r\n  });\r\n}\r\n\r\n/**\r\n * Save a document.\r\n *\r\n * @method\r\n * @param {Collection} a Collection instance.\r\n * @param {object} doc Document to save\r\n * @param {object} [options] Optional settings. See Collection.prototype.save for a list of options.\r\n * @param {Collection~writeOpCallback} [callback] The command result callback\r\n * @deprecated use insertOne, insertMany, updateOne or updateMany\r\n */\r\nfunction save(coll, doc, options, callback) {\r\n  // Get the write concern options\r\n  const finalOptions = applyWriteConcern(\r\n    Object.assign({}, options),\r\n    { db: coll.s.db, collection: coll },\r\n    options\r\n  );\r\n  // Establish if we need to perform an insert or update\r\n  if (doc._id != null) {\r\n    finalOptions.upsert = true;\r\n    return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);\r\n  }\r\n\r\n  // Insert the document\r\n  insertDocuments(coll, [doc], finalOptions, (err, result) => {\r\n    if (callback == null) return;\r\n    if (doc == null) return handleCallback(callback, null, null);\r\n    if (err) return handleCallback(callback, err, null);\r\n    handleCallback(callback, null, result);\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  checkForAtomicOperators,\r\n  createIndex,\r\n  createIndexes,\r\n  ensureIndex,\r\n  group,\r\n  indexes,\r\n  indexExists,\r\n  indexInformation,\r\n  parallelCollectionScan,\r\n  save\r\n};\r\n"]},"metadata":{},"sourceType":"script"}